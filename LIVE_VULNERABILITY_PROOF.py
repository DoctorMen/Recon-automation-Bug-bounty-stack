#!/usr/bin/env python3
"""
Live Vulnerability Proof System
Demonstrates real, verifiable vulnerabilities on authorized targets
No hallucinations - only actual findings with reproducible proof
"""

import json
import requests
import time
import sys
from datetime import datetime
from urllib.parse import urljoin, urlparse
import re

class LiveVulnerabilityProof:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        })
        self.findings = []
        self.verified = []
        
    def check_authorization(self, target):
        """Verify target is authorized before testing"""
        try:
            with open('targets.txt', 'r') as f:
                authorized_targets = f.read()
            
            # Extract domain from target
            if target.startswith('https://'):
                domain = target[8:].split('/')[0]
            elif target.startswith('http://'):
                domain = target[7:].split('/')[0]
            else:
                domain = target.split('/')[0]
            
            # Check if domain is in authorized list
            if domain in authorized_targets:
                return True
            return False
        except:
            return False
    
    def test_security_headers(self, target):
        """Test for missing security headers (real, verifiable finding)"""
        print(f"[*] Testing security headers on {target}")
        
        try:
            response = self.session.get(target, timeout=10, verify=False)
            headers = response.headers
            
            findings = []
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'Content-Security-Policy': 'XSS and data injection protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'X-Content-Type-Options': 'MIME-type sniffing protection',
                'Referrer-Policy': 'Referrer information control',
                'Permissions-Policy': 'Feature policy control'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    finding = {
                        'type': 'missing_security_header',
                        'header': header,
                        'description': description,
                        'severity': 'medium',
                        'target': target,
                        'proof': f'Header "{header}" is missing in response',
                        'response_headers': dict(headers),
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
            
            return findings
            
        except Exception as e:
            print(f"[!] Error testing {target}: {e}")
            return []
    
    def test_information_disclosure(self, target):
        """Test for information disclosure in error pages"""
        print(f"[*] Testing information disclosure on {target}")
        
        # Common error-prone paths
        error_paths = [
            '/admin',
            '/test',
            '/debug',
            '/.env',
            '/config.php',
            '/wp-admin',
            '/phpinfo.php',
            '/nonexistent-path-12345'
        ]
        
        findings = []
        
        for path in error_paths:
            try:
                test_url = urljoin(target, path)
                response = self.session.get(test_url, timeout=5, verify=False)
                
                # Check for information disclosure
                content = response.text.lower()
                
                # Patterns that indicate information disclosure
                disclosure_patterns = [
                    (r'server at.*apache', 'Apache server version exposed'),
                    (r'nginx\/\d+\.\d+\.\d+', 'Nginx version exposed'),
                    (r'php\/\d+\.\d+\.\d+', 'PHP version exposed'),
                    (r'stack trace:', 'Application stack trace exposed'),
                    (r'sql syntax.*mysql', 'MySQL error exposed'),
                    (r'internal server error', 'Detailed error message'),
                    (r'directory listing', 'Directory listing enabled'),
                    (r'index of/', 'Directory listing exposed')
                ]
                
                for pattern, description in disclosure_patterns:
                    if re.search(pattern, content):
                        finding = {
                            'type': 'information_disclosure',
                            'pattern': pattern,
                            'description': description,
                            'severity': 'low',
                            'target': test_url,
                            'proof': f'Pattern "{pattern}" found in response',
                            'status_code': response.status_code,
                            'timestamp': datetime.now().isoformat()
                        }
                        findings.append(finding)
                        break
                        
            except Exception as e:
                continue
        
        return findings
    
    def test_clickjacking(self, target):
        """Test for clickjacking vulnerability"""
        print(f"[*] Testing clickjacking protection on {target}")
        
        try:
            response = self.session.get(target, timeout=10, verify=False)
            headers = response.headers
            
            # Check for clickjacking protection
            clickjacking_protection = headers.get('X-Frame-Options') or headers.get('Content-Security-Policy')
            
            if not clickjacking_protection:
                # Create proof of concept
                poc_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking PoC for {target}</title>
    <style>
        .victim-frame {{
            position: absolute;
            opacity: 0.5;
            width: 100%;
            height: 100%;
            border: none;
        }}
        .attack-overlay {{
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: red;
            color: white;
            padding: 20px;
            cursor: pointer;
        }}
    </style>
</head>
<body>
    <h1>Clickjacking Proof of Concept</h1>
    <p>This demonstrates that {target} can be embedded in an iframe</p>
    
    <iframe src="{target}" class="victim-frame"></iframe>
    
    <div class="attack-overlay">
        <button>Click me (this could trigger actions on {target})</button>
    </div>
    
    <script>
        document.querySelector('.attack-overlay').addEventListener('click', function() {{
            alert('This could have triggered an action on the embedded site!');
        }});
    </script>
</body>
</html>
"""
                
                finding = {
                    'type': 'clickjacking',
                    'severity': 'medium',
                    'target': target,
                    'proof': 'Site can be embedded in iframe without protection',
                    'poc_html': poc_html,
                    'missing_headers': ['X-Frame-Options', 'Content-Security-Policy'],
                    'timestamp': datetime.now().isoformat()
                }
                
                return [finding]
            
        except Exception as e:
            print(f"[!] Error testing clickjacking on {target}: {e}")
        
        return []
    
    def test_cors_misconfiguration(self, target):
        """Test for CORS misconfiguration"""
        print(f"[*] Testing CORS configuration on {target}")
        
        try:
            # Test with malicious origin
            headers = {'Origin': 'https://evil.com'}
            response = self.session.get(target, headers=headers, timeout=10, verify=False)
            
            cors_header = response.headers.get('Access-Control-Allow-Origin')
            
            if cors_header and cors_header != 'null':
                finding = {
                    'type': 'cors_misconfiguration',
                    'severity': 'medium',
                    'target': target,
                    'proof': f'CORS allows origin: {cors_header}',
                    'tested_origin': 'https://evil.com',
                    'allowed_origin': cors_header,
                    'timestamp': datetime.now().isoformat()
                }
                
                return [finding]
                
        except Exception as e:
            print(f"[!] Error testing CORS on {target}: {e}")
        
        return []
    
    def verify_finding(self, finding):
        """Double-verify a finding to eliminate false positives"""
        print(f"[*] Verifying finding: {finding['type']} on {finding['target']}")
        
        try:
            if finding['type'] == 'missing_security_header':
                # Re-check headers
                response = self.session.get(finding['target'], timeout=10, verify=False)
                headers = response.headers
                
                if finding['header'] not in headers:
                    finding['verified'] = True
                    finding['verification_time'] = datetime.now().isoformat()
                    return True
            
            elif finding['type'] == 'clickjacking':
                # Re-test iframe embedding
                response = self.session.get(finding['target'], timeout=10, verify=False)
                headers = response.headers
                
                if not headers.get('X-Frame-Options') and not headers.get('Content-Security-Policy'):
                    finding['verified'] = True
                    finding['verification_time'] = datetime.now().isoformat()
                    return True
            
            elif finding['type'] in ['information_disclosure', 'cors_misconfiguration']:
                # Re-run the specific test
                if finding['type'] == 'information_disclosure':
                    test_results = self.test_information_disclosure(finding['target'])
                else:
                    test_results = self.test_cors_misconfiguration(finding['target'])
                
                for result in test_results:
                    if result['target'] == finding['target'] and result['type'] == finding['type']:
                        finding['verified'] = True
                        finding['verification_time'] = datetime.now().isoformat()
                        return True
            
        except Exception as e:
            print(f"[!] Verification failed: {e}")
        
        return False
    
    def scan_target(self, target):
        """Run comprehensive scan on a target"""
        print(f"\n{'='*60}")
        print(f"SCANNING: {target}")
        print(f"{'='*60}")
        
        if not self.check_authorization(target):
            print(f"[!] Target {target} is not authorized for scanning")
            return []
        
        all_findings = []
        
        # Run all tests
        tests = [
            self.test_security_headers,
            self.test_clickjacking,
            self.test_cors_misconfiguration,
            self.test_information_disclosure
        ]
        
        for test in tests:
            try:
                findings = test(target)
                all_findings.extend(findings)
                time.sleep(1)  # Rate limiting
            except Exception as e:
                print(f"[!] Test {test.__name__} failed: {e}")
        
        # Verify all findings
        verified_findings = []
        for finding in all_findings:
            if self.verify_finding(finding):
                verified_findings.append(finding)
                print(f"[‚úì] VERIFIED: {finding['type']} on {finding['target']}")
            else:
                print(f"[!] UNVERIFIED: {finding['type']} on {finding['target']}")
        
        return verified_findings
    
    def generate_proof_report(self, target, findings):
        """Generate comprehensive proof report"""
        report = {
            'target': target,
            'scan_date': datetime.now().isoformat(),
            'total_findings': len(findings),
            'verified_findings': len([f for f in findings if f.get('verified', False)]),
            'findings': findings,
            'summary': {
                'critical': len([f for f in findings if f.get('severity') == 'critical']),
                'high': len([f for f in findings if f.get('severity') == 'high']),
                'medium': len([f for f in findings if f.get('severity') == 'medium']),
                'low': len([f for f in findings if f.get('severity') == 'low'])
            }
        }
        
        return report
    
    def save_findings(self, target, findings):
        """Save findings with full proof"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"verified_vulnerabilities_{target.replace('https://', '').replace('/', '_')}_{timestamp}.json"
        
        report = self.generate_proof_report(target, findings)
        
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n[‚úì] Report saved: {filename}")
        
        # Save summary
        summary_file = f"summary_{timestamp}.md"
        with open(summary_file, 'w') as f:
            f.write(f"# Verified Vulnerabilities Report\n\n")
            f.write(f"**Target**: {target}\n")
            f.write(f"**Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Total Findings**: {len(findings)}\n")
            f.write(f"**Verified**: {len([f for f in findings if f.get('verified', False)])}\n\n")
            
            for finding in findings:
                status = "‚úÖ VERIFIED" if finding.get('verified', False) else "‚ùå UNVERIFIED"
                f.write(f"## {finding['type'].upper()} {status}\n")
                f.write(f"**Severity**: {finding.get('severity', 'unknown')}\n")
                f.write(f"**Target**: {finding['target']}\n")
                f.write(f"**Proof**: {finding.get('proof', 'N/A')}\n")
                
                if 'poc_html' in finding:
                    poc_file = f"poc_{finding['type']}_{timestamp}.html"
                    with open(poc_file, 'w') as poc:
                        poc.write(finding['poc_html'])
                    f.write(f"**Proof of Concept**: {poc_file}\n")
                
                f.write(f"**Timestamp**: {finding['timestamp']}\n\n")
        
        print(f"[‚úì] Summary saved: {summary_file}")
        return filename, summary_file

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 LIVE_VULNERABILITY_PROOF.py <target_url>")
        print("Example: python3 LIVE_VULNERABILITY_PROOF.py https://uniswap.org")
        sys.exit(1)
    
    target = sys.argv[1]
    scanner = LiveVulnerabilityProof()
    
    print("LIVE VULNERABILITY PROOF SYSTEM")
    print("=" * 60)
    print("Finding REAL, VERIFIABLE vulnerabilities")
    print("No hallucinations - only actual findings")
    print("=" * 60)
    
    findings = scanner.scan_target(target)
    
    print(f"\n{'='*60}")
    print("RESULTS")
    print(f"{'='*60}")
    print(f"Total findings: {len(findings)}")
    print(f"Verified findings: {len([f for f in findings if f.get('verified', False)])}")
    
    if findings:
        print("\nFINDINGS:")
        for finding in findings:
            status = "‚úÖ VERIFIED" if finding.get('verified', False) else "‚ùå UNVERIFIED"
            print(f"  - {finding['type'].upper()} [{finding.get('severity', 'unknown')}] {status}")
            print(f"    Target: {finding['target']}")
            print(f"    Proof: {finding.get('proof', 'N/A')}")
            print()
        
        # Save findings
        scanner.save_findings(target, findings)
        
        print("\nüéØ REAL VULNERABILITIES FOUND AND VERIFIED!")
        print("üìã Full proof reports saved with reproducible evidence")
    else:
        print("\n‚ùå No vulnerabilities found on this target")
