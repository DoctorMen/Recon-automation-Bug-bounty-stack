#!/usr/bin/env python3
"""
Enhanced API Vulnerability Scanner
Based on Hacking APIs PDF methodology and bug bounty best practices

METHODOLOGY FROM HACKINGAPIS.PDF:
- API Discovery (endpoint enumeration, documentation discovery)
- Authentication Testing (JWT, OAuth, API keys, tokens)
- Authorization Testing (IDOR, privilege escalation, RBAC)
- Input Validation (parameter manipulation, mass assignment, injection)
- Business Logic (rate limiting, batch operations, race conditions)
- Information Disclosure (error messages, debug endpoints, version disclosure)
"""

import json
import re
import requests
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from urllib.parse import urlparse, parse_qs, urljoin

class APIVulnerabilityScanner:
    """
    Enhanced API vulnerability scanner based on hacking APIs PDF methodology
    Focuses on high-ROI API vulnerabilities for bug bounty
    """
    
    # High-value API endpoints to discover
    HIGH_VALUE_ENDPOINTS = [
        # Authentication & Authorization
        "/api/auth", "/api/login", "/api/logout", "/api/register",
        "/api/v1/auth", "/api/v1/login", "/api/v2/auth",
        "/api/oauth", "/api/token", "/api/refresh",
        "/api/session", "/api/user", "/api/me",
        
        # Payment & Financial
        "/api/payments", "/api/v1/payments", "/api/v2/payments",
        "/api/checkout", "/api/transactions", "/api/orders",
        "/api/billing", "/api/invoice", "/api/subscription",
        "/api/wallet", "/api/balance", "/api/transfer",
        
        # Admin & Management
        "/api/admin", "/api/v1/admin", "/api/manage",
        "/api/users", "/api/v1/users", "/api/v2/users",
        "/api/accounts", "/api/customers", "/api/merchants",
        
        # Data & Resources
        "/api/data", "/api/files", "/api/upload", "/api/download",
        "/api/export", "/api/import", "/api/backup",
        
        # GraphQL & Modern APIs
        "/graphql", "/graphiql", "/graphql/v1",
        "/api/graphql", "/v1/graphql",
        
        # API Documentation
        "/api/docs", "/api/swagger", "/api/openapi",
        "/swagger", "/swagger.json", "/swagger.yaml",
        "/openapi.json", "/openapi.yaml",
        "/.well-known/openapi.json", "/.well-known/swagger.json",
        "/api-docs", "/docs/api",
        
        # Version endpoints
        "/api/v1", "/api/v2", "/api/v3",
        "/v1", "/v2", "/v3",
        
        # Internal/Testing
        "/api/internal", "/api/test", "/api/staging",
        "/api/dev", "/api/debug", "/api/health",
    ]
    
    # API vulnerability patterns (from hackingapis.pdf methodology)
    VULNERABILITY_PATTERNS = {
        "idor": {
            "indicators": [
                "id", "user_id", "account_id", "payment_id",
                "order_id", "transaction_id", "customer_id",
                "uuid", "guid", "resource_id"
            ],
            "methods": ["GET", "PUT", "PATCH", "DELETE"],
            "severity": "high",
            "pdf_methodology": "IDOR testing in API endpoints - test accessing other users' resources"
        },
        "mass_assignment": {
            "indicators": ["role", "admin", "privilege", "access_level", "is_admin", "permissions"],
            "methods": ["POST", "PUT", "PATCH"],
            "severity": "high",
            "pdf_methodology": "Mass assignment - try to set admin/privilege fields in user creation/update"
        },
        "rate_limit_bypass": {
            "indicators": ["api", "rate", "limit", "throttle"],
            "methods": ["GET", "POST"],
            "severity": "medium",
            "pdf_methodology": "Rate limiting bypass - test header manipulation, IP rotation, endpoint variations"
        },
        "auth_bypass": {
            "indicators": ["auth", "login", "token", "session", "oauth", "bearer"],
            "methods": ["GET", "POST"],
            "severity": "critical",
            "pdf_methodology": "Authentication bypass - test missing auth, weak JWT, token manipulation"
        },
        "jwt_weak": {
            "indicators": ["jwt", "token", "bearer", "authorization"],
            "methods": ["GET", "POST"],
            "severity": "high",
            "pdf_methodology": "JWT vulnerabilities - alg=none, weak secret, missing verification, predictable tokens"
        },
        "oauth_flaws": {
            "indicators": ["oauth", "authorize", "callback", "redirect_uri"],
            "methods": ["GET", "POST"],
            "severity": "high",
            "pdf_methodology": "OAuth flaws - redirect_uri manipulation, state parameter issues, token reuse"
        },
        "graphql_introspection": {
            "indicators": ["graphql", "graphiql"],
            "methods": ["POST"],
            "severity": "medium",
            "pdf_methodology": "GraphQL introspection - test __schema query, field name enumeration"
        },
        "graphql_query_complexity": {
            "indicators": ["graphql"],
            "methods": ["POST"],
            "severity": "high",
            "pdf_methodology": "GraphQL query complexity - deep nesting, circular queries, resource exhaustion"
        },
        "swagger_exposure": {
            "indicators": ["swagger", "openapi", "api-docs"],
            "methods": ["GET"],
            "severity": "medium",
            "pdf_methodology": "Swagger/OpenAPI exposure - enumerate endpoints, test undocumented parameters"
        },
        "cors_misconfig": {
            "indicators": ["api", "cors"],
            "methods": ["GET", "POST", "OPTIONS"],
            "severity": "medium",
            "pdf_methodology": "CORS misconfiguration - test wildcard origins, null origin, credentials handling"
        },
        "parameter_pollution": {
            "indicators": ["id", "user", "account", "email", "username"],
            "methods": ["GET", "POST"],
            "severity": "medium",
            "pdf_methodology": "Parameter pollution - duplicate parameters, conflicting values, array injection"
        },
        "batch_operations": {
            "indicators": ["batch", "bulk", "mass"],
            "methods": ["POST", "PUT"],
            "severity": "high",
            "pdf_methodology": "Batch operations - test bulk IDOR, unauthorized batch operations"
        },
        "api_versioning": {
            "indicators": ["v1", "v2", "version", "api"],
            "methods": ["GET", "POST"],
            "severity": "medium",
            "pdf_methodology": "API versioning - test old versions, version confusion, deprecated endpoints"
        },
        "missing_rate_limit": {
            "indicators": ["api", "endpoint"],
            "methods": ["POST", "PUT", "DELETE"],
            "severity": "medium",
            "pdf_methodology": "Missing rate limiting - test brute force, enumeration, resource exhaustion"
        },
        "information_disclosure": {
            "indicators": ["error", "debug", "stack", "trace", "exception"],
            "methods": ["GET", "POST"],
            "severity": "low-medium",
            "pdf_methodology": "Information disclosure - error messages, stack traces, debug endpoints"
        }
    }
    
    # Enhanced API endpoint discovery (from hackingapis.pdf)
    ENHANCED_API_PATTERNS = [
        # REST API patterns
        "/api", "/api/v1", "/api/v2", "/api/v3",
        "/v1", "/v2", "/v3",
        "/rest", "/rest/api", "/rest/v1",
        
        # GraphQL patterns
        "/graphql", "/graphiql", "/graphql/v1",
        "/api/graphql", "/v1/graphql",
        
        # API documentation
        "/swagger", "/swagger.json", "/swagger.yaml",
        "/openapi.json", "/openapi.yaml",
        "/api-docs", "/docs/api", "/api/docs",
        "/.well-known/openapi.json",
        
        # Authentication APIs
        "/api/auth", "/api/login", "/api/oauth",
        "/api/token", "/api/refresh", "/api/session",
        "/auth", "/oauth", "/oauth2",
        
        # Payment APIs
        "/api/payments", "/api/checkout", "/api/transactions",
        "/api/billing", "/api/invoice", "/api/subscription",
        
        # Admin APIs
        "/api/admin", "/api/manage", "/api/users",
        "/api/accounts", "/api/customers",
        
        # Data APIs
        "/api/data", "/api/files", "/api/upload",
        "/api/export", "/api/backup"
    ]
    
    @staticmethod
    def discover_api_endpoints(base_urls: List[str]) -> List[str]:
        """
        Enhanced API endpoint discovery from hackingapis.pdf methodology
        Discovers 60+ API endpoints using systematic patterns
        """
        api_endpoints = set()
        
        for base_url in base_urls:
            # Ensure base URL has scheme
            if not base_url.startswith(("http://", "https://")):
                base_url = f"https://{base_url}"
            
            # Add all high-value endpoints from hackingapis.pdf
            for path in APIVulnerabilityScanner.ENHANCED_API_PATTERNS:
                api_endpoints.add(f"{base_url.rstrip('/')}{path}")
            
            # Add common API paths (from HIGH_VALUE_ENDPOINTS)
            for path in APIVulnerabilityScanner.HIGH_VALUE_ENDPOINTS:
                api_endpoints.add(f"{base_url.rstrip('/')}{path}")
            
            # Add versioned endpoints
            for version in ["v1", "v2", "v3", "v4"]:
                api_endpoints.add(f"{base_url.rstrip('/')}/api/{version}")
                api_endpoints.add(f"{base_url.rstrip('/')}/{version}")
        
        return sorted(api_endpoints)
    
    @staticmethod
    def test_api_authentication(endpoint: str) -> List[Dict[str, Any]]:
        """
        Test API authentication vulnerabilities (from hackingapis.pdf)
        """
        findings = []
        
        # Test missing authentication
        try:
            response = requests.get(endpoint, timeout=5, verify=False)
            if response.status_code in [200, 201, 202]:
                findings.append({
                    "type": "missing_auth",
                    "url": endpoint,
                    "severity": "critical",
                    "description": "API endpoint accessible without authentication",
                    "methodology": "hackingapis.pdf - Missing authentication test",
                    "recommendation": "Test accessing protected resources without auth token"
                })
        except:
            pass
        
        # Test weak authentication headers
        weak_auth_headers = [
            {"Authorization": "Bearer test"},
            {"Authorization": "Bearer null"},
            {"X-API-Key": "test"},
            {"X-Auth-Token": "test"}
        ]
        
        for header in weak_auth_headers:
            try:
                response = requests.get(endpoint, headers=header, timeout=5, verify=False)
                if response.status_code in [200, 201, 202]:
                    findings.append({
                        "type": "weak_auth",
                        "url": endpoint,
                        "severity": "high",
                        "description": f"API accepts weak authentication: {header}",
                        "methodology": "hackingapis.pdf - Weak authentication test",
                        "recommendation": "Test with various weak tokens/keys"
                    })
                    break
            except:
                continue
        
        return findings
    
    @staticmethod
    def test_api_authorization(endpoint: str) -> List[Dict[str, Any]]:
        """
        Test API authorization vulnerabilities (from hackingapis.pdf)
        """
        findings = []
        
        # Check for IDOR indicators in URL
        idor_patterns = [
            r'/users?/(\d+)', r'/accounts?/(\d+)', r'/payments?/(\d+)',
            r'/orders?/(\d+)', r'/transactions?/(\d+)', r'/id=(\d+)'
        ]
        
        for pattern in idor_patterns:
            match = re.search(pattern, endpoint, re.IGNORECASE)
            if match:
                resource_id = match.group(1)
                findings.append({
                    "type": "idor_potential",
                    "url": endpoint,
                    "severity": "high",
                    "description": f"Potential IDOR vulnerability - resource ID in URL: {resource_id}",
                    "methodology": "hackingapis.pdf - IDOR testing",
                    "recommendation": f"Test accessing resource ID {resource_id} with different user accounts"
                })
        
        return findings
    
    @staticmethod
    def analyze_api_response(response_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Analyze API response for potential vulnerabilities
        Based on response patterns from hacking APIs PDF
        """
        findings = []
        
        url = response_data.get("url", "")
        status_code = response_data.get("status-code", 0)
        title = response_data.get("title", "")
        content_length = response_data.get("content-length", 0)
        
        # Check for exposed API documentation
        if any(indicator in url.lower() for indicator in ["swagger", "openapi", "api-docs", "graphiql"]):
            if status_code in [200, 201]:
                findings.append({
                    "type": "swagger_exposure",
                    "url": url,
                    "severity": "medium",
                    "description": "Exposed API documentation (Swagger/OpenAPI)",
                    "recommendation": "Review for sensitive endpoints and test for vulnerabilities"
                })
        
        # Check for GraphQL introspection
        if "graphql" in url.lower() or "graphiql" in url.lower():
            if status_code == 200:
                findings.append({
                    "type": "graphql_introspection",
                    "url": url,
                    "severity": "medium",
                    "description": "GraphQL endpoint discovered - test for introspection vulnerabilities",
                    "recommendation": "Test GraphQL introspection query and endpoint security"
                })
        
        # Check for authentication endpoints
        if any(indicator in url.lower() for indicator in ["auth", "login", "token", "session"]):
            findings.append({
                "type": "auth_endpoint",
                "url": url,
                "severity": "high",
                "description": "Authentication endpoint discovered",
                "recommendation": "Test for authentication bypass, JWT weaknesses, session management"
            })
        
        # Check for payment endpoints
        if any(indicator in url.lower() for indicator in ["payment", "checkout", "transaction", "billing"]):
            findings.append({
                "type": "payment_endpoint",
                "url": url,
                "severity": "high",
                "description": "Payment endpoint discovered",
                "recommendation": "Test for IDOR, amount manipulation, race conditions"
            })
        
        # Check for admin endpoints
        if "admin" in url.lower():
            findings.append({
                "type": "admin_endpoint",
                "url": url,
                "severity": "high",
                "description": "Admin endpoint discovered",
                "recommendation": "Test for unauthorized access, privilege escalation"
            })
        
        return findings
    
    @staticmethod
    def generate_test_cases(endpoint: str) -> List[Dict[str, Any]]:
        """
        Generate comprehensive test cases for API endpoints
        Based on hackingapis.pdf methodology
        """
        test_cases = []
        
        # Extract path and parameters
        from urllib.parse import urlparse, parse_qs
        parsed = urlparse(endpoint)
        path = parsed.path.lower()
        
        # IDOR test cases (from hackingapis.pdf)
        if any(indicator in path for indicator in ["user", "account", "payment", "order", "transaction", "customer"]):
            test_cases.append({
                "type": "idor",
                "method": "GET",
                "endpoint": endpoint,
                "description": "Test IDOR by accessing other users' resources",
                "payload": None,
                "expected": "Unauthorized access to other users' data",
                "methodology": "hackingapis.pdf - IDOR testing in API endpoints"
            })
            
            # Test IDOR with different HTTP methods
            for method in ["PUT", "PATCH", "DELETE"]:
                test_cases.append({
                    "type": f"idor_{method.lower()}",
                    "method": method,
                    "endpoint": endpoint,
                    "description": f"Test IDOR via {method} - modify/delete other users' resources",
                    "payload": {"id": "OTHER_USER_ID"},
                    "expected": f"Unauthorized {method} on other users' resources",
                    "methodology": "hackingapis.pdf - IDOR testing"
                })
        
        # Mass assignment test cases (from hackingapis.pdf)
        if any(indicator in path for indicator in ["user", "account", "profile", "register", "update"]):
            test_cases.append({
                "type": "mass_assignment",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test mass assignment vulnerabilities",
                "payload": {
                    "role": "admin",
                    "is_admin": True,
                    "privilege": "super",
                    "access_level": "admin",
                    "permissions": ["admin", "superuser"]
                },
                "expected": "Unauthorized privilege escalation",
                "methodology": "hackingapis.pdf - Mass assignment testing"
            })
        
        # Rate limit bypass (from hackingapis.pdf)
        test_cases.append({
            "type": "rate_limit_bypass",
            "method": "GET",
            "endpoint": endpoint,
            "description": "Test rate limit bypass techniques",
            "payload": None,
            "expected": "Bypass rate limiting via header manipulation",
            "methodology": "hackingapis.pdf - Rate limiting bypass"
        })
        
        # JWT token manipulation (from hackingapis.pdf)
        if any(indicator in path for indicator in ["auth", "token", "login", "session"]):
            test_cases.append({
                "type": "jwt_manipulation",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test JWT token manipulation (alg=none, weak secret, missing verification)",
                "payload": {"token": "MANIPULATED_JWT"},
                "expected": "Authentication bypass via JWT manipulation",
                "methodology": "hackingapis.pdf - JWT vulnerabilities"
            })
        
        # Parameter pollution (from hackingapis.pdf)
        parsed_qs = parse_qs(parsed.query)
        if parsed_qs:
            test_cases.append({
                "type": "parameter_pollution",
                "method": "GET",
                "endpoint": endpoint,
                "description": "Test parameter pollution (duplicate parameters, conflicting values)",
                "payload": None,
                "expected": "Unexpected behavior from parameter pollution",
                "methodology": "hackingapis.pdf - Parameter pollution"
            })
        
        # Batch operations (from hackingapis.pdf)
        if any(indicator in path for indicator in ["batch", "bulk", "mass"]):
            test_cases.append({
                "type": "batch_idor",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test batch operations for IDOR vulnerabilities",
                "payload": {"ids": ["OTHER_USER_ID1", "OTHER_USER_ID2"]},
                "expected": "Unauthorized access via batch operations",
                "methodology": "hackingapis.pdf - Batch operations testing"
            })
        
        # GraphQL specific tests (from hackingapis.pdf)
        if "graphql" in path:
            test_cases.append({
                "type": "graphql_introspection",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test GraphQL introspection query",
                "payload": {"query": "{__schema{types{name}}}"},
                "expected": "GraphQL schema disclosure",
                "methodology": "hackingapis.pdf - GraphQL introspection"
            })
            
            test_cases.append({
                "type": "graphql_query_complexity",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test GraphQL query complexity (deep nesting)",
                "payload": {"query": "{user{user{user{user{name}}}}}"},
                "expected": "Resource exhaustion via complex queries",
                "methodology": "hackingapis.pdf - GraphQL query complexity"
            })
        
        return test_cases
    
    @staticmethod
    def scan_for_vulnerabilities(api_endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan discovered API endpoints for vulnerabilities
        """
        findings = []
        
        for endpoint_data in api_endpoints:
            # Analyze response
            endpoint_findings = APIVulnerabilityScanner.analyze_api_response(endpoint_data)
            findings.extend(endpoint_findings)
            
            # Generate test cases
            url = endpoint_data.get("url", "")
            if url:
                test_cases = APIVulnerabilityScanner.generate_test_cases(url)
                for test_case in test_cases:
                    findings.append({
                        "type": f"test_case_{test_case['type']}",
                        "url": url,
                        "severity": APIVulnerabilityScanner.VULNERABILITY_PATTERNS.get(
                            test_case['type'], {}
                        ).get("severity", "medium"),
                        "description": test_case['description'],
                        "test_case": test_case,
                        "recommendation": f"Manually test: {test_case['description']}"
                    })
        
        return findings

