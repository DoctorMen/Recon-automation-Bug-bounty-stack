#!/usr/bin/env python3
"""
Active Exploitation Module
Actually tests endpoints and executes test cases
This is the missing piece that turns discovery into value
"""

import json
import requests
import time
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from urllib.parse import urlparse
import base64
import hmac
import hashlib

class ActiveExploiter:
    """
    Actually exploits endpoints and confirms vulnerabilities
    This bridges the gap between discovery and value
    """
    
    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.exploited_findings = []
        self.confirmed_vulnerabilities = []
    
    def test_endpoint(self, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """
        Actually test an endpoint for vulnerabilities
        Returns confirmed exploit if found
        """
        result = {
            "endpoint": endpoint,
            "test_case": test_case,
            "exploited": False,
            "confirmed": False,
            "proof": None,
            "value": 0
        }
        
        try:
            # Test authentication bypass
            if test_case.get("type") == "auth_bypass":
                result = self._test_auth_bypass(endpoint)
            
            # Test IDOR
            elif test_case.get("type") == "idor":
                result = self._test_idor(endpoint, test_case)
            
            # Test API vulnerabilities
            elif test_case.get("type", "").startswith("api_"):
                result = self._test_api_vulnerability(endpoint, test_case)
            
            # Test other vulnerabilities
            else:
                result = self._test_generic(endpoint, test_case)
            
            if result.get("exploited"):
                self.confirmed_vulnerabilities.append(result)
                result["value"] = self._estimate_value(result)
            
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _test_auth_bypass(self, endpoint: str) -> Dict[str, Any]:
        """Test for authentication bypass"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Test without authentication
        try:
            response = requests.get(endpoint, timeout=5, verify=False)
            if response.status_code in [200, 201, 202]:
                result["exploited"] = True
                result["confirmed"] = True
                result["proof"] = {
                    "method": "GET",
                    "status_code": response.status_code,
                    "response_length": len(response.text),
                    "headers": dict(response.headers)
                }
        except:
            pass
        
        # Test with weak authentication
        weak_headers = [
            {"Authorization": "Bearer test"},
            {"X-API-Key": "test"},
            {"X-Auth-Token": "test"}
        ]
        
        for header in weak_headers:
            try:
                response = requests.get(endpoint, headers=header, timeout=5, verify=False)
                if response.status_code in [200, 201, 202]:
                    result["exploited"] = True
                    result["confirmed"] = True
                    result["proof"] = {
                        "method": "GET",
                        "headers": header,
                        "status_code": response.status_code,
                        "response_length": len(response.text)
                    }
                    break
            except:
                continue
        
        return result
    
    def _test_idor(self, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Test for IDOR vulnerabilities"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Extract ID patterns from endpoint
        import re
        id_patterns = re.findall(r'/(\d+)', endpoint)
        
        if id_patterns:
            # Try different IDs
            for test_id in ["1", "2", "999", "1000"]:
                test_endpoint = endpoint.replace(id_patterns[0], test_id)
                try:
                    response = requests.get(test_endpoint, timeout=5, verify=False)
                    if response.status_code == 200 and len(response.text) > 100:
                        result["exploited"] = True
                        result["confirmed"] = True
                        result["proof"] = {
                            "original_id": id_patterns[0],
                            "test_id": test_id,
                            "status_code": response.status_code,
                            "response_length": len(response.text)
                        }
                        break
                except:
                    continue
        
        return result
    
    def _test_api_vulnerability(self, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Test API-specific vulnerabilities"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Test based on test case type
        test_type = test_case.get("type", "")
        
        if "rate_limit" in test_type:
            # Test rate limit bypass
            for i in range(100):
                try:
                    response = requests.get(endpoint, timeout=2, verify=False)
                    if response.status_code == 200:
                        result["exploited"] = True
                        result["confirmed"] = True
                        result["proof"] = {
                            "requests_sent": i + 1,
                            "status_code": response.status_code
                        }
                        break
                except:
                    continue
        
        elif "idor" in test_type:
            result = self._test_idor(endpoint, test_case)
        
        elif "mass_assignment" in test_type:
            # Test mass assignment
            payload = test_case.get("payload", {})
            try:
                response = requests.post(endpoint, json=payload, timeout=5, verify=False)
                if response.status_code in [200, 201]:
                    result["exploited"] = True
                    result["confirmed"] = True
                    result["proof"] = {
                        "payload": payload,
                        "status_code": response.status_code
                    }
            except:
                pass
        
        return result
    
    def _test_generic(self, endpoint: str, test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Generic vulnerability testing"""
        result = {"endpoint": endpoint, "exploited": False}
        
        # Try basic exploitation
        try:
            response = requests.get(endpoint, timeout=5, verify=False)
            if response.status_code == 200:
                result["exploited"] = True
                result["confirmed"] = True
                result["proof"] = {
                    "status_code": response.status_code,
                    "response_length": len(response.text)
                }
        except:
            pass
        
        return result
    
    def _estimate_value(self, result: Dict[str, Any]) -> float:
        """Estimate bug bounty value"""
        if not result.get("confirmed"):
            return 0
        
        # Base value estimates
        if result.get("test_case", {}).get("type") == "auth_bypass":
            return 5000  # High value
        elif "idor" in result.get("test_case", {}).get("type", ""):
            return 3000  # Medium-high value
        elif "api_" in result.get("test_case", {}).get("type", ""):
            return 1000  # Medium value
        else:
            return 500  # Low-medium value
    
    def exploit_all_discoveries(self, endpoints: List[str], test_cases: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Actually exploit all discovered endpoints
        This is where value comes from
        """
        confirmed = []
        
        for endpoint in endpoints[:50]:  # Limit to first 50 for speed
            for test_case in test_cases[:10]:  # Limit test cases
                result = self.test_endpoint(endpoint, test_case)
                if result.get("exploited"):
                    confirmed.append(result)
                    print(f"âœ… CONFIRMED: {endpoint} - {result.get('test_case', {}).get('type')}")
        
        return confirmed

