#!/usr/bin/env python3
"""
Copyright (c) 2025 YOUR_NAME_HERE
Proprietary and Confidential
All Rights Reserved

This software is proprietary and confidential.
Unauthorized copying, modification, or distribution is prohibited.

System ID: BB_20251102_5946
Owner: YOUR_NAME_HERE
"""

"""
Bug Bounty Program Finder
Identifies popular bug bounty programs from various platforms and sources.
Helps discover authorized targets for security testing.
"""

import json
import sys
from pathlib import Path
from typing import List, Dict
from datetime import datetime

# Well-known bug bounty platforms and programs
# NOTE: Always verify scope and authorization before scanning!
BUG_BOUNTY_SOURCES = {
    "hackerone": [
        # Popular public programs (verify scope!)
        "shopify.com",
        "starbucks.com", 
        "uber.com",
        "twitter.com",
        "github.com",
        "mozilla.org",
        "wordpress.com",
        "automattic.com",
        "dropbox.com",
        "yelp.com",
        "instagram.com",
        "tiktok.com",
        "paypal.com",
        "ebay.com",
    ],
    "bugcrowd": [
        # Popular public programs
        "apple.com",
        "microsoft.com",
        "atlassian.com",
        "alibaba.com",
        "sony.com",
        "nintendo.com",
    ],
    "public_programs": [
        # Companies with well-known public programs
        "google.com",
        "facebook.com",
        "linkedin.com",
        "yahoo.com",
        "oracle.com",
        "adobe.com",
        "vmware.com",
        "cisco.com",
    ],
    "government_educational": [
        # Public programs (always verify scope!)
        # Note: Government programs often have strict scope
    ]
}

# High-value bug bounty categories
HIGH_VALUE_TAGS = [
    "authentication",
    "authorization", 
    "api",
    "rce",
    "ssrf",
    "sqli",
    "xss",
    "xxe",
    "subdomain-takeover",
    "cloud-misconfig",
]

def get_bug_bounty_programs() -> Dict[str, List[str]]:
    """Get list of popular bug bounty programs organized by platform"""
    return BUG_BOUNTY_SOURCES

def filter_by_platform(platform: str = None) -> List[str]:
    """Filter programs by platform"""
    all_programs = []
    sources = BUG_BOUNTY_SOURCES
    
    if platform and platform.lower() in sources:
        all_programs = sources[platform.lower()]
    else:
        for programs in sources.values():
            all_programs.extend(programs)
    
    # Remove duplicates while preserving order
    seen = set()
    unique = []
    for program in all_programs:
        if program not in seen:
            seen.add(program)
            unique.append(program)
    
    return unique

def generate_targets_file(programs: List[str], output_file: Path = None):
    """Generate a targets.txt file with bug bounty programs"""
    if output_file is None:
        output_file = Path(__file__).parent.parent / "targets.txt"
    
    header = """# Recon Stack Targets Configuration
# Bug Bounty Programs - Generated by find_bug_bounty_programs.py
# 
# ⚠️ IMPORTANT: Only scan domains you are authorized to test!
# Always verify scope and authorization before scanning.
# Review each program's bug bounty policy and scope at:
#   - HackerOne: https://hackerone.com/programs
#   - Bugcrowd: https://bugcrowd.com/programs
#   - Company-specific bug bounty pages
#
# Remove or comment out (#) any domains you are NOT authorized to test.
#
"""
    
    content = header
    content += "# Popular Bug Bounty Programs\n"
    content += "# Uncomment domains you are authorized to scan:\n\n"
    
    for program in sorted(programs):
        content += f"# {program}\n"
    
    content += "\n# Add your authorized targets below (uncomment or add new lines):\n"
    
    output_file.write_text(content, encoding="utf-8")
    return output_file

def query_hackerone_api(query: str = None):
    """Query HackerOne API for public programs (if API key available)"""
    # Placeholder for future API integration
    # Requires HackerOne API key in environment
    api_key = None  # os.getenv("HACKERONE_API_KEY")
    if not api_key:
        return []
    
    # Future: Implement HackerOne API query
    return []

def query_bugcrowd_api(query: str = None):
    """Query Bugcrowd API for public programs (if API key available)"""
    # Placeholder for future API integration
    # Requires Bugcrowd API key in environment
    api_key = None  # os.getenv("BUGCROWD_API_KEY")
    if not api_key:
        return []
    
    # Future: Implement Bugcrowd API query
    return []

def main():
    """Main function"""
    print("=" * 60)
    print("Bug Bounty Program Finder")
    print("=" * 60)
    print()
    print("⚠️  IMPORTANT: Always verify authorization and scope before scanning!")
    print()
    
    # Get all programs
    all_programs = filter_by_platform()
    
    print(f"Found {len(all_programs)} popular bug bounty programs:")
    print()
    
    # Display by platform
    for platform, programs in BUG_BOUNTY_SOURCES.items():
        if programs:
            print(f"{platform.upper().replace('_', ' ')}: {len(programs)} programs")
            for program in programs[:5]:  # Show first 5
                print(f"  - {program}")
            if len(programs) > 5:
                print(f"  ... and {len(programs) - 5} more")
            print()
    
    # Generate targets.txt
    targets_file = Path(__file__).parent.parent / "targets.txt"
    print(f"Generating {targets_file}...")
    generate_targets_file(all_programs, targets_file)
    print(f"✓ Created {targets_file}")
    print()
    print("Next steps:")
    print("1. Review targets.txt and uncomment domains you are authorized to scan")
    print("2. Add any additional authorized targets")
    print("3. Run: python run_pipeline.py")
    print()
    
    # Also create a JSON export
    json_file = Path(__file__).parent.parent / "bug_bounty_programs.json"
    with open(json_file, "w", encoding="utf-8") as f:
        json.dump({
            "generated": datetime.now().isoformat(),
            "programs": all_programs,
            "by_platform": BUG_BOUNTY_SOURCES,
            "high_value_tags": HIGH_VALUE_TAGS,
        }, f, indent=2, ensure_ascii=False)
    print(f"✓ Exported program list to {json_file}")

if __name__ == "__main__":
    main()


# System ID: BB_20251102_5946
# Owner: YOUR_NAME_HERE
# Build Date: 2025-11-02 02:45:55
