#!/usr/bin/env python3
"""
KURU DEX VULNERABILITY ANALYZER
Neural-enhanced smart contract security analysis

Targets:
- Vault.sol (Share inflation, first depositor attacks)
- KuruAMMVault (Virtual rebalancing manipulation)
- OrderBook (Flip order edge cases)
- MarginAccount (Access control bypass)
- Router (Multi-hop reentrancy)
"""

import json
import requests
from pathlib import Path

# Monad RPC
RPC = "https://rpc.monad.xyz"
CHAIN_ID = 143

# Contract addresses from bug bounty scope (testnet for now)
CONTRACTS = {
    "Router": "0x1f5A250c4A506DA4cE584173c6ed1890B1bf7187",
    "MarginAccount": "0xdDDaBd30785bA8b45e434a1f134BDf304d6125d9",
    "OrderBook": "0xa21ca7b4e308e9E2dC4C60620572792634EA21a0",
    "MonadDeployer": "0x1D90616Ad479c3D814021b1f4C43b1a2fFf87626",
    "KuruUtils": "0xDdAEdbc015fEe6BE50c69Fbf5d771A4563C996B3",
}

class KuruAnalyzer:
    def __init__(self):
        self.abis = {}
        self.load_abis()
        
    def load_abis(self):
        """Load all ABIs"""
        abi_dir = Path(__file__).parent / "abi"
        for abi_file in abi_dir.glob("*.json"):
            with open(abi_file) as f:
                data = json.load(f)
                self.abis[abi_file.stem] = data.get('abi', data)
                
    def analyze_vault_share_inflation(self):
        """
        CRITICAL: First depositor share inflation attack
        
        Attack pattern:
        1. Attacker is first depositor with minimal amounts
        2. Attacker donates tokens directly to vault (not via deposit)
        3. Share price inflated - subsequent depositors get fewer shares
        4. Attacker withdraws with profit
        """
        print("\n" + "="*60)
        print("ðŸ”´ ANALYZING: VAULT SHARE INFLATION")
        print("="*60)
        
        vault_abi = self.abis.get('Vault', [])
        
        findings = []
        
        # Check for first deposit protection
        has_min_liquidity = False
        for item in vault_abi:
            if item.get('type') == 'function':
                name = item.get('name', '')
                # Look for MIN_LIQUIDITY constant or dead shares
                if 'MIN' in name.upper() or 'DEAD' in name.upper():
                    has_min_liquidity = True
                    
        if not has_min_liquidity:
            findings.append({
                'severity': 'CRITICAL',
                'title': 'Potential Share Inflation Vulnerability',
                'description': 'No MIN_LIQUIDITY or dead shares visible in ABI',
                'attack': 'First depositor can inflate share price via donation',
                'poc_steps': [
                    '1. Be first depositor with 1 wei base + 1 wei quote',
                    '2. Receive ~1 share (minus any MIN_LIQUIDITY)',
                    '3. Transfer large amount of tokens directly to vault',
                    '4. Next depositor gets very few shares per token',
                    '5. Withdraw to extract value from other depositors'
                ]
            })
            
        # Check deposit function for slippage protection
        for item in vault_abi:
            if item.get('name') == 'deposit':
                inputs = [i.get('name') for i in item.get('inputs', [])]
                if 'minQuoteConsumed' not in inputs and 'minShares' not in inputs:
                    findings.append({
                        'severity': 'HIGH',
                        'title': 'Missing Slippage Protection on Deposit',
                        'description': 'deposit() may not have adequate slippage protection'
                    })
                else:
                    print("  âœ… Deposit has minQuoteConsumed parameter")
                    
        return findings
        
    def analyze_margin_account_access(self):
        """
        HIGH: MarginAccount access control analysis
        
        Critical functions:
        - creditUser: Can credit any user with any amount
        - debitUser: Can debit any user
        - creditUsersEncoded: Raw bytes parsing
        """
        print("\n" + "="*60)
        print("ðŸŸ  ANALYZING: MARGINACCOUNT ACCESS CONTROL")
        print("="*60)
        
        ma_abi = self.abis.get('MarginAccount', [])
        
        findings = []
        
        critical_funcs = ['creditUser', 'debitUser', 'creditUsersEncoded', 'creditFee']
        
        for item in ma_abi:
            if item.get('type') == 'function' and item.get('name') in critical_funcs:
                name = item.get('name')
                # ABI doesn't show modifiers, but we flag for manual review
                findings.append({
                    'severity': 'NEEDS_REVIEW',
                    'title': f'Verify Access Control: {name}()',
                    'description': f'{name} can manipulate user balances',
                    'check': 'Verify onlyMarket or similar modifier in source'
                })
                
        # Check creditUsersEncoded for parsing issues
        for item in ma_abi:
            if item.get('name') == 'creditUsersEncoded':
                findings.append({
                    'severity': 'MEDIUM',
                    'title': 'Encoded Data Parsing Risk',
                    'description': 'creditUsersEncoded takes raw bytes - check for overflow/underflow in parsing',
                    'attack': 'Malformed encoded data could credit wrong amounts'
                })
                
        return findings
        
    def analyze_orderbook_flip_orders(self):
        """
        MEDIUM: Flip order edge cases
        
        Known out-of-scope: Market DOS via minimum order bypass
        But other edge cases may exist
        """
        print("\n" + "="*60)
        print("ðŸŸ¡ ANALYZING: ORDERBOOK FLIP ORDERS")
        print("="*60)
        
        ob_abi = self.abis.get('OrderBook', [])
        
        findings = []
        
        # Check flip order parameters
        for item in ob_abi:
            if item.get('name') in ['addFlipBuyOrder', 'addFlipSellOrder']:
                inputs = {i.get('name'): i.get('type') for i in item.get('inputs', [])}
                
                # Check if flippedPrice validation exists
                if '_price' in inputs and '_flippedPrice' in inputs:
                    findings.append({
                        'severity': 'MEDIUM',
                        'title': 'Flip Order Price Validation',
                        'description': 'Check: Can _flippedPrice be set outside market bounds?',
                        'check': 'Verify _flippedPrice <= _price for buys, >= _price for sells'
                    })
                    
        # Check batch functions for array length mismatches
        batch_funcs = ['batchProvisionLiquidity', 'batchAddPairedLiquidity', 
                       'placeMultipleBuyOrders', 'placeMultipleSellOrders']
        
        for item in ob_abi:
            if item.get('name') in batch_funcs:
                arrays = [i for i in item.get('inputs', []) if '[]' in i.get('type', '')]
                if len(arrays) > 1:
                    findings.append({
                        'severity': 'LOW',
                        'title': f'Array Length Validation: {item.get("name")}',
                        'description': f'Function has {len(arrays)} array inputs',
                        'check': 'Verify all arrays must have same length'
                    })
                    
        return findings
        
    def analyze_router_multihop(self):
        """
        HIGH: Multi-hop swap analysis
        
        anyToAnySwap with complex array handling
        """
        print("\n" + "="*60)
        print("ðŸŸ  ANALYZING: ROUTER MULTI-HOP SWAPS")
        print("="*60)
        
        router_abi = self.abis.get('Router', [])
        
        findings = []
        
        for item in router_abi:
            if item.get('name') == 'anyToAnySwap':
                inputs = item.get('inputs', [])
                
                findings.append({
                    'severity': 'HIGH',
                    'title': 'Multi-hop Swap Reentrancy Risk',
                    'description': 'anyToAnySwap iterates through multiple markets',
                    'check': 'Verify CEI pattern, nonReentrant modifier',
                    'attack_vectors': [
                        'Reentrancy between market hops',
                        'Array length mismatch (marketAddresses vs isBuy vs nativeSend)',
                        'Native/ERC20 accounting confusion',
                        'Slippage check timing (_minAmountOut at end?)'
                    ]
                })
                
        return findings
        
    def run_full_analysis(self):
        """Run complete vulnerability analysis"""
        print("\n" + "="*70)
        print("ðŸŽ¯ KURU DEX VULNERABILITY ANALYSIS")
        print("="*70)
        
        all_findings = []
        
        all_findings.extend(self.analyze_vault_share_inflation())
        all_findings.extend(self.analyze_margin_account_access())
        all_findings.extend(self.analyze_orderbook_flip_orders())
        all_findings.extend(self.analyze_router_multihop())
        
        # Summary
        print("\n" + "="*70)
        print("ðŸ“Š FINDINGS SUMMARY")
        print("="*70)
        
        by_severity = {}
        for f in all_findings:
            sev = f.get('severity', 'UNKNOWN')
            by_severity[sev] = by_severity.get(sev, 0) + 1
            
        for sev, count in sorted(by_severity.items()):
            icon = {'CRITICAL': 'ðŸ”´', 'HIGH': 'ðŸŸ ', 'MEDIUM': 'ðŸŸ¡', 
                   'LOW': 'ðŸŸ¢', 'NEEDS_REVIEW': 'ðŸ”µ'}.get(sev, 'âšª')
            print(f"  {icon} {sev}: {count}")
            
        print(f"\n  Total findings: {len(all_findings)}")
        
        # Save report
        report = {
            'target': 'Kuru DEX',
            'contracts_analyzed': list(self.abis.keys()),
            'findings': all_findings,
            'summary': by_severity
        }
        
        with open('kuru_audit/vulnerability_report.json', 'w') as f:
            json.dump(report, f, indent=2)
            
        print(f"\nðŸ’¾ Report saved: kuru_audit/vulnerability_report.json")
        
        return all_findings

if __name__ == "__main__":
    analyzer = KuruAnalyzer()
    findings = analyzer.run_full_analysis()
    
    # Print critical findings
    print("\n" + "="*70)
    print("ðŸš¨ CRITICAL/HIGH FINDINGS FOR IMMEDIATE REVIEW")
    print("="*70)
    
    for f in findings:
        if f.get('severity') in ['CRITICAL', 'HIGH']:
            print(f"\n[{f['severity']}] {f['title']}")
            print(f"  {f['description']}")
            if 'attack' in f:
                print(f"  Attack: {f['attack']}")
            if 'poc_steps' in f:
                print("  PoC Steps:")
                for step in f['poc_steps']:
                    print(f"    {step}")
