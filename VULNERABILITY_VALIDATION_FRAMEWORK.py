#!/usr/bin/env python3
"""
Vulnerability Validation Framework - Professional Evidence Collection
Implements industry-standard vulnerability validation with reproducible proof
"""

import json
import requests
import subprocess
import time
import os
import base64
import hashlib
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from pathlib import Path
import urllib.parse

class VulnerabilityValidator:
    """
    Professional vulnerability validation system
    Provides validated findings with reproducible proof
    """
    
    def __init__(self, target_url: str, output_dir: str = "./validation_reports"):
        self.target_url = target_url
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Evidence collection
        self.evidence_log = []
        self.screenshots = []
        self.network_logs = []
        self.console_outputs = []
        
        # Validation session
        self.session_id = hashlib.md5(f"{target_url}_{datetime.now().isoformat()}".encode()).hexdigest()[:8]
        self.validation_start = datetime.now()
        
    def validate_vulnerability(self, vuln_type: str, endpoint: str, payload: str = None) -> Dict:
        """
        Validate a specific vulnerability with professional evidence collection
        
        Args:
            vuln_type: Type of vulnerability (xss, clickjacking, missing_csp, etc.)
            endpoint: Specific endpoint to test
            payload: Optional payload to test with
            
        Returns:
            Dict with validation results and evidence
        """
        
        validation_result = {
            'session_id': self.session_id,
            'target_url': self.target_url,
            'vulnerability_type': vuln_type,
            'endpoint_tested': endpoint,
            'validation_timestamp': self.validation_start.isoformat(),
            'validation_status': 'unknown',
            'evidence': {},
            'reproduction_steps': [],
            'proof_of_vulnerability': {},
            'risk_assessment': {},
            'responsible_disclosure': {}
        }
        
        # Route to specific validation method
        if vuln_type.lower() == 'clickjacking':
            validation_result = self._validate_clickjacking(endpoint, validation_result)
        elif vuln_type.lower() == 'xss':
            validation_result = self._validate_xss(endpoint, payload or '<script>alert("XSS")</script>', validation_result)
        elif vuln_type.lower() == 'missing_csp':
            validation_result = self._validate_missing_csp(endpoint, validation_result)
        elif vuln_type.lower() == 'missing_hsts':
            validation_result = self._validate_missing_hsts(endpoint, validation_result)
        elif vuln_type.lower() == 'csrf':
            validation_result = self._validate_csrf(endpoint, validation_result)
        elif vuln_type.lower() == 'idor':
            validation_result = self._validate_idor(endpoint, validation_result)
        elif vuln_type.lower() == 'ssrf':
            validation_result = self._validate_ssrf(endpoint, validation_result)
        else:
            validation_result['validation_status'] = 'unsupported'
            validation_result['evidence']['error'] = f"Vulnerability type '{vuln_type}' not supported"
        
        # Generate responsible disclosure summary
        validation_result['responsible_disclosure'] = self._generate_responsible_disclosure(validation_result)
        
        # Save validation report
        self._save_validation_report(validation_result)
        
        return validation_result
    
    def _validate_clickjacking(self, endpoint: str, result: Dict) -> Dict:
        """Validate clickjacking vulnerability with professional evidence"""
        
        print(f"üîç Validating Clickjacking: {endpoint}")
        
        # Step 1: Check X-Frame-Options header
        headers = self._get_headers(endpoint)
        x_frame_options = headers.get('X-Frame-Options', '').lower()
        csp_frame_options = headers.get('Content-Security-Policy', '').lower()
        
        evidence = {
            'headers_received': dict(headers),
            'x_frame_options': x_frame_options,
            'csp_frame_ancestors': 'frame-ancestors' in csp_frame_options,
            'iframe_test_result': None,
            'proof_of_concept': None
        }
        
        # Step 2: Test iframe embedding
        iframe_test_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking Validation Test - {endpoint}</title>
    <style>
        body {{ margin: 0; padding: 20px; font-family: Arial, sans-serif; }}
        .test-container {{ border: 2px solid #333; padding: 10px; margin: 10px 0; }}
        .iframe-container {{ width: 100%; height: 500px; border: 1px solid red; }}
        iframe {{ width: 100%; height: 100%; border: none; }}
        .result {{ margin: 10px 0; padding: 10px; }}
        .success {{ background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }}
        .failure {{ background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }}
    </style>
</head>
<body>
    <h1>üîç Clickjacking Validation Test</h1>
    <div class="test-container">
        <h2>Target: {endpoint}</h2>
        <p>X-Frame-Options: {x_frame_options or 'MISSING'}</p>
        <p>CSP frame-ancestors: {'PRESENT' if 'frame-ancestors' in csp_frame_options else 'MISSING'}</p>
    </div>
    
    <div class="test-container">
        <h2>IFrame Embedding Test</h2>
        <div class="iframe-container">
            <iframe src="{endpoint}" id="targetFrame"></iframe>
        </div>
        <div id="testResult" class="result">Testing iframe loading...</div>
    </div>
    
    <script>
        const iframe = document.getElementById('targetFrame');
        const resultDiv = document.getElementById('testResult');
        
        iframe.onload = function() {{
            try {{
                // Try to access iframe content (same-origin test)
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                resultDiv.className = 'result success';
                resultDiv.innerHTML = '‚úÖ IFrame loaded successfully - VULNERABLE to clickjacking';
            }} catch(e) {{
                // Cross-origin - but iframe still loaded
                resultDiv.className = 'result success';
                resultDiv.innerHTML = '‚úÖ IFrame loaded (cross-origin) - VULNERABLE to clickjacking';
            }}
        }};
        
        iframe.onerror = function() {{
            resultDiv.className = 'result failure';
            resultDiv.innerHTML = '‚ùå IFrame blocked by X-Frame-Options or CSP - NOT VULNERABLE';
        }};
        
        // Timeout after 10 seconds
        setTimeout(function() {{
            if (resultDiv.innerHTML === 'Testing iframe loading...') {{
                resultDiv.className = 'result failure';
                resultDiv.innerHTML = '‚ùå IFrame failed to load - NOT VULNERABLE or network error';
            }}
        }}, 10000);
    </script>
</body>
</html>
        """
        
        # Save iframe test
        test_file = self.output_dir / f"clickjacking_test_{self.session_id}.html"
        with open(test_file, 'w', encoding='utf-8') as f:
            f.write(iframe_test_html)
        
        evidence['iframe_test_file'] = str(test_file)
        evidence['iframe_test_html'] = iframe_test_html
        
        # Step 3: Determine vulnerability status
        is_vulnerable = (
            not x_frame_options or 
            x_frame_options in ['allow-from', 'sameorigin'] or  # Weak configurations
            'frame-ancestors' not in csp_frame_options
        )
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        # Step 4: Generate reproduction steps
        result['reproduction_steps'] = [
            f"1. Navigate to the target endpoint: {endpoint}",
            f"2. Check HTTP headers - X-Frame-Options: {x_frame_options or 'MISSING'}",
            f"3. Check CSP header - frame-ancestors: {'PRESENT' if 'frame-ancestors' in csp_frame_options else 'MISSING'}",
            "4. Create HTML page with iframe embedding the target",
            "5. Load the HTML page in browser",
            f"6. Observe iframe loads: {'SUCCESS (vulnerable)' if is_vulnerable else 'BLOCKED (not vulnerable)'}",
            "7. If vulnerable, attacker can overlay hidden elements to hijack clicks"
        ]
        
        # Step 5: Generate proof of vulnerability
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'clickjacking',
                'severity': 'medium',
                'impact_description': 'Attackers can embed the target in invisible iframes and trick users into clicking hidden UI elements',
                'exploit_scenario': 'An attacker could create a fake login page that overlays the real login form, capturing user credentials',
                'business_impact': 'Account takeover, unauthorized actions, data theft through UI manipulation',
                'test_file_location': str(test_file)
            }
        
        return result
    
    def _validate_xss(self, endpoint: str, payload: str, result: Dict) -> Dict:
        """Validate XSS vulnerability with professional evidence"""
        
        print(f"üîç Validating XSS: {endpoint}")
        
        # Step 1: Check CSP header
        headers = self._get_headers(endpoint)
        csp_header = headers.get('Content-Security-Policy', '')
        
        evidence = {
            'headers_received': dict(headers),
            'csp_header': csp_header,
            'csp_strict': csp_header and ('script-src' in csp_header or 'default-src' in csp_header),
            'payload_tested': payload,
            'injection_points': [],
            'response_analysis': {}
        }
        
        # Step 2: Identify injection points
        test_params = ['q', 'search', 'query', 'input', 'data', 'param', 'test']
        injection_results = []
        
        for param in test_params:
            test_url = f"{endpoint}?{param}={urllib.parse.quote(payload)}"
            
            try:
                response = requests.get(test_url, timeout=10, verify=False)
                
                injection_result = {
                    'parameter': param,
                    'test_url': test_url,
                    'status_code': response.status_code,
                    'payload_reflected': payload in response.text,
                    'script_executed': False,  # Would need browser automation for real test
                    'response_snippet': response.text[:500] if len(response.text) > 500 else response.text
                }
                
                injection_results.append(injection_result)
                evidence['injection_points'].append(injection_result)
                
            except Exception as e:
                evidence['injection_points'].append({
                    'parameter': param,
                    'error': str(e)
                })
        
        # Step 3: Check for reflected XSS
        is_vulnerable = any(
            result['payload_reflected'] and 
            not evidence['csp_strict']
            for result in injection_results
        )
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        # Step 4: Generate reproduction steps
        vulnerable_params = [r['parameter'] for r in injection_results if r['payload_reflected']]
        
        result['reproduction_steps'] = [
            f"1. Navigate to target endpoint: {endpoint}",
            f"2. Check CSP header: {'PRESENT' if csp_header else 'MISSING'}",
            f"3. Test XSS payload: {payload}",
            f"4. Test parameters: {', '.join(vulnerable_params) if vulnerable_params else 'None vulnerable'}",
            "5. Observe payload reflection in response",
            f"6. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        # Step 5: Generate proof of vulnerability
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'cross-site scripting',
                'severity': 'high',
                'impact_description': 'Attackers can inject malicious scripts that execute in victims\' browsers',
                'exploit_scenario': 'Session hijacking, credential theft, malware distribution through script injection',
                'business_impact': 'Account takeover, data theft, malware distribution, compliance violations',
                'vulnerable_parameters': vulnerable_params,
                'payload_used': payload
            }
        
        return result
    
    def _validate_missing_csp(self, endpoint: str, result: Dict) -> Dict:
        """Validate missing CSP vulnerability"""
        
        print(f"üîç Validating Missing CSP: {endpoint}")
        
        headers = self._get_headers(endpoint)
        csp_header = headers.get('Content-Security-Policy', '')
        
        evidence = {
            'headers_received': dict(headers),
            'csp_header': csp_header,
            'csp_present': bool(csp_header),
            'csp_analysis': self._analyze_csp(csp_header) if csp_header else None,
            'risk_assessment': None
        }
        
        is_vulnerable = not bool(csp_header)
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        result['reproduction_steps'] = [
            f"1. Navigate to target endpoint: {endpoint}",
            f"2. Check HTTP headers for CSP: {'PRESENT' if csp_header else 'MISSING'}",
            "3. If missing, site lacks XSS protection",
            "4. Test script injection in various contexts",
            f"5. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'missing content security policy',
                'severity': 'medium',
                'impact_description': 'No protection against XSS and other injection attacks',
                'exploit_scenario': 'Attackers can inject scripts, steal data, and perform malicious actions',
                'business_impact': 'XSS vulnerabilities, data theft, compliance violations'
            }
        
        return result
    
    def _validate_missing_hsts(self, endpoint: str, result: Dict) -> Dict:
        """Validate missing HSTS vulnerability"""
        
        print(f"üîç Validating Missing HSTS: {endpoint}")
        
        # Ensure HTTPS URL for HSTS test
        https_url = endpoint.replace('http://', 'https://')
        
        try:
            headers = self._get_headers(https_url)
            hsts_header = headers.get('Strict-Transport-Security', '')
        except:
            # HTTPS not available
            hsts_header = ''
            https_url = "HTTPS_NOT_AVAILABLE"
        
        evidence = {
            'headers_received': dict(headers) if 'headers' in locals() else {},
            'hsts_header': hsts_header,
            'hsts_present': bool(hsts_header),
            'https_available': https_url != "HTTPS_NOT_AVAILABLE",
            'hsts_analysis': self._analyze_hsts(hsts_header) if hsts_header else None
        }
        
        is_vulnerable = not bool(hsts_header) and https_url != "HTTPS_NOT_AVAILABLE"
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        result['reproduction_steps'] = [
            f"1. Test HTTPS availability: {'YES' if https_url != 'HTTPS_NOT_AVAILABLE' else 'NO'}",
            f"2. Check HSTS header: {'PRESENT' if hsts_header else 'MISSING'}",
            "3. If missing, vulnerable to SSL stripping attacks",
            "4. Test HTTP connection downgrade",
            f"5. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'missing HSTS',
                'severity': 'medium',
                'impact_description': 'Vulnerable to SSL stripping and man-in-the-middle attacks',
                'exploit_scenario': 'Attackers can downgrade HTTPS to HTTP and intercept credentials',
                'business_impact': 'Credential theft, session hijacking, data interception'
            }
        
        return result
    
    def _validate_csrf(self, endpoint: str, result: Dict) -> Dict:
        """Validate CSRF vulnerability"""
        
        print(f"üîç Validating CSRF: {endpoint}")
        
        # Check for anti-CSRF tokens
        response = requests.get(endpoint, timeout=10, verify=False)
        
        evidence = {
            'forms_found': [],
            'csrf_tokens_found': [],
            'same_site_cookies': [],
            'headers_received': dict(response.headers)
        }
        
        # Analyze forms
        from bs4 import BeautifulSoup
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        csrf_token_patterns = ['csrf', 'token', '_token', 'authenticity_token', 'xsrf-token']
        
        for form in forms:
            form_info = {
                'action': form.get('action', ''),
                'method': form.get('method', 'GET'),
                'inputs': []
            }
            
            # Look for CSRF tokens in form
            inputs = form.find_all('input')
            has_csrf_token = False
            
            for inp in inputs:
                input_info = {
                    'name': inp.get('name', ''),
                    'type': inp.get('type', ''),
                    'value': inp.get('value', '')
                }
                form_info['inputs'].append(input_info)
                
                # Check if this looks like a CSRF token
                if any(pattern in input_info['name'].lower() for pattern in csrf_token_patterns):
                    has_csrf_token = True
                    evidence['csrf_tokens_found'].append(input_info)
            
            evidence['forms_found'].append(form_info)
        
        # Check SameSite cookie attributes
        cookies = response.cookies
        for cookie in cookies:
            cookie_info = {
                'name': cookie.name,
                'same_site': getattr(cookie, 'SameSite', 'None'),
                'secure': cookie.secure,
                'http_only': cookie.httpOnly
            }
            evidence['same_site_cookies'].append(cookie_info)
        
        is_vulnerable = (
            len(evidence['forms_found']) > 0 and 
            len(evidence['csrf_tokens_found']) == 0 and
            not any(c['same_site'] in ['Strict', 'Lax'] for c in evidence['same_site_cookies'])
        )
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        result['reproduction_steps'] = [
            f"1. Navigate to target endpoint: {endpoint}",
            f"2. Analyze forms found: {len(evidence['forms_found'])}",
            f"3. Check for CSRF tokens: {len(evidence['csrf_tokens_found'])} found",
            f"4. Check SameSite cookies: {len([c for c in evidence['same_site_cookies'] if c['same_site'] in ['Strict', 'Lax']])} protected",
            f"5. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'cross-site request forgery',
                'severity': 'high',
                'impact_description': 'Attackers can forge requests on behalf of authenticated users',
                'exploit_scenario': 'Unauthorized actions, data modification, account takeover through forged requests',
                'business_impact': 'Unauthorized actions, data manipulation, compliance violations'
            }
        
        return result
    
    def _validate_idor(self, endpoint: str, result: Dict) -> Dict:
        """Validate IDOR vulnerability"""
        
        print(f"üîç Validating IDOR: {endpoint}")
        
        evidence = {
            'endpoint_tested': endpoint,
            'access_patterns': [],
            'authorization_checks': {},
            'test_results': []
        }
        
        # Test common IDOR patterns
        idor_patterns = [
            r'/api/users/(\d+)',
            r'/user/(\d+)/profile',
            r'/data/(\d+)',
            r'/records/(\d+)',
            r'/files/(\d+)'
        ]
        
        import re
        
        for pattern in idor_patterns:
            if re.search(pattern, endpoint):
                # Test with different IDs
                for test_id in ['1', '999999', '0', '-1']:
                    test_endpoint = re.sub(r'\d+', test_id, endpoint)
                    
                    try:
                        response = requests.get(test_endpoint, timeout=10, verify=False)
                        
                        test_result = {
                            'test_id': test_id,
                            'endpoint': test_endpoint,
                            'status_code': response.status_code,
                            'response_length': len(response.text),
                            'access_granted': response.status_code not in [401, 403, 404],
                            'response_snippet': response.text[:200] if len(response.text) > 200 else response.text
                        }
                        
                        evidence['test_results'].append(test_result)
                        
                    except Exception as e:
                        evidence['test_results'].append({
                            'test_id': test_id,
                            'endpoint': test_endpoint,
                            'error': str(e)
                        })
        
        # Analyze results for IDOR
        unauthorized_access = any(
            result['access_granted'] and result['test_id'] in ['999999', '0', '-1']
            for result in evidence['test_results']
        )
        
        is_vulnerable = unauthorized_access
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        result['reproduction_steps'] = [
            f"1. Identify endpoint with ID pattern: {endpoint}",
            "2. Test with legitimate user ID (should work)",
            "3. Test with unauthorized IDs (999999, 0, -1)",
            "4. Check if unauthorized access is granted",
            f"5. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'insecure direct object reference',
                'severity': 'high',
                'impact_description': 'Access control bypass allows viewing/modifying other users\' data',
                'exploit_scenario': 'Data theft, privacy breach, unauthorized access to sensitive information',
                'business_impact': 'Data breach, privacy violations, compliance failures'
            }
        
        return result
    
    def _validate_ssrf(self, endpoint: str, result: Dict) -> Dict:
        """Validate SSRF vulnerability"""
        
        print(f"üîç Validating SSRF: {endpoint}")
        
        # Test SSRF payloads
        ssrf_payloads = [
            'http://127.0.0.1:80',
            'http://localhost:80',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'file:///etc/passwd',
            'ftp://127.0.0.1:21',
            'gopher://127.0.0.1:70'
        ]
        
        evidence = {
            'endpoint_tested': endpoint,
            'payloads_tested': [],
            'responses': {},
            'dns_requests': []
        }
        
        for payload in ssrf_payloads:
            try:
                # Try different parameter names
                for param in ['url', 'target', 'redirect', 'callback', 'return']:
                    test_url = f"{endpoint}?{param}={urllib.parse.quote(payload)}"
                    
                    response = requests.get(test_url, timeout=10, verify=False)
                    
                    test_result = {
                        'payload': payload,
                        'parameter': param,
                        'test_url': test_url,
                        'status_code': response.status_code,
                        'response_time': response.elapsed.total_seconds(),
                        'response_length': len(response.text),
                        'indicators': self._check_ssrf_indicators(response.text, payload)
                    }
                    
                    evidence['payloads_tested'].append(test_result)
                    
            except Exception as e:
                evidence['payloads_tested'].append({
                    'payload': payload,
                    'error': str(e)
                })
        
        # Check for SSRF indicators
        ssrf_indicators = [
            'root:x:0:0',  # /etc/passwd indicator
            'instance-id',  # AWS metadata indicator
            'localhost',
            '127.0.0.1'
        ]
        
        is_vulnerable = any(
            any(indicator in result.get('indicators', {}).get('text_content', '') for indicator in ssrf_indicators)
            for result in evidence['payloads_tested']
            if 'indicators' in result
        )
        
        result['validation_status'] = 'vulnerable' if is_vulnerable else 'not_vulnerable'
        result['evidence'] = evidence
        
        result['reproduction_steps'] = [
            f"1. Identify endpoint that takes URLs: {endpoint}",
            "2. Test with internal network addresses",
            "3. Test with file:// protocol",
            "4. Test with cloud metadata endpoints",
            "5. Check response for internal data",
            f"6. Vulnerability confirmed: {'YES' if is_vulnerable else 'NO'}"
        ]
        
        if is_vulnerable:
            result['proof_of_vulnerability'] = {
                'type': 'server-side request forgery',
                'severity': 'critical',
                'impact_description': 'Server can be forced to access internal network resources',
                'exploit_scenario': 'Internal network scanning, cloud metadata theft, file access',
                'business_impact': 'Internal network compromise, cloud credential theft, data breach'
            }
        
        return result
    
    def _get_headers(self, url: str) -> Dict:
        """Get HTTP headers for URL"""
        try:
            response = requests.head(url, timeout=10, verify=False, allow_redirects=True)
            return dict(response.headers)
        except Exception as e:
            return {'error': str(e)}
    
    def _analyze_csp(self, csp_header: str) -> Dict:
        """Analyze CSP header effectiveness"""
        directives = csp_header.split(';')
        analysis = {
            'script_src_present': False,
            'default_src_present': False,
            'unsafe_inline_allowed': False,
            'unsafe_eval_allowed': False,
            'strict_dynamic': False
        }
        
        for directive in directives:
            directive = directive.strip().lower()
            if directive.startswith('script-src'):
                analysis['script_src_present'] = True
                if 'unsafe-inline' in directive:
                    analysis['unsafe_inline_allowed'] = True
                if 'unsafe-eval' in directive:
                    analysis['unsafe_eval_allowed'] = True
            elif directive.startswith('default-src'):
                analysis['default_src_present'] = True
            if 'strict-dynamic' in directive:
                analysis['strict_dynamic'] = True
        
        return analysis
    
    def _analyze_hsts(self, hsts_header: str) -> Dict:
        """Analyze HSTS header effectiveness"""
        directives = hsts_header.split(';')
        analysis = {
            'max_age': 0,
            'include_subdomains': False,
            'preload': False
        }
        
        for directive in directives:
            directive = directive.strip()
            if directive.startswith('max-age='):
                try:
                    analysis['max_age'] = int(directive.split('=')[1])
                except:
                    pass
            elif directive == 'includeSubDomains':
                analysis['include_subdomains'] = True
            elif directive == 'preload':
                analysis['preload'] = True
        
        return analysis
    
    def _check_ssrf_indicators(self, response_text: str, payload: str) -> Dict:
        """Check for SSRF indicators in response"""
        indicators = {
            'text_content': response_text[:500],  # First 500 chars
            'file_indicators': 'root:x:0:0' in response_text or '/bin/bash' in response_text,
            'aws_indicators': 'instance-id' in response_text or 'ami-id' in response_text,
            'localhost_indicators': 'localhost' in response_text or '127.0.0.1' in response_text,
            'error_messages': 'connection refused' in response_text.lower() or 'timeout' in response_text.lower()
        }
        
        return indicators
    
    def _generate_responsible_disclosure(self, validation_result: Dict) -> Dict:
        """Generate responsible disclosure summary"""
        
        vuln_type = validation_result['vulnerability_type']
        status = validation_result['validation_status']
        
        disclosure = {
            'summary': f"{vuln_type.upper()} {'VULNERABILITY CONFIRMED' if status == 'vulnerable' else 'NOT VULNERABLE'}",
            'security_focus': 'The security flaw itself, not attack automation',
            'technical_details': validation_result.get('proof_of_vulnerability', {}),
            'remediation_priority': self._get_remediation_priority(validation_result),
            'compliance_impact': self._get_compliance_impact(vuln_type),
            'next_steps': [
                'Review validation evidence',
                'Assess business impact',
                'Plan remediation',
                'Test fix implementation',
                'Monitor for regressions'
            ]
        }
        
        return disclosure
    
    def _get_remediation_priority(self, validation_result: Dict) -> str:
        """Get remediation priority based on vulnerability type and severity"""
        
        severity_map = {
            'ssrf': 'critical',
            'idor': 'high',
            'xss': 'high',
            'csrf': 'high',
            'clickjacking': 'medium',
            'missing_csp': 'medium',
            'missing_hsts': 'medium'
        }
        
        vuln_type = validation_result['vulnerability_type'].lower()
        return severity_map.get(vuln_type, 'medium')
    
    def _get_compliance_impact(self, vuln_type: str) -> List[str]:
        """Get compliance impact for vulnerability type"""
        
        compliance_map = {
            'xss': ['OWASP Top 10', 'PCI-DSS', 'GDPR', 'SOC 2'],
            'csrf': ['OWASP Top 10', 'PCI-DSS', 'SOC 2'],
            'idor': ['OWASP Top 10', 'GDPR', 'HIPAA', 'PCI-DSS'],
            'ssrf': ['OWASP Top 10', 'PCI-DSS', 'SOC 2', 'CIS Controls'],
            'clickjacking': ['OWASP Top 10', 'PCI-DSS'],
            'missing_csp': ['OWASP Top 10', 'PCI-DSS', 'SOC 2'],
            'missing_hsts': ['PCI-DSS', 'SOC 2', 'NIST CSF']
        }
        
        return compliance_map.get(vuln_type.lower(), ['General Security'])
    
    def _save_validation_report(self, validation_result: Dict):
        """Save validation report to file"""
        
        filename = f"validation_{validation_result['vulnerability_type']}_{validation_result['session_id']}.json"
        filepath = self.output_dir / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(validation_result, f, indent=2, default=str)
        
        print(f"üìÑ Validation report saved: {filepath}")
    
    def generate_summary_report(self, validations: List[Dict]) -> Dict:
        """Generate summary report of all validations"""
        
        summary = {
            'summary_timestamp': datetime.now().isoformat(),
            'target_url': self.target_url,
            'total_validations': len(validations),
            'vulnerabilities_found': len([v for v in validations if v['validation_status'] == 'vulnerable']),
            'vulnerability_types': list(set(v['vulnerability_type'] for v in validations)),
            'severity_distribution': {},
            'compliance_impact': [],
            'recommendations': []
        }
        
        # Count severities
        for validation in validations:
            if validation['validation_status'] == 'vulnerable':
                proof = validation.get('proof_of_vulnerability', {})
                severity = proof.get('severity', 'medium')
                summary['severity_distribution'][severity] = summary['severity_distribution'].get(severity, 0) + 1
        
        # Aggregate compliance impacts
        all_compliance = []
        for validation in validations:
            if validation['validation_status'] == 'vulnerable':
                compliance = validation['responsible_disclosure'].get('compliance_impact', [])
                all_compliance.extend(compliance)
        
        summary['compliance_impact'] = list(set(all_compliance))
        
        # Generate recommendations
        if summary['vulnerabilities_found'] > 0:
            summary['recommendations'] = [
                "Prioritize critical and high severity vulnerabilities",
                "Implement security headers (CSP, HSTS, X-Frame-Options)",
                "Add input validation and output encoding",
                "Implement proper access controls",
                "Regular security testing and monitoring"
            ]
        
        return summary

# Usage example
if __name__ == "__main__":
    validator = VulnerabilityValidator("https://example.com")
    
    # Validate clickjacking
    clickjacking_result = validator.validate_vulnerability("clickjacking", "https://example.com/login")
    print(f"Clickjacking validation: {clickjacking_result['validation_status']}")
    
    # Validate XSS
    xss_result = validator.validate_vulnerability("xss", "https://example.com/search")
    print(f"XSS validation: {xss_result['validation_status']}")
    
    # Generate summary
    summary = validator.generate_summary_report([clickjacking_result, xss_result])
    print(f"Summary: {summary['vulnerabilities_found']} vulnerabilities found")
