<!DOCTYPE html>
<!-- saved from url=(0065)https://archive.org/stream/hackingciphers/hackingciphers_djvu.txt -->
<html lang="en"><!-- __ _ _ _ __| |_ (_)__ _____
    / _` | '_/ _| ' \| |\ V / -_)
    \__,_|_| \__|_||_|_| \_/\___| --><head data-release="11e75e73" data-node="www29.us.archive.org"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } 
</style>
    <title>Full text of "Hacking Secret Ciphers With Python"</title>

          <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
        <meta name="google-site-verification" content="Q2YSouphkkgHkFNP7FgAkc4TmBs1Gmag3uGNndb53B8">
    <meta name="google-site-verification" content="bpjKvUvsX0lxfmjg19TLblckWkDpnptZEYsBntApxUk">

    <meta name="baggage" content="sentry-trace_id=e3ad3c63c0e7400bbda8750c634a69ab,sentry-sample_rate=0.001,sentry-transaction=%2Fdownload.php,sentry-public_key=94bf3037c1e245c8a927aaa4daad2dbb,sentry-environment=production,sentry-sampled=false">    <meta name="sentry-trace" content="e3ad3c63c0e7400bbda8750c634a69ab-4e1c17017ede4c3b-0">
    <script async="" src="./Full text of _Hacking Secret Ciphers With Python__files/container_ZUUaFed2.js.download"></script><script nonce="">
/* @licstart  The following is the entire license notice for the
 * JavaScript code in this page.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in this page.
 */
</script>
        
                      <meta property="mediatype" content="texts">
                      <meta property="primary_collection" content="">
            <script src="./Full text of _Hacking Secret Ciphers With Python__files/athena.js.download" type="text/javascript"></script>
    <script src="./Full text of _Hacking Secret Ciphers With Python__files/apollo.js.download" type="text/javascript"></script>
    <script src="./Full text of _Hacking Secret Ciphers With Python__files/polyfill-support.js.download" type="text/javascript"></script>
    <script src="./Full text of _Hacking Secret Ciphers With Python__files/webcomponents-bundle.js.download" type="text/javascript"></script>
<script nonce="">
      window.__realDefine = customElements.define.bind(customElements);
      customElements.define = function() {
        try {
          return window.__realDefine.apply(this, arguments);
        } catch (e) {
          console.warn(e);
        }
      }
    </script>    <script src="./Full text of _Hacking Secret Ciphers With Python__files/ia-topnav.min.js.download" type="text/javascript"></script>
    <script src="./Full text of _Hacking Secret Ciphers With Python__files/archive.min.js.download" type="text/javascript"></script>
<link rel="canonical" href="https://archive.org/details/hackingciphers">
    <link href="./Full text of _Hacking Secret Ciphers With Python__files/archive.min.css" rel="stylesheet" type="text/css">
    <link rel="SHORTCUT ICON" href="https://archive.org/images/glogo.jpg">
  <style>
#manage-ids {
  visibility: hidden;
  position: absolute;
  top: 0;
  left: 0;
  width: 1px;
  height: 1px;
}

#manage-help > div {
  display: inline-block;
  font-weight: bold;
  font-size: 125%;
  padding-right: 10px;
}

#manage-help .btn-info {
  background-color: #777;
  border-color: #666;
}


#manage-help > p {
  text-align: center;
}

.item-ia.manage-item  .item-img {
  opacity: .8;
}

.item-ia.manage-item  .item-img:hover {
  opacity: .9;
}

.manage-check {
  position: absolute;
  right: 0;
  top: 0;
  border-style: solid;
  border-color: black;
  border-width: 2px 4px;
  background-color: black;
  border-radius: 3px;
}

#confirm-remove-items .btn {
  display: block;
  margin: 0 auto 10px;
}

.task-pending {
  opacity: .20;
}

/* Bulk remove items modal */
#confirm-remove-items .modal-content {
  padding: 1rem;
}

#confirm-remove-items h2 {
  font-size: 2.4rem;
}
</style></head>
  <body class="navia ">
    <a href="https://archive.org/stream/hackingciphers/hackingciphers_djvu.txt#maincontent" class="hidden-for-screen-readers">Skip to main content</a>

    <!-- Wraps all page content -->
    <div id="wrap">
                    <div class="ia-banners">
              <div class="ia-banner hidden post-appeal-20240905 visible" data-campaign="post-appeal-20240905">
        <p><a href="https://change.org/LetReadersRead" rel="ugc nofollow">Ask the publishers</a> to restore access to 500,000+ books.</p>
        <form class="banner-close" action="https://archive.org/stream/hackingciphers/hackingciphers_djvu.txt" method="get" data-action="ia-banner-close">
          <fieldset>
            <button aria-label="Close Banner" type="submit"></button>
          </fieldset>
        </form>
      </div>
          </div>
                    <div id="topnav">
              <input class="js_nav_tweaks" type="hidden" value="[]">
    <!-- Shady DOM styles for icon-hamburger -->
<style scope="icon-hamburger-1">
  .icon-hamburger-1 svg.icon-hamburger {
    display: block;
    height: 4rem;
    width: 4rem;
  }

  .icon-hamburger-1 .fill-color.icon-hamburger {
    fill: #fff;
  }
</style><!-- Shady DOM styles for login-button -->
<style scope="login-button-1">
  .login-button-1 .dropdown-toggle.login-button {
    display: block;
    text-transform: uppercase;
    color: #ccc;
    cursor: pointer;
  }

  .login-button-1 .dropdown-toggle.login-button svg.login-button {
    height: 100%;
    width: 4rem;
  }

  .login-button-1 .dropdown-toggle.login-button .fill-color.login-button {
    fill: #999;
  }

  .login-button-1 .dropdown-toggle.login-button:active .fill-color.login-button,
  .login-button-1 .dropdown-toggle.login-button:focus .fill-color.login-button,
  .login-button-1 .dropdown-toggle.login-button:hover .fill-color.login-button {
    fill: #fff;
  }

  .login-button-1 .active.login-button {
    border-radius: 1rem 1rem 0 0;
    background: #333;
  }

  .login-button-1 .active.login-button .fill-color.login-button {
    fill: #fff;
  }

  .login-button-1 span.login-button {
    display: none;
    font-size: 1.4rem;
    text-transform: uppercase;
    color: #999;
  }

  .login-button-1 span.login-button a.login-button {
    color: inherit;
    text-decoration: none;
    outline: 0;
  }

  .login-button-1 a.login-button:hover,
  .login-button-1 a.login-button:active,
  .login-button-1 a.login-button:focus {
    color: #fff !important;
    outline: none !important;
    outline-offset: inherit !important;
  }

  @media (min-width: 890px) {
    .login-button-1 .logged-out-toolbar.login-button {
      padding: 1rem 0.5rem;
      vertical-align: middle;
    }

    .login-button-1 .active.login-button {
      background: transparent;
    }

    .login-button-1 .dropdown-toggle.login-button {
      display: inline-block;
      vertical-align: middle;
    }

    .login-button-1 .dropdown-toggle.login-button svg.login-button {
      height: 3rem;
      width: 3rem;
      display: block;
    }

    .login-button-1 span.login-button {
      display: inline;
      vertical-align: middle;
    }

  }
</style><!-- Shady DOM styles for nav-search -->
<style scope="nav-search-1">
  .nav-search-1 input.nav-search[type="text"] {
    color: #222;
  }

  .nav-search-1 input.nav-search:focus {
    outline: none;
  }

  .nav-search-1 button.nav-search {
    background: none;
    color: inherit;
    border: none;
    font: inherit;
    cursor: pointer;
  }

  .nav-search-1 button.nav-search:focus {
    outline: none;
  }

  .nav-search-1 .search.nav-search {
    padding-top: 0;
    margin-right: 0.5rem;
  }

  .nav-search-1 .search.nav-search svg.nav-search {
    position: relative;
    fill: ;
  }

  .nav-search-1 .search-activated.nav-search {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    position: absolute;
    top: 0;
    right: 4rem;
    bottom: 0;
    left: 4rem;
    z-index: 3;
    padding: 0.5rem 0.2rem;
    border-radius: 1rem 1rem 0 0;
    background: #333;
  }

  .nav-search-1 .search-inactive.nav-search {
    display: none;
  }

  .nav-search-1 .search-activated.nav-search .highlight.nav-search,
  .nav-search-1 .search-activated.nav-search .search.nav-search {
    background: #fff;
    border-radius: 0.5rem;
  }

  .nav-search-1 .search-activated.nav-search .highlight.nav-search {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    width: 100%;
    margin: 0 0.5rem;
  }

  .nav-search-1 .search-activated.nav-search .search.nav-search {
    height: 100%;
    padding: 0;
    margin-right: 0;
    -ms-flex-item-align: center;
    -ms-grid-row-align: center;
    align-self: center;
  }

  .nav-search-1 .search-activated.nav-search .search.nav-search svg.nav-search {
    height: 3rem;
    width: 3rem;
  }

  .nav-search-1 .search-activated.nav-search .search-field.nav-search {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding-left: 1rem;
    border-radius: 0.5rem;
    border: none;
    font-size: 1.6rem;
    text-align: center;
  }

  .nav-search-1 .search-activated.nav-search .search-field.nav-search:focus {
    outline: none;
  }

  @keyframes fade-in-nav-search-1 {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }

  }

  .nav-search-1 .fade-in.nav-search {
    animation: fade-in-nav-search-1 0.2s forwards;
  }

  @media (min-width: 890px) {
    .nav-search-1 .search.nav-search svg.nav-search {
      display: inline;
      width: 2.8rem;
      height: 2.8rem;
      vertical-align: -14px;
    }

    .nav-search-1 .search.nav-search path.nav-search {
      fill: #333;
    }

    .nav-search-1 .search-inactive.nav-search,
    .nav-search-1 .search-activated.nav-search {
      display: block;
      position: static;
      padding: 1.1rem 0.2rem;
      background: transparent;
    }

    .nav-search-1 .search-activated.nav-search .highlight.nav-search {
      width: 13rem;
      height: 2.8rem;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: reverse;
      -ms-flex-direction: row-reverse;
      flex-direction: row-reverse;
    }

    .nav-search-1 .search-activated.nav-search .search-field.nav-search {
      width: calc(100% - 28px);
      height: 100%;
      padding-left: 0;
      font-size: 1.4rem;
      text-align: left;
    }

    .nav-search-1 .search-activated.nav-search .search.nav-search svg.nav-search {
      width: 2.8rem;
      height: 2.8rem;
    }

  }
</style><!-- Shady DOM styles for media-button -->
<style scope="media-button-1">
  .media-button-1 a.media-button {
    display: inline-block;
    text-decoration: none;
  }

  .media-button-1 .menu-item.media-button {
    display: inline-block;
    width: 100%;
    padding: 0;
    font-size: 1.6rem;
    text-align: left;
    background: transparent;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
  }

  .media-button-1 .menu-item.media-button:focus {
    outline: none;
  }

  .media-button-1 .label.media-button {
    display: inline-block;
    padding: 0;
    font-weight: 400;
    color: #fff;
    text-align: left;
    vertical-align: middle;
  }

  .media-button-1 .menu-item.media-button>.icon.media-button {
    display: inline-flex;
    vertical-align: middle;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
  }

  .media-button-1 .menu-item.media-button>.icon.media-button>svg.media-button {
    height: 4rem;
    width: 4rem;
  }

  .media-button-1 .menu-item.selected.media-button .icon.media-button {
    background-color: #333;
    border-radius: 1rem 0 0 1rem;
  }

  .media-button-1 .icon.media-button .fill-color.media-button {
    fill: #999;
  }

  .media-button-1 .icon.active.media-button .fill-color.media-button {
    fill: #fff;
  }

  .media-button-1 .donate.media-button .fill-color.media-button {
    fill: #f00;
  }

  @media (min-width: 890px) {
    .media-button-1 .menu-item.media-button {
      width: auto;
      height: 5rem;
      color: #999;
      display: inline-flex;
    }

    .media-button-1 .menu-item.media-button:hover,
    .media-button-1 .menu-item.media-button:active,
    .media-button-1 .menu-item.media-button:focus {
      color: #fff;
    }

    .media-button-1 .menu-item.media-button:hover .fill-color.media-button,
    .media-button-1 .menu-item.media-button:active .fill-color.media-button,
    .media-button-1 .menu-item.media-button:focus .fill-color.media-button {
      fill: #fff;
    }

    .media-button-1 .label.media-button {
      display: none;
    }

    .media-button-1 .label.media-button,
    .media-button-1 .web.media-button:after {
      padding-right: 1rem;
      font-size: 1.3rem;
      text-transform: uppercase;
      color: inherit;
    }

    .media-button-1 .web.media-button:after {
      display: none;
      content: "web";
    }

    .media-button-1 .donate.media-button,
    .media-button-1 .more.media-button {
      display: none;
    }

    .media-button-1 .menu-item.selected.media-button {
      background: #474747;
    }

    .media-button-1 .menu-item.selected.media-button .label.media-button,
    .media-button-1 .menu-item.selected.web.media-button:after {
      color: #fff;
    }

    .media-button-1 .menu-item.selected.media-button .icon.media-button {
      background: transparent;
    }

    .media-button-1 .web.selected.media-button .fill-color.media-button {
      fill: #ffcd27;
    }

    .media-button-1 .texts.selected.media-button .fill-color.media-button {
      fill: #faab3c;
    }

    .media-button-1 .video.selected.media-button .fill-color.media-button {
      fill: #f1644b;
    }

    .media-button-1 .audio.selected.media-button .fill-color.media-button {
      fill: #00adef;
    }

    .media-button-1 .software.selected.media-button .fill-color.media-button {
      fill: #9ecc4f;
    }

    .media-button-1 .images.selected.media-button .fill-color.media-button {
      fill: #aa99c9;
    }

  }

  @media (min-width: 1200px) {

    .media-button-1 .label.media-button,
    .media-button-1 .web.media-button:after {
      display: inline;
    }

    .media-button-1 .web.media-button .label.media-button {
      display: none;
    }

  }
</style><!-- Shady DOM styles for media-menu -->
<style scope="media-menu-1">
  .media-menu-1 {
    outline: none;
  }

  .media-menu-1 .media-menu-inner.media-menu {
    z-index: -1;
    top: -40rem;
    background-color: #222;
    margin: 0;
    overflow: hidden;
    transition-duration: 0.2s;
    transition-property: top;
    transition-timing-function: ease;
  }

  .media-menu-1 .menu-group.media-menu {
    position: relative;
    line-height: normal;
  }

  @media (max-width: 889px) {
    .media-menu-1 .media-menu-inner.media-menu {
      position: absolute;
      width: 100%;
    }

    .media-menu-1 .open.media-menu .media-menu-inner.media-menu {
      top: 0;
    }

    .media-menu-1 .overflow-clip.media-menu {
      position: absolute;
      z-index: -1;
      top: 4rem;
      left: 0;
      height: 0;
      width: 100%;
      overflow: hidden;
      transition-duration: 0.2s;
      transition-property: height;
    }

    .media-menu-1 .open.media-menu .overflow-clip.media-menu {
      height: 40rem;
    }

  }

  @media (min-width: 890px) {
    .media-menu-1 .media-menu-inner.media-menu {
      display: block;
      position: static;
      width: auto;
      height: 5rem;
      transition-property: none;
    }

    .media-menu-1 .menu-group.media-menu {
      font-size: 0;
    }

  }
</style><!-- Shady DOM styles for primary-nav -->
<style scope="primary-nav-1">
  .primary-nav-1 button.primary-nav:focus,
  .primary-nav-1 input.primary-nav:focus {
    outline: none;
  }

  .primary-nav-1 nav.primary-nav {
    position: relative;
    display: flex;
    height: 4rem;
    grid-template-areas: 'hamburger empty heart search user';
    -ms-grid-columns: 4rem minmax(1rem, 100%) 4rem 4rem 4rem;
    grid-template-columns: 4rem auto 4rem 4rem 4rem;
    -ms-grid-rows: 100%;
    grid-template-rows: 100%;
    background: #222;
    border-bottom: 1px solid #333;
  }

  .primary-nav-1 nav.hide-search.primary-nav {
    grid-template-areas: 'hamburger empty heart user';
    -ms-grid-columns: 4rem minmax(1rem, 100%) 4rem 4rem;
    grid-template-columns: 4rem auto 4rem 4rem;
  }

  .primary-nav-1 .right-side-section.primary-nav {
    display: flex;
    margin-left: auto;
    user-select: none;
  }

  .primary-nav-1 button.primary-nav {
    background: none;
    color: inherit;
    border: none;
    font: inherit;
    cursor: pointer;
  }

  .primary-nav-1 .branding.primary-nav {
    position: static;
    float: left;
    margin: 0 !important;
    padding: 0 5px 0 10px;
    -webkit-transform: translate(0, 0);
    -ms-transform: translate(0, 0);
    transform: translate(0, 0);
  }

  .primary-nav-1 slot.primary-nav,
  .primary-nav-1 .branding.primary-nav {
    display: flex;
    justify-content: left;
    align-items: center;
  }

  .primary-nav-1 media-menu.primary-nav {
    flex: 1;
    justify-self: stretch;
  }

  .primary-nav-1 .ia-logo.primary-nav {
    height: 3rem;
    width: 2.7rem;
    display: inline-block;
  }

  .primary-nav-1 .ia-wordmark.primary-nav {
    height: 3rem;
    width: 9.5rem;
  }

  .primary-nav-1 .ia-logo.primary-nav,
  .primary-nav-1 .ia-wordmark.primary-nav {
    margin-right: 5px;
  }

  .primary-nav-1 .hamburger.primary-nav {
    -ms-grid-row: 1;
    -ms-grid-column: 1;
    grid-area: hamburger;
    padding: 0;
  }

  .primary-nav-1 .hamburger.primary-nav svg.primary-nav {
    height: 4rem;
    width: 4rem;
    fill: #fff;
  }

  .primary-nav-1 .mobile-donate-link.primary-nav {
    display: inline-block;
  }

  .primary-nav-1 .mobile-donate-link.primary-nav svg.primary-nav {
    height: 4rem;
    width: 4rem;
  }

  .primary-nav-1 .mobile-donate-link.primary-nav .fill-color.primary-nav {
    fill: rgb(255, 0, 0);
  }

  .primary-nav-1 .sr-only.primary-nav {
    position: absolute;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    border: 0;
    overflow: hidden;
    white-space: nowrap;
    clip: rect(1px, 1px, 1px, 1px);
    -webkit-clip-path: inset(50%);
    clip-path: inset(50%);
    user-select: none;
  }

  .primary-nav-1 .search-trigger.primary-nav {
    padding: 0;
  }

  .primary-nav-1 .search-trigger.primary-nav svg.primary-nav {
    height: 4rem;
    width: 4rem;
  }

  .primary-nav-1 .search-trigger.primary-nav .fill-color.primary-nav {
    fill: #999;
  }

  .primary-nav-1 .search-activated.primary-nav {
    position: relative;
    z-index: 3;
  }

  .primary-nav-1 .upload.primary-nav {
    display: none;
  }

  .primary-nav-1 .upload.primary-nav span.primary-nav {
    display: none;
  }

  .primary-nav-1 .upload.primary-nav svg.primary-nav {
    height: 3rem;
    width: 3rem;
  }

  .primary-nav-1 .screen-name.primary-nav {
    display: none;
    font-size: 1.3rem;
    vertical-align: middle;
    text-transform: uppercase;
  }

  .primary-nav-1 .user-menu.primary-nav {
    color: #999;
    padding: 0.5rem;
    height: 100%;
  }

  .primary-nav-1 button.user-menu.primary-nav:hover,
  .primary-nav-1 button.user-menu.primary-nav:focus {
    color: #fff;
    outline: none;
  }

  .primary-nav-1 .user-menu.active.primary-nav {
    border-radius: 1rem 1rem 0 0;
    background: #333;
  }

  .primary-nav-1 .user-menu.primary-nav img.primary-nav {
    display: block;
    width: 3rem;
    height: 3rem;
  }

  .primary-nav-1 .link-home.primary-nav {
    text-decoration: none;
    display: inline-flex;
  }

  .primary-nav-1 a.link-home.primary-nav:focus,
  .primary-nav-1 a.link-home.primary-nav:focus-visible {
    outline-offset: 1px;
  }

  @media only screen and (min-width: 890px) and (max-device-width: 905px) {
    .primary-nav-1 .branding.second-logo.primary-nav {
      padding-right: 0;
    }

  }

  @media (min-width: 906px) {
    .primary-nav-1 .branding.second-logo.primary-nav {
      padding-right: 20px;
    }

  }

  @media (max-width: 889px) {
    .primary-nav-1 slot.primary-nav[name='opt-sec-logo'] {
      display: none;
    }

    .primary-nav-1 .right-side-section.primary-nav {
      display: initial;
    }

    .primary-nav-1 .right-side-section.primary-nav .user-info.primary-nav {
      float: right;
    }

  }

  @media (min-width: 890px) {
    .primary-nav-1 {
      ;
    }

    .primary-nav-1 nav.primary-nav {
      display: flex;
      z-index: 4;
      height: 5rem;
      padding-right: 1.5rem;
    }

    .primary-nav-1 slot.primary-nav[name='opt-sec-logo-mobile'] {
      display: none;
    }

    .primary-nav-1 .ia-logo.primary-nav,
    .primary-nav-1 .ia-wordmark.primary-nav {
      margin-right: 10px;
    }

    .primary-nav-1 .hamburger.primary-nav,
    .primary-nav-1 .search-trigger.primary-nav,
    .primary-nav-1 .mobile-donate-link.primary-nav {
      display: none;
    }

    .primary-nav-1 .user-info.primary-nav {
      display: block;
      float: right;
      vertical-align: middle;
      height: 100%;
    }

    .primary-nav-1 .user-info.primary-nav .user-menu.primary-nav img.primary-nav {
      height: 3rem;
      width: 3rem;
      margin-right: 0.5rem;
    }

    .primary-nav-1 .user-menu.primary-nav {
      padding: 1rem 0.5rem;
    }

    .primary-nav-1 .user-menu.active.primary-nav {
      background: transparent;
    }

    .primary-nav-1 .user-menu.primary-nav img.primary-nav {
      display: inline-block;
      vertical-align: middle;
      margin-right: 0.5rem;
    }

    .primary-nav-1 .upload.primary-nav {
      display: block;
      padding: 1rem 0.5rem;
      float: right;
      font-size: 1.4rem;
      text-transform: uppercase;
      text-decoration: none;
      color: #999;
    }

    .primary-nav-1 .upload.primary-nav:active,
    .primary-nav-1 .upload.primary-nav:focus,
    .primary-nav-1 .upload.primary-nav:hover {
      color: #fff;
    }

    .primary-nav-1 .upload.primary-nav:focus-visible {
      outline: none;
    }

    .primary-nav-1 .upload.primary-nav svg.primary-nav {
      vertical-align: middle;
      fill: #999;
    }

    .primary-nav-1 .upload.primary-nav:hover svg.primary-nav,
    .primary-nav-1 .upload.primary-nav:focus svg.primary-nav,
    .primary-nav-1 .upload.primary-nav:active svg.primary-nav {
      fill: #fff;
    }

    .primary-nav-1 nav-search.primary-nav {
      float: right;
      margin-left: 1rem;
    }

  }

  @media (min-width: 990px) {
    .primary-nav-1 .screen-name.primary-nav {
      display: inline-block;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      max-width: 165px;
    }

    .primary-nav-1 .upload.primary-nav span.primary-nav {
      display: inline;
    }

  }
</style><!-- Shady DOM styles for user-menu --><!-- Shady DOM styles for search-menu -->
<style scope="search-menu-1">
  .search-menu-1 .menu-wrapper.search-menu {
    position: relative;
  }

  .search-menu-1 button.search-menu:focus,
  .search-menu-1 input.search-menu:focus {
    outline-color: #428bca;
    outline-width: 0.16rem;
    outline-style: auto;
    outline-offset: 2px !important;
  }

  .search-menu-1 .search-menu-inner.search-menu {
    position: absolute;
    right: 0;
    left: 0;
    z-index: 4;
    padding: 0 4.5rem;
    font-size: 1.6rem;
    background-color: #333;
  }

  .search-menu-1 .tx-slide.search-menu {
    overflow: hidden;
    transition-property: top;
    transition-duration: 0.2s;
    transition-timing-function: ease;
  }

  .search-menu-1 .initial.search-menu,
  .search-menu-1 .closed.search-menu {
    top: -1500px;
  }

  .search-menu-1 .closed.search-menu {
    transition-duration: 0.2s;
  }

  .search-menu-1 label.search-menu,
  .search-menu-1 a.search-menu {
    padding: 1rem;
    display: block;
  }

  .search-menu-1 .advanced-search.search-menu {
    text-decoration: none;
    color: #428bca;
    line-height: normal;
    padding: 0.5rem;
    margin-top: 5px;
  }

  @media (min-width: 890px) {
    .search-menu-1 .search-menu-inner.search-menu {
      overflow: visible;
      right: 2rem;
      left: auto;
      z-index: 5;
      padding: 1rem 2rem;
      transition: opacity 0.2s ease-in-out;
      font-size: 1.4rem;
      color: #333;
      border-radius: 2px;
      background: #fff;
      box-shadow: 0 1px 2px 1px rgba(0, 0, 0, 0.15);
    }

    .search-menu-1 .search-menu-inner.search-menu:after {
      position: absolute;
      right: 7px;
      top: -7px;
      width: 12px;
      height: 7px;
      box-sizing: border-box;
      color: #fff;
      content: '';
      border-bottom: 7px solid currentColor;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
    }

    .search-menu-1 .initial.search-menu,
    .search-menu-1 .closed.search-menu {
      opacity: 0;
      transition-duration: 0.2s;
    }

    .search-menu-1 .open.search-menu {
      opacity: 1;
    }

    .search-menu-1 label.search-menu {
      padding: 0;
      font-weight: normal;
      margin: 0;
    }

    .search-menu-1 label.search-menu+label.search-menu {
      padding-top: 7px;
    }

    .search-menu-1 a.search-menu {
      padding: 1rem 0 0 0;
    }

  }
</style><!-- Shady DOM styles for ia-wayback-search --><!-- Shady DOM styles for wayback-search -->
<style scope="wayback-search-1">
  .wayback-search-1 {
    font: normal 1.2rem/1.5 'Helvetica Neue', Helvetica, Arial, sans-serif;
  }

  .wayback-search-1 form.wayback-search {
    max-width: 600px;
  }

  .wayback-search-1 p.wayback-search {
    margin-top: 0;
    font-weight: 200;
  }

  .wayback-search-1 a.wayback-search {
    font-weight: 500;
    text-decoration: none;
    color: #fff;
  }

  .wayback-search-1 fieldset.wayback-search {
    padding: 0.7rem 2rem;
    margin: 1.5rem 0;
    box-sizing: border-box;
    text-align: center;
    border: none;
    border-radius: 7px;
    background-color: #fcf5e6;
    box-shadow: 3px 3px 0 0 #c3ad97;
  }

  .wayback-search-1 label.wayback-search {
    display: none;
  }

  .wayback-search-1 img.wayback-search {
    width: 100%;
    max-width: 215px;
    max-height: 60px;
    margin-bottom: 1.3rem;
    vertical-align: middle;
  }

  .wayback-search-1 input.wayback-search {
    display: block;
    width: 100%;
    height: 3rem;
    padding: 0.5rem 1rem 0.5rem 2.5rem;
    font: normal 1.2rem/1.5 'Helvetica Neue', Helvetica, Arial, sans-serif;
    color: #858585;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 2rem;
    background: #eee;
  }

  .wayback-search-1 input.wayback-search:focus {
    border-color: #66afe9;
    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);
    outline: none;
  }

  .wayback-search-1 .search-field.wayback-search {
    position: relative;
    overflow: hidden;
  }

  .wayback-search-1 .search-field.wayback-search svg.wayback-search {
    position: absolute;
    top: 2px;
    left: 3px;
    width: 2.4rem;
    height: 2.4rem;
  }

  .wayback-search-1 .search-field.wayback-search .fill-color.wayback-search {
    fill: #999;
  }

  @media (min-width: 890px) {
    .wayback-search-1 form.wayback-search {
      margin: 0 auto;
    }

    .wayback-search-1 p.wayback-search {
      margin-bottom: 3rem;
      font-size: 1.6rem;
      text-align: center;
    }

    .wayback-search-1 img.wayback-search {
      margin: 0;
    }

    .wayback-search-1 fieldset.wayback-search {
      margin: 0 auto;
      font-size: 0;
    }

    .wayback-search-1 fieldset.wayback-search a.wayback-search,
    .wayback-search-1 .search-field.wayback-search {
      display: inline-block;
      width: 50%;
      vertical-align: middle;
    }

    .wayback-search-1 fieldset.wayback-search a.wayback-search {
      text-align: center;
    }

    .wayback-search-1 .search-field.wayback-search svg.wayback-search {
      width: 2.8rem;
      height: 2.8rem;
    }

    .wayback-search-1 .search-field.wayback-search .fill-color.wayback-search {
      fill: #333;
    }

  }

  .wayback-search-1 p.wayback-search {
    margin-bottom: 1rem;
    font-size: 1.6rem;
    text-align: center;
  }

  .wayback-search-1 fieldset.wayback-search {
    padding: .5rem;
    border-radius: 5px;
    box-shadow: none;
  }

  .wayback-search-1 input.wayback-search {
    padding-left: 3rem;
    margin-top: .3rem;
    font-size: 1.4rem;
    border-color: #bca38e;
    background: #fff;
  }

  .wayback-search-1 input.wayback-search::placeholder,
  .wayback-search-1 input.wayback-search::-webkit-input-placeholder {
    color: #8e8e8e;
  }

  .wayback-search-1 .search-field.wayback-search svg.wayback-search {
    top: 50%;
    transform: translateY(-50%);
  }

  @media (min-width: 890px) {

    .wayback-search-1 fieldset.wayback-search a.wayback-search,
    .wayback-search-1 .search-field.wayback-search {
      display: block;
      width: auto;
    }

    .wayback-search-1 fieldset.wayback-search a.wayback-search {
      margin: 0 1.5rem;
    }

  }
</style><!-- Shady DOM styles for save-page-form -->
<style scope="save-page-form-1">
  .save-page-form-1 div.save-page-form {
    display: grid;
    grid-template-columns: 1fr auto;
    grid-column-gap: .8rem;
    margin: 0;
    padding: 0;
    border: none;
  }

  .save-page-form-1 input.save-page-form[type="text"] {
    width: 100%;
    height: 3rem;
    box-sizing: border-box;
    border: 1px solid #999;
    border-radius: .5rem;
    color: #222;
    font-size: inherit;
  }

  .save-page-form-1 input.save-page-form[type="submit"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: .4rem .8rem;
    font: normal 1.3rem 'Helvetica Neue', Helvetica, Arial, sans-serif;
    text-transform: uppercase;
    color: #fff;
    border: none;
    border-radius: 16px;
    background: #222;
    cursor: pointer;
  }

  .save-page-form-1 .error.save-page-form {
    display: none;
    margin-top: .5rem;
    font-weight: bold;
    color: #ffcd27;
  }

  .save-page-form-1 .visible.save-page-form {
    display: block;
  }

  @media (min-width: 890px) {
    .save-page-form-1 h3.save-page-form {
      margin-top: 0;
      font: normal 100 1.6rem 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

  }
</style><!-- Shady DOM styles for wayback-slider -->
<style scope="wayback-slider-1">
  .wayback-slider-1 h4.wayback-slider {
    font-size: 1.6rem;
  }

  .wayback-slider-1 a.wayback-slider {
    text-decoration: none;
    color: #fff;
  }

  .wayback-slider-1 ul.wayback-slider {
    padding: 0;
    margin: 0;
    list-style: none;
  }

  .wayback-slider-1 li.wayback-slider+li.wayback-slider {
    padding-top: 1.5rem;
  }

  @media (min-width: 890px) {
    .wayback-slider-1 h4.wayback-slider {
      margin: 0 0 1rem 0;
      font-weight: 100;
    }

    .wayback-slider-1 ul.wayback-slider {
      font-size: 1.3rem;
    }

    .wayback-slider-1 li.wayback-slider {
      padding-bottom: .5rem;
    }

    .wayback-slider-1 li.wayback-slider+li.wayback-slider {
      padding-top: 0;
    }

    .wayback-slider-1 li.wayback-slider a.wayback-slider {
      display: block;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

  }

  @media (min-width: 890px) {
    .wayback-slider-1 {
      display: block;
      grid-column: 1 / 4;
      padding: 0 1.5rem;
    }

    .wayback-slider-1 h4.wayback-slider {
      margin-top: 0;
      font: normal 100 1.6rem 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    .wayback-slider-1 .grid.wayback-slider {
      display: grid;
      grid-template-columns: minmax(auto, 260px) 1fr minmax(auto, 260px);

      grid-column-gap: 2.5rem;
    }

    .wayback-slider-1 .link-lists.wayback-slider {
      display: grid;
      grid-template-columns: calc(50% - 1.25rem) calc(50% - 1.25rem);
      grid-column-gap: 2.5rem;
    }

  }
</style><!-- Shady DOM styles for more-slider -->
<style scope="more-slider-1">
  .more-slider-1 ul.more-slider {
    padding: 0;
    margin: -1rem 0 0 0;
    list-style: none;
  }

  .more-slider-1 a.more-slider {
    display: block;
    padding: 1rem 0;
    text-decoration: none;
    color: #fff;
  }
</style><!-- Shady DOM styles for media-subnav -->
<style scope="media-subnav-1">
  .media-subnav-1 h4.media-subnav {
    font-size: 1.6rem;
  }

  .media-subnav-1 a.media-subnav {
    text-decoration: none;
    color: #fff;
  }

  .media-subnav-1 ul.media-subnav {
    padding: 0;
    margin: 0;
    list-style: none;
  }

  .media-subnav-1 li.media-subnav+li.media-subnav {
    padding-top: 1.5rem;
  }

  @media (min-width: 890px) {
    .media-subnav-1 h4.media-subnav {
      margin: 0 0 1rem 0;
      font-weight: 100;
    }

    .media-subnav-1 ul.media-subnav {
      font-size: 1.3rem;
    }

    .media-subnav-1 li.media-subnav {
      padding-bottom: .5rem;
    }

    .media-subnav-1 li.media-subnav+li.media-subnav {
      padding-top: 0;
    }

    .media-subnav-1 li.media-subnav a.media-subnav {
      display: block;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

  }

  .media-subnav-1 img.media-subnav {
    display: block;
    width: 90px;
    height: 90px;
    margin: 0 auto 1rem auto;
    border-radius: 45px;
  }

  .media-subnav-1 h3.media-subnav {
    margin-top: 0;
    font-size: 1.8rem;
  }

  .media-subnav-1 .icon-links.media-subnav {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-pack: space-evenly;
    -ms-flex-pack: space-evenly;
    justify-content: space-evenly;
    text-align: center;
  }

  .media-subnav-1 .icon-links.media-subnav a.media-subnav {
    display: inline-block;
    width: 12rem;
    margin-bottom: 1.5rem;
    overflow: hidden;
    white-space: nowrap;
    text-align: center;
    text-overflow: ellipsis;
  }

  .media-subnav-1 .icon-links.media-subnav a.media-subnav+a.media-subnav {
    margin-left: 2rem;
  }

  .media-subnav-1 .featured.media-subnav h4.media-subnav {
    display: none;
  }

  @media (min-width: 890px) {
    .media-subnav-1 {
      display: -ms-grid;
      display: grid;
      -ms-grid-columns: 40% 20% 40%;
      grid-template-columns: 40% 20% 40%;
    }

    .media-subnav-1 .wayback-search.media-subnav {
      -ms-grid-column: 1;
      -ms-grid-column-span: 3;
      grid-column: 1 / 4;
    }

    .media-subnav-1 h3.media-subnav {
      display: none;
    }

    .media-subnav-1 .icon-links.media-subnav {
      -ms-grid-column: 1;
    }

    .media-subnav-1 .icon-links.media-subnav a.media-subnav {
      padding-top: 3.5rem;
      max-width: 16rem;
    }

    .media-subnav-1 .links.media-subnav {
      padding: 0 1.5rem;
    }

    .media-subnav-1 .featured.media-subnav {
      -ms-grid-column: 2;
    }

    .media-subnav-1 .featured.media-subnav h4.media-subnav {
      display: block;
    }

    .media-subnav-1 .top.media-subnav {
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav {
      display: -ms-grid;
      display: grid;
      -ms-grid-columns: 50% 3rem 50%;
      grid-template-columns: 50% 50%;
      -ms-grid-rows: (auto)[7];
      grid-template-rows: repeat(7, auto);
      grid-column-gap: 3rem;
      grid-auto-flow: column;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(1) {
      -ms-grid-row: 1;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(2) {
      -ms-grid-row: 2;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(3) {
      -ms-grid-row: 3;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(4) {
      -ms-grid-row: 4;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(5) {
      -ms-grid-row: 5;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(6) {
      -ms-grid-row: 6;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(7) {
      -ms-grid-row: 7;
      -ms-grid-column: 1;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(8) {
      -ms-grid-row: 1;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(9) {
      -ms-grid-row: 2;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(10) {
      -ms-grid-row: 3;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(11) {
      -ms-grid-row: 4;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(12) {
      -ms-grid-row: 5;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(13) {
      -ms-grid-row: 6;
      -ms-grid-column: 3;
    }

    .media-subnav-1 .top.media-subnav ul.media-subnav>*.media-subnav:nth-child(14) {
      -ms-grid-row: 7;
      -ms-grid-column: 3;
    }

  }
</style><!-- Shady DOM styles for media-slider -->
<style scope="media-slider-1">
  .media-slider-1 .media-slider-container.media-slider {
    position: relative;
  }

  .media-slider-1 .overflow-clip.media-slider {
    display: none;
    position: absolute;
    top: 3rem;
    right: 0;
    left: 0;
    height: 0;
    overflow: hidden;
    transition: height 0.2s ease;
  }

  .media-slider-1 .information-menu.media-slider {
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    padding: 0;
    height: 31.9rem;
    overflow-x: hidden;
    font-size: 1.4rem;
    background: #333;
  }

  .media-slider-1 .open.media-slider {
    display: block;
  }

  .media-slider-1 .hidden.media-slider {
    display: none;
  }

  .media-slider-1 .info-box.media-slider {
    padding: 1rem;
  }

  @media (max-width: 889px) {
    .media-slider-1 .overflow-clip.open.media-slider {
      display: block;
      height: 35.8rem;
      left: 4rem;
      top: 0;
    }

  }

  @media (min-width: 890px) {
    .media-slider-1 .overflow-clip.media-slider {
      display: block;
    }

    .media-slider-1 .information-menu.media-slider {
      left: 0;
      z-index: 3;
      height: auto;
      min-height: 21rem;
      background: #474747;
      transform: translate(0, -100%);
      transition: transform 0.2s ease;
    }

    .media-slider-1 .overflow-clip.open.media-slider {
      height: 22rem;
    }

    .media-slider-1 .information-menu.open.media-slider {
      transform: translate(0, 0);
    }

    .media-slider-1 .info-box.media-slider {
      max-width: 100rem;
      padding: 1.5rem 0;
      margin: 0 auto;
    }

  }
</style><!-- Shady DOM styles for desktop-subnav -->
<style scope="desktop-subnav-1">
  .desktop-subnav-1 ul.desktop-subnav {
    position: relative;
    z-index: 3;
    padding: .8rem 0;
    margin: 0;
    font-size: 1.2rem;
    text-transform: uppercase;
    text-align: center;
    background: #333;
  }

  .desktop-subnav-1 li.desktop-subnav {
    display: inline-block;
    padding: 0 15px;
  }

  .desktop-subnav-1 a.desktop-subnav {
    text-decoration: none;
    color: #aaa;
  }

  .desktop-subnav-1 a.desktop-subnav:hover,
  .desktop-subnav-1 a.desktop-subnav:active,
  .desktop-subnav-1 a.desktop-subnav:focus {
    color: #fff;
  }

  .desktop-subnav-1 .donate.desktop-subnav svg.desktop-subnav {
    width: 1.6rem;
    height: 1.6rem;
    vertical-align: top;
    fill: #f00;
  }
</style><!-- Shady DOM styles for signed-out-dropdown -->
<style scope="signed-out-dropdown-1">
  .signed-out-dropdown-1 .nav-container.signed-out-dropdown {
    position: relative;
  }

  .signed-out-dropdown-1 nav.signed-out-dropdown {
    position: absolute;
    right: 0;
    z-index: 4;
    overflow: hidden;
    font-size: 1.6rem;
    background-color: #333;
    transition-property: top;
    transition-duration: 0.2s;
    transition-timing-function: ease;
  }

  .signed-out-dropdown-1 .initial.signed-out-dropdown,
  .signed-out-dropdown-1 .closed.signed-out-dropdown {
    top: -1500px;
  }

  .signed-out-dropdown-1 .closed.signed-out-dropdown {
    transition-duration: 0.5s;
  }

  .signed-out-dropdown-1 .open.signed-out-dropdown {
    max-width: 100vw;
    overflow: auto;
  }

  .signed-out-dropdown-1 h3.signed-out-dropdown {
    padding: 0.6rem 2rem;
    margin: 0;
    font-size: inherit;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .signed-out-dropdown-1 ul.signed-out-dropdown {
    padding: 0.4rem 0 0.7rem 0;
    margin: 0;
    list-style: none;

    max-height: calc(100vh - 7.2rem + 1px);
    overflow: auto;
    box-sizing: border-box;
  }

  .signed-out-dropdown-1 .divider.signed-out-dropdown {
    margin: 0.5rem 0;
    border-bottom: 1px solid #666;
  }

  .signed-out-dropdown-1 a.signed-out-dropdown,
  .signed-out-dropdown-1 .info-item.signed-out-dropdown {
    display: block;
    color: #fff;
    text-decoration: none;
    padding: 1rem 2rem;
  }

  .signed-out-dropdown-1 .info-item.signed-out-dropdown {
    font-size: 0.8em;
    color: #999;
  }

  .signed-out-dropdown-1 .callout.signed-out-dropdown {
    position: absolute;
    margin-left: 10px;
    padding: 0 5px;
    border-radius: 2px;
    background: #fee257;
    color: #2c2c2c;
    font-size: 1.4rem;
    font-weight: bold;
  }

  .signed-out-dropdown-1 a.mobile-upload.signed-out-dropdown {
    display: flex;
    justify-content: left;
    align-items: center;
  }

  .signed-out-dropdown-1 a.mobile-upload.signed-out-dropdown svg.signed-out-dropdown {
    fill: #fff;
    margin-right: 1rem;
    height: 1.4rem;
    width: 1.4rem;
  }

  @media (min-width: 890px) {
    .signed-out-dropdown-1 nav.signed-out-dropdown {
      display: flex;
      overflow: visible;
      top: 0;
      left: auto;
      z-index: 5;
      transition: opacity 0.2s ease-in-out;
      font-size: 1.4rem;
      border-radius: 2px;
      background: #fff;
      box-shadow: 0 1px 2px 1px rgba(0, 0, 0, 0.15);
    }

    .signed-out-dropdown-1 nav.signed-out-dropdown:after {
      position: absolute;
      right: 7px;
      top: -7px;
      width: 12px;
      height: 7px;
      box-sizing: border-box;
      color: #fff;
      content: '';
      border-bottom: 7px solid currentColor;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
    }

    .signed-out-dropdown-1 h3.signed-out-dropdown {
      display: none;
    }

    .signed-out-dropdown-1 ul.signed-out-dropdown {
      max-height: calc(100vh - 8.5rem + 1px);
    }

    .signed-out-dropdown-1 .divider.signed-out-dropdown {
      border-bottom-color: #666;
    }

    .signed-out-dropdown-1 a.signed-out-dropdown {
      padding: 0.5rem 2rem;
      color: #333;
      transition: background 0.1s ease-out, color 0.1s ease-out;
    }

    .signed-out-dropdown-1 .info-item.signed-out-dropdown {
      padding: 0.5rem 2rem;
      font-size: 0.8em;
    }

    .signed-out-dropdown-1 a.signed-out-dropdown:hover,
    .signed-out-dropdown-1 a.signed-out-dropdown:active,
    .signed-out-dropdown-1 a.signed-out-dropdown:focus {
      color: #fff;
      background: #428bca;
      outline: none;
    }

    .signed-out-dropdown-1 .initial.signed-out-dropdown,
    .signed-out-dropdown-1 .closed.signed-out-dropdown {
      opacity: 0;
      transition-duration: 0.2s;
    }

    .signed-out-dropdown-1 .open.signed-out-dropdown {
      opacity: 1;
      overflow: visible;
    }

    .signed-out-dropdown-1 a.mobile-upload.signed-out-dropdown {
      display: none;
    }

  }

  @media (min-width: 890px) {

    .signed-out-dropdown-1 .initial.signed-out-dropdown,
    .signed-out-dropdown-1 .closed.signed-out-dropdown,
    .signed-out-dropdown-1 .open.signed-out-dropdown {
      right: 33.5rem;
    }

    .signed-out-dropdown-1 .search-hidden.initial.signed-out-dropdown,
    .signed-out-dropdown-1 .search-hidden.closed.signed-out-dropdown,
    .signed-out-dropdown-1 .search-hidden.open.signed-out-dropdown {
      right: 18.5rem;
    }

  }

  @media (min-width: 990px) {

    .signed-out-dropdown-1 .initial.signed-out-dropdown,
    .signed-out-dropdown-1 .closed.signed-out-dropdown,
    .signed-out-dropdown-1 .open.signed-out-dropdown {
      right: 40rem;
    }

    .signed-out-dropdown-1 .search-hidden.initial.signed-out-dropdown,
    .signed-out-dropdown-1 .search-hidden.closed.signed-out-dropdown,
    .signed-out-dropdown-1 .search-hidden.open.signed-out-dropdown {
      right: 26rem;
    }

  }
</style><!-- Shady DOM styles for ia-topnav -->
<style scope="ia-topnav-1">
  .ia-topnav-1 {
    ;

    color: #fff;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  }

  .ia-topnav-1 primary-nav.ia-topnav:focus {
    outline: none !important;
  }

  .ia-topnav-1 #close-layer.ia-topnav {
    display: none;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 3;
  }

  .ia-topnav-1 #close-layer.visible.ia-topnav {
    display: block;
  }

  .ia-topnav-1 .topnav.ia-topnav {
    position: relative;
    z-index: 4;
  }

  @media (max-width: 889px) {
    .ia-topnav-1 desktop-subnav.ia-topnav {
      display: none;
    }

  }
</style>
<style>
  body {
    transition: opacity ease-in 0.2s;
  }

  body[unresolved] {
    opacity: 0;
    display: block;
    overflow: hidden;
    position: relative;
  }
</style>








<ia-topnav locallinks="true" waybackpagesarchived="1 trillion" class="x-scope ia-topnav-1"><!---->
  <div class="topnav style-scope ia-topnav">
    <primary-nav class="style-scope ia-topnav x-scope primary-nav-1"><!---->
      <nav class="style-scope primary-nav">
        <button class="hamburger style-scope primary-nav" title="Open main menu" data-event-click-tracking="TopNav|NavHamburger">
          <icon-hamburger class="style-scope primary-nav x-scope icon-hamburger-1"><!---->
            <svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="hamburgerTitleID hamburgerDescID" class="style-scope icon-hamburger">
              <title id="hamburgerTitleID" class="style-scope icon-hamburger">Hamburger icon</title>
              <desc id="hamburgerDescID" class="style-scope icon-hamburger">An icon used to represent a menu that can be
                toggled by interacting with this icon.</desc>
              <path d="m30.5 26.5c.8284271 0 1.5.6715729 1.5 1.5s-.6715729 1.5-1.5 1.5h-21c-.82842712 0-1.5-.6715729-1.5-1.5s.67157288-1.5 1.5-1.5zm0-8c.8284271 0 1.5.6715729 1.5 1.5s-.6715729 1.5-1.5 1.5h-21c-.82842712 0-1.5-.6715729-1.5-1.5s.67157288-1.5 1.5-1.5zm0-8c.8284271 0 1.5.6715729 1.5 1.5s-.6715729 1.5-1.5 1.5h-21c-.82842712 0-1.5-.6715729-1.5-1.5s.67157288-1.5 1.5-1.5z" fill="#999" fill-rule="evenodd" class="style-scope icon-hamburger"></path>
              </svg>
              </icon-hamburger>
        </button>

        <div class="branding  style-scope primary-nav">
          <a title="Go home" class="link-home style-scope primary-nav" href="https://archive.org/" data-event-click-tracking="TopNav|NavHome"><!--?lit$49386103$-->
            <svg class="ia-logo style-scope primary-nav" viewBox="0 0 27 30" xmlns="http://www.w3.org/2000/svg" aria-labelledby="logoTitleID logoDescID">
              <title id="logoTitleID" class="style-scope primary-nav">Internet Archive logo</title>
              <desc id="logoDescID" class="style-scope primary-nav">A line drawing of the Internet Archive headquarters
                building fa√ßade.</desc>
              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" class="style-scope primary-nav">
                <mask id="mask-2" fill="white" class="style-scope primary-nav">
                  <path d="M26.6666667,28.6046512 L26.6666667,30 L0,30 L0.000283687943,28.6046512 L26.6666667,28.6046512 Z M25.6140351,26.5116279 L25.6140351,28.255814 L1.05263158,28.255814 L1.05263158,26.5116279 L25.6140351,26.5116279 Z M3.62469203,7.6744186 L3.91746909,7.82153285 L4.0639977,10.1739544 L4.21052632,13.9963932 L4.21052632,17.6725617 L4.0639977,22.255044 L4.03962296,25.3421929 L3.62469203,25.4651163 L2.16024641,25.4651163 L1.72094074,25.3421929 L1.55031755,22.255044 L1.40350877,17.6970339 L1.40350877,14.0211467 L1.55031755,10.1739544 L1.68423854,7.80887484 L1.98962322,7.6744186 L3.62469203,7.6744186 Z M24.6774869,7.6744186 L24.9706026,7.82153285 L25.1168803,10.1739544 L25.2631579,13.9963932 L25.2631579,17.6725617 L25.1168803,22.255044 L25.0927809,25.3421929 L24.6774869,25.4651163 L23.2130291,25.4651163 L22.7736357,25.3421929 L22.602418,22.255044 L22.4561404,17.6970339 L22.4561404,14.0211467 L22.602418,10.1739544 L22.7369262,7.80887484 L23.0420916,7.6744186 L24.6774869,7.6744186 Z M9.94042303,7.6744186 L10.2332293,7.82153285 L10.3797725,10.1739544 L10.5263158,13.9963932 L10.5263158,17.6725617 L10.3797725,22.255044 L10.3556756,25.3421929 L9.94042303,25.4651163 L8.47583122,25.4651163 L8.0362015,25.3421929 L7.86556129,22.255044 L7.71929825,17.6970339 L7.71929825,14.0211467 L7.86556129,10.1739544 L8.00005604,7.80887484 L8.30491081,7.6744186 L9.94042303,7.6744186 Z M18.0105985,7.6744186 L18.3034047,7.82153285 L18.449948,10.1739544 L18.5964912,13.9963932 L18.5964912,17.6725617 L18.449948,22.255044 L18.425851,25.3421929 L18.0105985,25.4651163 L16.5460067,25.4651163 L16.1066571,25.3421929 L15.9357367,22.255044 L15.7894737,17.6970339 L15.7894737,14.0211467 L15.9357367,10.1739544 L16.0702315,7.80887484 L16.3753664,7.6744186 L18.0105985,7.6744186 Z M25.6140351,4.53488372 L25.6140351,6.97674419 L1.05263158,6.97674419 L1.05263158,4.53488372 L25.6140351,4.53488372 Z M13.0806755,0 L25.9649123,2.93331338 L25.4484139,3.8372093 L0.771925248,3.8372093 L0,3.1041615 L13.0806755,0 Z" id="path-1" class="style-scope primary-nav"></path>
                  </mask>
                  <use fill="#FFFFFF" xlink:href="#path-1" class="style-scope primary-nav"></use>
                  <g mask="url(#mask-2)" fill="#FFFFFF" class="style-scope primary-nav">
                  <path d="M0,0 L26.6666667,0 L26.6666667,30 L0,30 L0,0 Z" id="swatch" class="style-scope primary-nav">
                  </path>
                  </g>
                  </g>
                  </svg>
                  <!--?lit$49386103$-->
            <svg class="ia-wordmark stacked style-scope primary-nav" viewBox="0 0 95 30" xmlns="http://www.w3.org/2000/svg">
              <g fill="#fff" fill-rule="evenodd" class="style-scope primary-nav">
                <g transform="translate(0 17)" class="style-scope primary-nav">
                  <path d="m3.07645967 2.60391777c.09263226-.31901841.26275495-.97477846.26275495-1.10630359 0-.74950669-.57227138-.76816274-1.19041353-.88009902v-.41183224h2.90678232l3.77209227 12.60682378h-1.60725868l-1.16012991-3.8963154h-3.94266032l-1.15968456 3.8963154h-.95794221zm-.69607795 5.4317081h3.41670507l-1.76223957-5.469953z" class="style-scope primary-nav"></path>
                  <path d="m13.2661876 2.75363255c0-1.85487748-.0316196-1.85487748-1.469201-2.13611739v-.41183224h3.8032666c1.1601299 0 4.3599508 0 4.3599508 3.35342446 0 2.13518459-1.143652 2.84737918-2.3652399 3.0903742l2.8448791 6.16302512h-1.7773814l-2.7366596-5.82581707h-.9588329v5.82581707h-1.7007817zm1.7007817 3.35295806h.8817878c1.0042583 0 2.411556-.33674165 2.411556-2.43508055 0-2.0237147-.9588329-2.58572812-2.2579112-2.58572812-1.0354326 0-1.0354326.33720805-1.0354326 1.68650665z" class="style-scope primary-nav"></path>
                  <path d="m30.9386422 12.2878054c-.5250645.2817063-1.3761234.7121946-2.9682403.7121946-3.3552471 0-4.5612478-2.4537366-4.5612478-6.66860403 0-3.4089262.86531-6.18214759 4.3136347-6.18214759 1.3761234 0 2.3812724.28077351 3.0920468.56201342l.0930776 3.12908549h-.4484648c-.0619033-.95612241-.9125167-2.79187744-2.5821241-2.79187744-2.2726076 0-2.6440273 2.94065941-2.6440273 5.28292612 0 2.95931547.8510588 5.61966783 2.9994146 5.61966783 1.4692009 0 2.2267368-.5620135 2.7059306-.9551897z" class="style-scope primary-nav"></path>
                  <path d="m35.4546446 2.67900836c0-1.48129014-.0926322-1.64966096-1.5466914-1.83622143v-.41276504l3.2470277-.43002189v5.80669465h4.2049699v-5.60101173h1.7007816v12.60682378h-1.7007816v-6.12571303h-4.2049699v6.12571303h-1.7003363z" class="style-scope primary-nav"></path>
                  <path d="m46.0300434 12.3447063c1.0973359 0 1.3137748-.2807735 1.3137748-1.7420083v-8.05568117c0-1.46123489-.2164389-1.741542-1.3137748-1.741542v-.46919958h4.3287765v.46919958c-1.0826395 0-1.3137748.28030711-1.3137748 1.741542v8.05568117c0 1.4612348.2311353 1.7420083 1.3137748 1.7420083v.4678004h-4.3287765z" class="style-scope primary-nav"></path>
                  <path d="m55.1990352 2.60391777c-.494781-1.7051627-.6341747-1.7051627-1.8709043-1.98640261v-.41183224h2.9994145l3.0301436 10.26548988h.0307289l2.9535438-10.26548988h1.0042584l-3.771647 12.60682378h-1.344949z" class="style-scope primary-nav"></path>
                  <path d="m67.7842867 2.75363255c0-1.85487748-.0463161-1.85487748-1.4687557-2.13611739v-.41183224h7.4061269l.0463161 2.77228859h-.433323c0-1.49854698-.6488711-1.89218957-1.6696073-1.89218957h-1.2060007c-.7726777 0-.9735293.07462419-.9735293.97431206v3.7279446h1.8709043c1.0657162 0 1.174381-.82366447 1.2674586-1.44164603h.4324323v3.93316112h-.4324323c0-1.01162415-.3402454-1.61141607-1.2674586-1.61141607h-1.8709043v4.17755538c0 1.0489362.2008516 1.0867147.9735293 1.0867147h1.7168141c.8804518 0 1.2977423-.3749865 1.3908199-1.835755h.433323l-.0472068 2.715854h-6.1685065z" class="style-scope primary-nav"></path>
                  </g>
                <path d="m1.55575146 9.89647882v-7.6678574c0-1.39053729-.25677019-1.65867172-1.55575146-1.65867172v-.44528687h5.12561364v.44528687c-1.28118091 0-1.55575146.26813443-1.55575146 1.65867172v7.6678574c0 1.39097468.27457055 1.65735948 1.55575146 1.65735948v.4461617h-5.12561364v-.4461617c1.29898127 0 1.55575146-.2663848 1.55575146-1.65735948z" class="style-scope primary-nav"></path>
                <path d="m9.92299051 2.28198586c0-1.65823431-.25588017-1.58649851-1.83032201-1.88962601v-.39235985h3.8626781l5.7664266 9.70008019h.0364907v-9.70008019h1.1534634v12h-1.7577856l-6.0405521-10.14492965h-.0369358v10.14492965h-1.15346329z" class="style-scope primary-nav"></path>
                <path d="m25.631543.83808413h-1.2633805c-1.4458343 0-1.8668128.44572428-1.977175 1.74834147h-.5122054l.0729815-2.5864256h9.3727795l.0734265 2.63935263h-.5126504c0-1.37304075-.5860768-1.8012685-1.9954203-1.8012685h-1.2442452v11.16191587h-2.0141107z" class="style-scope primary-nav"></path>
                <path d="m36.1050097 2.42502005c0-1.7654006-.0556262-1.7654006-1.7399852-2.0326602v-.39235985h8.7684573l.0551811 2.63935263h-.5126504c0-1.42684261-.7685305-1.8012685-1.9762849-1.8012685h-1.4284789c-.9153835 0-1.1534633.0717358-1.1534633.92775388v3.54829773h2.2152547c1.2629356 0 1.3906532-.7851571 1.5010154-1.37391558h.5130954v3.74513378h-.5130954c0-.96274696-.4022881-1.53313407-1.5010154-1.53313407h-2.2152547v3.97608803c0 .9986149.2380798 1.033608 1.1534633 1.033608h2.0319111c1.0439911 0 1.5375061-.356492 1.6469783-1.74702926h.5135404l-.0551812 2.58511336h-7.3034876z" class="style-scope primary-nav"></path>
                <path d="m48.1689385 2.42502005c0-1.7654006-.0364908-1.7654006-1.7382052-2.0326602v-.39235985h4.5026011c1.3732977 0 5.1621043 0 5.1621043 3.19180579 0 2.03309761-1.3537173 2.71065102-2.8004416 2.94248013l3.3682731 5.86571408h-2.1053376l-3.2396655-5.54552745h-1.1352179v5.54552745h-2.0141107zm2.0141107 3.19136837h1.0439911c1.189064 0 2.8556227-.32018663 2.8556227-2.31697893 0-1.92680615-1.1352179-2.46132536-2.673169-2.46132536-1.2264448 0-1.2264448.32062404-1.2264448 1.6057447z" class="style-scope primary-nav"></path>
                <path d="m61.4610921 2.28198586c0-1.65823431-.2567702-1.58649851-1.830767-1.88962601v-.39235985h3.8622331l5.7659816 9.70008019h.0369357v-9.70008019h1.1534633v12h-1.7568955l-6.0414421-10.14492965h-.0364908v10.14492965h-1.1530183z" class="style-scope primary-nav"></path>
                <path d="m75.1550889 2.42502005c0-1.7654006-.0547361-1.7654006-1.7390952-2.0326602v-.39235985h8.7684573l.0551811 2.63935263h-.5126504c0-1.42684261-.7694205-1.8012685-1.9771749-1.8012685h-1.4280339c-.9149385 0-1.1530183.0717358-1.1530183.92775388v3.54829773h2.2148098c1.2633805 0 1.3906531-.7851571 1.5010153-1.37391558h.5130954v3.74513378h-.5130954c0-.96274696-.4022881-1.53313407-1.5010153-1.53313407h-2.2148098v3.97608803c0 .9986149.2380798 1.033608 1.1530183 1.033608h2.0319111c1.0439911 0 1.5379511-.356492 1.6478683-1.74702926h.5126504l-.0551811 2.58511336h-7.3039327z" class="style-scope primary-nav"></path>
                <path d="m89.2335734.83808413h-1.2624905c-1.4462793 0-1.8672578.44572428-1.97762 1.74834147h-.5122054l.0734265-2.5864256h9.3718895l.0734265 2.63935263h-.5122054c0-1.37304075-.5856318-1.8012685-1.9958653-1.8012685h-1.2446902v11.16191587h-2.0136657z" class="style-scope primary-nav"></path>
                </g>
                </svg>

          </a>
          <!--?lit$49386103$-->
        </div>
        <media-menu class="style-scope primary-nav x-scope media-menu-1"><!---->
          <div class="media-menu-container closed style-scope media-menu">
            <div class="overflow-clip style-scope media-menu">
              <nav class="media-menu-inner style-scope media-menu" aria-expanded="false">
                <div class="menu-group style-scope media-menu">
                  <!--?lit$49386103$--><!---->
                  <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="web"><!---->
                    <a class="menu-item web  style-scope media-button" href="https://web.archive.org/" data-event-click-tracking="TopNav|NavMenuWeb" title="Expand web menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="webTitleID webDescID" class="style-scope media-button">
                          <title id="webTitleID" class="style-scope media-button">Web icon</title>
                          <desc id="webDescID" class="style-scope media-button">An illustration of a computer
                            application window</desc>
                          <path class="fill-color style-scope media-button" d="m8 28.7585405v-8.1608108-9.3577297h24v9.3577297 8.1608108zm14.2702703-15.8863783h-12.43243246v2.6114594h12.43243246zm7.7837838 14.0365946v-7.0727027-1.8497838h-20.21621626v1.8497838 7.0727027zm-3.7837838-14.0365946h-2.7027027v2.6114594h2.7027027zm4 0h-2.7027027v2.6114594h2.7027027z" fill-rule="evenodd"></path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Wayback Machine</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="texts"><!---->
                    <a class="menu-item texts  style-scope media-button" href="https://archive.org/details/texts" data-event-click-tracking="TopNav|NavMenuTexts" title="Expand texts menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="textsTitleID textsDescID" class="style-scope media-button">
                          <title id="textsTitleID" class="style-scope media-button">Texts icon</title>
                          <desc id="textsDescID" class="style-scope media-button">An illustration of an open book.
                          </desc>
                          <path class="fill-color style-scope media-button" d="m10.3323235 11.0007023h6.9060825c.8851083 0 1.5847122.3064258 2.0988114.9192774v14.4324451h-.6460032c-.1435563-.120323-.3528315-.2434552-.6278257-.3693964-.2749942-.1259413-.5201585-.2191097-.7354929-.2795053l-.3048241-.1081503h-5.7042647c-.3108832 0-.5621067-.0601615-.7536705-.1804846-.0717781-.0599274-.1256117-.1439663-.1615008-.2521166-.0358891-.1081502-.0598928-.2043619-.0720112-.2886348v-13.8741368zm19.1752505 0v13.603761c-.0717781.3361555-.2211606.5943584-.4481473.7746089-.0717781.0599274-.1733862.1079162-.304824.1439663-.1314379.0360501-.2451643.0601615-.3411793.0723343h-5.5965975c-.9568865.2640552-1.5068748.5164059-1.649965.757052h-.6634817v-14.4324451c.5140992-.6128516 1.2076439-.9192774 2.0806339-.9192774h6.92426zm1.3814961.6489017-.1796783 15.2976474c-.0955489 0-1.0342578.0119386-2.8161268.035816-1.7818691.0238773-3.3006293.0898911-4.5562806.1980414-1.2556514.1081503-1.9613144.2884008-2.1169891.5407514-.0955488.1924233-.5439291.273419-1.345141.2429871-.8012118-.0304319-1.3155441-.1776755-1.5429969-.4417308-.334654-.3843783-3.4558378-.5765674-9.36355164-.5765674v-15.3875385l-.96830576.3960828v16.2702977c6.4096947-.2041278 9.7760429-.0840388 10.0990445.3602669.2391051.276228.9864833.414342 2.2421347.414342.1915638 0 .4187835-.0210682.6816593-.0632047s.4810068-.0870821.6543929-.1348367c.1733862-.0477547.2719646-.0838048.2957353-.1081503.0838965-.1563732.9599161-.2675666 2.6280587-.3335805 1.6681426-.0660138 3.3213703-.0931684 4.9596831-.0814638l2.4392915.0182591v-16.2344816z">
                          </path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Texts</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="video"><!---->
                    <a class="menu-item video  style-scope media-button" href="https://archive.org/details/movies" data-event-click-tracking="TopNav|NavMenuVideo" title="Expand video menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="videoTitleID videoDescID" class="style-scope media-button">
                          <title id="videoTitleID" class="style-scope media-button">Video icon</title>
                          <desc id="videoDescID" class="style-scope media-button">An illustration of two cells of a film
                            strip.</desc>
                          <path class="fill-color style-scope media-button" d="m31.0117647 12.0677966c0 .4067797-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711864-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067797-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711864-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711865-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.3898305c0 .4067797-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711864-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711865-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.2711865-.7058823-.6779661v-.6779661c0-.4067797.2823529-.6779661.7058823-.6779661h1.2705883c.4235294 0 .7058823.2711864.7058823.6779661zm-4.0941176-10.440678c0 .5423729-.4235295.9491525-.9882353.9491525h-11.5764706c-.5647059 0-.9882353-.4067796-.9882353-.9491525v-6.9152542c0-.5423729.4235294-.9491526.9882353-.9491526h11.5764706c.5647058 0 .9882353.4067797.9882353.9491526zm-.1411765 11.2542373c0 .5423729-.4235294.9491525-.9882353.9491525h-11.5764706c-.5647059 0-.9882353-.4067796-.9882353-.9491525v-6.9152542c0-.5423729.4235294-.9491526.9882353-.9491526h11.5764706c.5647059 0 .9882353.4067797.9882353.9491526zm-14.9647059-17.220339c0 .4067797-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711864-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067797-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711864-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711865-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.3898305c0 .4067797-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711864-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711865-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm0 3.2542373c0 .4067796-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.2711865-.70588236-.6779661v-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661zm20.0470588-20.4745763h-.8470588v.27118644.6779661c0 .40677966-.2823529.6779661-.7058823.6779661h-1.2705883c-.4235294 0-.7058823-.27118644-.7058823-.6779661v-.6779661-.27118644h-16.5176471v.27118644.6779661c0 .40677966-.2823529.6779661-.7058823.6779661h-1.27058828c-.42352941 0-.70588236-.27118644-.70588236-.6779661v-.6779661-.27118644h-1.12941176v24h1.12941176v-.2711864-.6779661c0-.4067797.28235295-.6779661.70588236-.6779661h1.27058828c.4235294 0 .7058823.2711864.7058823.6779661v.6779661.2711864h16.6588235v-.2711864-.6779661c0-.4067797.282353-.6779661.7058824-.6779661h1.2705882c.4235294 0 .7058824.2711864.7058824.6779661v.6779661.2711864h.8470588v-24z" fill-rule="evenodd"></path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Video</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="audio"><!---->
                    <a class="menu-item audio  style-scope media-button" href="https://archive.org/details/audio" data-event-click-tracking="TopNav|NavMenuAudio" title="Expand audio menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg width="40px" height="40px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" aria-labelledby="audioTitleID audioDescID" class="style-scope media-button">
                          <title id="audioTitleID" class="style-scope media-button">Audio icon</title>
                          <desc id="audioDescID" class="style-scope media-button">An illustration of an audio speaker.
                          </desc>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" class="style-scope media-button">
                            <g transform="translate(10, 8)" class="fill-color style-scope media-button">
                              <path d="M19.4264564,11.8585048 L19.4264564,20.7200433 C19.4264564,22.3657576 18.8838179,23.2519114 16.8489237,23.2519114 C12.2364969,23.125318 7.75972977,23.125318 3.14730298,23.2519114 C1.24806842,23.2519114 0.569770368,22.492351 0.569770368,20.7200433 L0.569770368,2.74377955 C0.569770368,1.09806526 1.11240881,0.211911416 3.14730298,0.211911416 C7.75972977,0.338504822 12.2364969,0.338504822 16.8489237,0.211911416 C18.7481583,0.211911416 19.4264564,0.971471855 19.4264564,2.74377955 C19.2907967,5.78202131 19.4264564,8.82026306 19.4264564,11.8585048 L19.4264564,11.8585048 Z M10.0659432,2.74377955 C8.16670861,2.74377955 6.67445288,4.13630702 6.67445288,5.90861471 C6.67445288,7.6809224 8.16670861,9.07344988 10.0659432,9.07344988 C11.9651777,9.07344988 13.4574335,7.6809224 13.4574335,5.90861471 C13.4574335,4.13630702 11.8295181,2.74377955 10.0659432,2.74377955 L10.0659432,2.74377955 Z M10.0659432,11.4787246 C7.21709133,11.4787246 5.04653754,13.6308125 5.04653754,16.1626806 C5.04653754,18.8211422 7.35275094,20.8466367 10.0659432,20.8466367 C12.914795,20.8466367 15.0853488,18.6945488 15.0853488,16.1626806 C15.0853488,13.6308125 12.7791354,11.4787246 10.0659432,11.4787246 L10.0659432,11.4787246 Z" class="style-scope media-button"></path>
                              <ellipse cx="10.2016028" cy="16.5690777" rx="1.35659611" ry="1.34075134" class="style-scope media-button"></ellipse>
                              </g>
                              </g>
                              </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Audio</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="software"><!---->
                    <a class="menu-item software  style-scope media-button" href="https://archive.org/details/software" data-event-click-tracking="TopNav|NavMenuSoftware" title="Expand software menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="softwareTitleID softwareDescID" class="style-scope media-button">
                          <title id="softwareTitleID" class="style-scope media-button">Software icon</title>
                          <desc id="softwareDescID" class="style-scope media-button">An illustration of a 3.5" floppy
                            disk.</desc>
                          <path class="fill-color style-scope media-button" d="m32 30.6900373v-21.44521088c0-.82988428-.4156786-1.24482642-1.2470357-1.24482642h-21.50592858c-.83135715 0-1.24703572.4221795-1.24703572 1.26653851v21.44521089c0 .8588337.41567857 1.2882506 1.24703572 1.2882506h21.48327168c.8458575 0 1.2687863-.4366542 1.2687863-1.3099627zm-5.9950155-20.4410268v6.114667c0 .6694561-.3428744 1.0041841-1.0286232 1.0041841h-10.1294464c-.2622159 0-.4773054-.0802141-.6452685-.2406423s-.2519447-.3642806-.2519447-.6115572v-6.1363791l.0217506-.1311772h12.0326259zm-4.9437353.8295827v5.0010178h3.0405558v-5.0010178zm-9.7134658 18.8035735v-7.753025c0-.5241057.1604108-.9025595.4812325-1.1353613.1897138-.1453504.4011782-.2180256.6343932-.2180256h14.7451099c.3208217 0 .5905898.1091636.8093044.3274907s.3280719.5023936.3280719.8521995v7.8181612l-.0217506.1094652h-16.9772676z">
                          </path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Software</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="images"><!---->
                    <a class="menu-item images  style-scope media-button" href="https://archive.org/details/image" data-event-click-tracking="TopNav|NavMenuImages" title="Expand images menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="imagesTitleID imagesDescID" class="style-scope media-button">
                          <title id="imagesTitleID" class="style-scope media-button">Images icon</title>
                          <desc id="imagesDescID" class="style-scope media-button">An illustration of two photographs.
                          </desc>
                          <path class="fill-color style-scope media-button" d="m20.8219178 15.3769871c0 1.1136708-.8767123 1.8932404-1.8630137 1.8932404s-1.9726027-.8909367-1.9726027-1.8932404c0-1.0023038.8767123-1.8932404 1.9726027-1.8932404.9863014 0 1.8630137.8909366 1.8630137 1.8932404zm-5.9178082-3.7864808h15.4520548v6.0138225l-1.9726028-3.3410125-2.6301369 6.3479237-2.1917809-2.67281-6.1369863 5.1228859h-2.5205479zm-1.7534247-1.6705063v14.9231892h18.8493151v-14.9231892zm-2.9589041 7.2388604c.2191781 0 1.9726028-.3341012 1.9726028-.3341012v-2.0046075l-4.1643836.5568354c.43835616 4.7887846.87671233 9.9116704 1.31506849 14.700455 6.02739731-.5568354 13.26027401-1.5591391 19.39726031-2.1159746-.1095891-.5568354-.1095891-2.0046075-.2191781-2.67281-.4383562.1113671-1.4246575 0-1.8630137.1113671v.8909367c-5.1506849.4454683-10.3013699 1.1136708-15.4520548 1.6705062.109589-.111367-.5479452-7.0161262-.9863014-10.8026071z" fill-rule="evenodd"></path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Images</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="donate"><!---->
                    <a class="menu-item donate  style-scope media-button" href="https://archive.org/donate/" data-event-click-tracking="TopNav|NavMenuDonate" title="Expand donate menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="donateTitleID donateDescID" class="style-scope media-button">
                          <title id="donateTitleID" class="style-scope media-button">Donate icon</title>
                          <desc id="donateDescID" class="style-scope media-button">An illustration of a heart shape
                          </desc>
                          <path class="fill-color style-scope media-button" d="m30.0120362 11.0857287c-1.2990268-1.12627221-2.8599641-1.65258786-4.682812-1.57894699-.8253588.02475323-1.7674318.3849128-2.8262192 1.08047869-1.0587873.6955659-1.89622 1.5724492-2.512298 2.63065-.591311-1.0588196-1.4194561-1.9357029-2.4844351-2.63065-1.0649791-.69494706-2.0039563-1.05510663-2.8169316-1.08047869-1.2067699-.04950647-2.318187.17203498-3.3342513.66462439-1.0160643.4925893-1.82594378 1.2002224-2.42963831 2.1228992-.60369453.9226769-.91173353 1.9629315-.92411701 3.1207641-.03715043 1.9202322.70183359 3.7665141 2.21695202 5.5388457 1.2067699 1.4035084 2.912594 3.1606786 5.1174721 5.2715107 2.2048782 2.1108321 3.7565279 3.5356901 4.6549492 4.2745742.8253588-.6646243 2.355647-2.0647292 4.5908647-4.2003145s3.9747867-3.9171994 5.218707-5.3448422c1.502735-1.7723316 2.2355273-3.6186135 2.1983769-5.5388457-.0256957-1.7608832-.6875926-3.2039968-1.9866194-4.3302689z">
                          </path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->Donate</span>

                    </a>
                    </media-button>
                    <!----><!---->
                    <media-button class="style-scope media-menu x-scope media-button-1" data-mediatype="more"><!---->
                    <a class="menu-item more  style-scope media-button" href="https://archive.org/about/" data-event-click-tracking="TopNav|NavMenuMore" title="Expand more menu">
                      <!--?lit$49386103$-->
                      <span class="icon  style-scope media-button">
                        <!--?lit$49386103$-->
                        <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="ellipsesTitleID ellipsesDescID" class="style-scope media-button">
                          <title id="ellipsesTitleID" class="style-scope media-button">Ellipses icon</title>
                          <desc id="ellipsesDescID" class="style-scope media-button">An illustration of text ellipses.
                          </desc>
                          <path class="fill-color style-scope media-button" d="m10.5 17.5c1.3807119 0 2.5 1.1192881 2.5 2.5s-1.1192881 2.5-2.5 2.5c-1.38071187 0-2.5-1.1192881-2.5-2.5s1.11928813-2.5 2.5-2.5zm9.5 0c1.3807119 0 2.5 1.1192881 2.5 2.5s-1.1192881 2.5-2.5 2.5-2.5-1.1192881-2.5-2.5 1.1192881-2.5 2.5-2.5zm9.5 0c1.3807119 0 2.5 1.1192881 2.5 2.5s-1.1192881 2.5-2.5 2.5-2.5-1.1192881-2.5-2.5 1.1192881-2.5 2.5-2.5z" fill-rule="evenodd"></path>
                          </svg>

                      </span>
                      <span class="label style-scope media-button"><!--?lit$49386103$-->More</span>

                    </a>
                    </media-button>
                    <!---->
                    </div>
                    </nav>
                    </div>
                    </div>
                    </media-menu>
        <div class="right-side-section style-scope primary-nav">
          <!--?lit$49386103$-->
          <a class="mobile-donate-link style-scope primary-nav" href="https://archive.org/donate/?origin=iawww-mbhrt">
            <!--?lit$49386103$-->
            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" aria-labelledby="donateTitleID donateDescID" class="style-scope primary-nav">
              <title id="donateTitleID" class="style-scope primary-nav">Donate icon</title>
              <desc id="donateDescID" class="style-scope primary-nav">An illustration of a heart shape</desc>
              <path class="fill-color style-scope primary-nav" d="m32.6,8.12c-1.57,-1.51 -3.46,-2.21 -5.65,-2.11c-1,0.03 -2.14,0.51 -3.42,1.44c-1.28,0.92 -2.28,2.09 -3.03,3.51c-0.71,-1.41 -1.72,-2.59 -3,-3.51c-1.29,-0.93 -2.43,-1.41 -3.41,-1.44c-1.46,-0.07 -2.8,0.23 -4.02,0.88c-1.23,0.65 -2.21,1.6 -2.94,2.83c-0.74,1.24 -1.11,2.63 -1.12,4.17c-0.05,2.56 0.85,5.01 2.68,7.37c1.46,1.88 3.52,4.21 6.19,7.04c2.66,2.81 4.53,4.71 5.62,5.69c1,-0.88 2.85,-2.75 5.55,-5.6s4.81,-5.23 6.31,-7.13c1.81,-2.36 2.71,-4.81 2.66,-7.37c-0.04,-2.35 -0.83,-4.28 -2.4,-5.77z">
              </path>
              </svg>

            <span class="sr-only style-scope primary-nav">"Donate to the archive"</span>
            </a>

          <!--?lit$49386103$-->
          <div class="user-info style-scope primary-nav">
            <!--?lit$49386103$-->
            <login-button class="style-scope primary-nav x-scope login-button-1"><!---->
              <div class="logged-out-toolbar style-scope login-button">
                <a class="dropdown-toggle style-scope login-button" data-event-click-tracking="TopNav|NavLoginIcon">
                  <!--?lit$49386103$-->
                  <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="userTitleID userDescID" class="style-scope login-button">
                    <title id="userTitleID" class="style-scope login-button">User icon</title>
                    <desc id="userDescID" class="style-scope login-button">An illustration of a person's head and chest.
                    </desc>
                    <path class="fill-color style-scope login-button" d="m20.7130435 18.0434783c-3.5658385 0-6.4565218-2.9198821-6.4565218-6.5217392 0-3.60185703 2.8906833-6.5217391 6.4565218-6.5217391s6.4565217 2.91988207 6.4565217 6.5217391c0 3.6018571-2.8906832 6.5217392-6.4565217 6.5217392zm-12.9130435 16.9565217c0-7.9240855 5.7813665-14.3478261 12.9130435-14.3478261s12.9130435 6.4237406 12.9130435 14.3478261z" fill-rule="evenodd"></path>
                    </svg>

                </a>
                <span class="style-scope login-button">
                  <a class="style-scope login-button" href="https://archive.org/account/signup">Sign up</a>
                  |
                  <a class="style-scope login-button" href="https://archive.org/account/login">Log in</a>
                </span>
                </div>
                </login-button>

          </div>
          <!--?lit$49386103$-->
          <a class="upload style-scope primary-nav" href="https://archive.org/create">
            <!--?lit$49386103$-->
            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="uploadTitleID uploadDescID" class="style-scope primary-nav">
              <title id="uploadTitleID" class="style-scope primary-nav">Upload icon</title>
              <desc id="uploadDescID" class="style-scope primary-nav">An illustration of a horizontal line over an up
                pointing arrow.</desc>
              <path class="fill-color style-scope primary-nav" d="m20 12.8 8 10.4h-4.8v8.8h-6.4v-8.8h-4.8zm12-4.8v3.2h-24v-3.2z" fill-rule="evenodd"></path>
              </svg>

            <span class="style-scope primary-nav">Upload</span>
            </a>
          <!--?lit$49386103$-->
          <button class="search-trigger style-scope primary-nav" data-event-click-tracking="TopNav|NavSearchOpen">
            <!--?lit$49386103$-->
            <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="searchTitleID searchDescID" class="style-scope primary-nav">
              <title id="searchTitleID" class="style-scope primary-nav">Search icon</title>
              <desc id="searchDescID" class="style-scope primary-nav">An illustration of a magnifying glass.</desc>
              <path class="fill-color style-scope primary-nav" d="m32.4526364 29.8875889-8.1719472-7.9751279c1.1046135-1.4876138 1.7652549-3.3102407 1.7652549-5.2846451 0-.101185-.0142895-.1981539-.030573-.2944743.0166158-.0976175.0309053-.196208.0309053-.2990145 0-4.9814145-4.152935-9.0343271-9.2572866-9.0343271-.0907218 0-.1781206.01394537-.2655193.02594487-.0880633-.0119995-.1747974-.02594487-.2655193-.02594487-5.1046839 0-9.25761889 4.0529126-9.25761889 9.0343271 0 .1011849.01395722.1981539.03057294.2947985-.01694804.0976176-.03090525.1958838-.03090525.2986903 0 4.9814145 4.1526027 9.0346514 9.2572866 9.0346514.0907218 0 .1777882-.0139454.2658516-.0262692.0873987.0123238.1741328.0262692.265187.0262692 1.7306942 0 3.3467399-.4747911 4.7338208-1.2852439l8.2882574 8.0886366c.3652137.3564177.843082.53414 1.3212826.53414.4782007 0 .9567336-.1780467 1.3212827-.53414.7294304-.7118622.7294304-1.8660845-.0003323-2.5782711zm-15.9526364-7.8875889c-.0832667-.0118703-.1652765-.0253024-.2513711-.0253024-2.8781993 0-5.2197212-2.3278242-5.2197212-5.1891862 0-.0974612-.013197-.1908615-.0289077-.2836371.0160249-.0940251.0292219-.1889874.0292219-.2880105 0-2.861362 2.3418361-5.1891861 5.2200354-5.1891861.0854662 0 .1677902-.0131198.2510569-.0246777.0826383.0115579.1649623.0246777.2510569.0246777 2.8781993 0 5.2197212 2.3278241 5.2197212 5.1891861 0 .0974612.0135112.1908616.0289077.2839496-.0157107.0940251-.0295361.1886749-.0295361.287698 0 2.861362-2.3415219 5.1891862-5.2197212 5.1891862-.0860946 0-.1684187.0134321-.2507427.0253024z" fill-rule="evenodd"></path>
              </svg>

          </button>
          <nav-search class="style-scope primary-nav x-scope nav-search-1"><!---->
            <div class="search-activated fade-in search-inactive style-scope nav-search">
              <form id="nav-search" class="highlight style-scope nav-search" method="get" action="https://archive.org/search" data-event-submit-tracking="TopNav|NavSearchSubmit">
                <input type="text" name="query" class="search-field style-scope nav-search" placeholder="Search" autocomplete="off" value="">
                <!--?lit$49386103$-->
                <button type="submit" class="search style-scope nav-search" tabindex="-1" data-event-click-tracking="TopNav|NavSearchClose">
                  <!--?lit$49386103$-->
                  <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="searchTitleID searchDescID" class="style-scope nav-search">
                    <title id="searchTitleID" class="style-scope nav-search">Search icon</title>
                    <desc id="searchDescID" class="style-scope nav-search">An illustration of a magnifying glass.</desc>
                    <path class="fill-color style-scope nav-search" d="m32.4526364 29.8875889-8.1719472-7.9751279c1.1046135-1.4876138 1.7652549-3.3102407 1.7652549-5.2846451 0-.101185-.0142895-.1981539-.030573-.2944743.0166158-.0976175.0309053-.196208.0309053-.2990145 0-4.9814145-4.152935-9.0343271-9.2572866-9.0343271-.0907218 0-.1781206.01394537-.2655193.02594487-.0880633-.0119995-.1747974-.02594487-.2655193-.02594487-5.1046839 0-9.25761889 4.0529126-9.25761889 9.0343271 0 .1011849.01395722.1981539.03057294.2947985-.01694804.0976176-.03090525.1958838-.03090525.2986903 0 4.9814145 4.1526027 9.0346514 9.2572866 9.0346514.0907218 0 .1777882-.0139454.2658516-.0262692.0873987.0123238.1741328.0262692.265187.0262692 1.7306942 0 3.3467399-.4747911 4.7338208-1.2852439l8.2882574 8.0886366c.3652137.3564177.843082.53414 1.3212826.53414.4782007 0 .9567336-.1780467 1.3212827-.53414.7294304-.7118622.7294304-1.8660845-.0003323-2.5782711zm-15.9526364-7.8875889c-.0832667-.0118703-.1652765-.0253024-.2513711-.0253024-2.8781993 0-5.2197212-2.3278242-5.2197212-5.1891862 0-.0974612-.013197-.1908615-.0289077-.2836371.0160249-.0940251.0292219-.1889874.0292219-.2880105 0-2.861362 2.3418361-5.1891861 5.2200354-5.1891861.0854662 0 .1677902-.0131198.2510569-.0246777.0826383.0115579.1649623.0246777.2510569.0246777 2.8781993 0 5.2197212 2.3278241 5.2197212 5.1891861 0 .0974612.0135112.1908616.0289077.2839496-.0157107.0940251-.0295361.1886749-.0295361.287698 0 2.861362-2.3415219 5.1891862-5.2197212 5.1891862-.0860946 0-.1684187.0134321-.2507427.0253024z" fill-rule="evenodd"></path>
                    </svg>

                </button>
                </form>
                </div>
                </nav-search>

        </div>
      </nav>
    </primary-nav>
    <media-slider class="style-scope ia-topnav x-scope media-slider-1" tabindex="-1"><!---->
      <div class="media-slider-container style-scope media-slider">
        <div class="overflow-clip closed style-scope media-slider">
          <div class="information-menu closed style-scope media-slider">
            <div class="info-box style-scope media-slider">
              <media-subnav menu="audio" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <h3 class="style-scope media-subnav"><!--?lit$49386103$-->Internet Archive Audio</h3>
                <div class="icon-links style-scope media-subnav">
                  <!--?lit$49386103$--><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/etree" data-event-click-tracking="TopNav|LiveMusicArchiveAudio"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/etree"><!--?lit$49386103$-->Live Music
                    Archive</a>
                  <!----><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/librivoxaudio" data-event-click-tracking="TopNav|LibrivoxFreeAudioAudio"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/librivoxaudio"><!--?lit$49386103$-->Librivox
                    Free Audio</a>
                  <!---->
                  </div>
                  <div class="links featured style-scope media-subnav">
                    <h4 class="style-scope media-subnav">Featured</h4>
                    <ul class="style-scope media-subnav">
                      <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio" data-event-click-tracking="TopNav|AllAudioAudio"><!--?lit$49386103$-->All Audio</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/GratefulDead" data-event-click-tracking="TopNav|GratefulDeadAudio"><!--?lit$49386103$-->Grateful Dead</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/netlabels" data-event-click-tracking="TopNav|NetlabelsAudio"><!--?lit$49386103$-->Netlabels</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/oldtimeradio" data-event-click-tracking="TopNav|OldTimeRadioAudio"><!--?lit$49386103$-->Old Time Radio</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/78rpm" data-event-click-tracking="TopNav|78RPMsAndCylinderRecordingsAudio"><!--?lit$49386103$-->78 RPMs
                        and Cylinder Recordings</a></li>
                    <!---->
                    </ul>
                    </div>
                    <div class="links top style-scope media-subnav">
                      <h4 class="style-scope media-subnav">Top</h4>
                      <ul class="style-scope media-subnav">
                        <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio_bookspoetry" data-event-click-tracking="TopNav|AudioBooks&amp;PoetryAudio"><!--?lit$49386103$-->Audio Books
                        &amp; Poetry</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio_tech" data-event-click-tracking="TopNav|Computers,TechnologyAndScienceAudio"><!--?lit$49386103$-->Computers,
                        Technology and Science</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio_music" data-event-click-tracking="TopNav|Music,Arts&amp;CultureAudio"><!--?lit$49386103$-->Music, Arts
                        &amp; Culture</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio_news" data-event-click-tracking="TopNav|News&amp;PublicAffairsAudio"><!--?lit$49386103$-->News &amp;
                        Public Affairs</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/audio_religion" data-event-click-tracking="TopNav|Spirituality&amp;ReligionAudio"><!--?lit$49386103$-->Spirituality
                        &amp; Religion</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/podcasts" data-event-click-tracking="TopNav|PodcastsAudio"><!--?lit$49386103$-->Podcasts</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/radio" data-event-click-tracking="TopNav|RadioNewsArchiveAudio"><!--?lit$49386103$-->Radio News
                        Archive</a></li>
                    <!---->
                    </ul>
                    </div>
                    </media-subnav>
              <media-subnav menu="images" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <h3 class="style-scope media-subnav"><!--?lit$49386103$-->Images</h3>
                <div class="icon-links style-scope media-subnav">
                  <!--?lit$49386103$--><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/metropolitanmuseumofart-gallery" data-event-click-tracking="TopNav|MetropolitanMuseumImages"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/metropolitanmuseumofart-gallery"><!--?lit$49386103$-->Metropolitan Museum</a>
                  <!----><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/clevelandart" data-event-click-tracking="TopNav|ClevelandMuseumOfArtImages"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/clevelandart"><!--?lit$49386103$-->Cleveland
                    Museum of Art</a>
                  <!---->
                  </div>
                  <div class="links featured style-scope media-subnav">
                    <h4 class="style-scope media-subnav">Featured</h4>
                    <ul class="style-scope media-subnav">
                      <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/image" data-event-click-tracking="TopNav|AllImagesImages"><!--?lit$49386103$-->All Images</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/flickrcommons" data-event-click-tracking="TopNav|FlickrCommonsImages"><!--?lit$49386103$-->Flickr Commons</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/flickr-ows" data-event-click-tracking="TopNav|OccupyWallStreetFlickrImages"><!--?lit$49386103$-->Occupy Wall
                        Street Flickr</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/coverartarchive" data-event-click-tracking="TopNav|CoverArtImages"><!--?lit$49386103$-->Cover Art</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/maps_usgs" data-event-click-tracking="TopNav|USGSMapsImages"><!--?lit$49386103$-->USGS Maps</a></li>
                    <!---->
                    </ul>
                    </div>
                    <div class="links top style-scope media-subnav">
                      <h4 class="style-scope media-subnav">Top</h4>
                      <ul class="style-scope media-subnav">
                        <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/nasa" data-event-click-tracking="TopNav|NASAImagesImages"><!--?lit$49386103$-->NASA Images</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/solarsystemcollection" data-event-click-tracking="TopNav|SolarSystemCollectionImages"><!--?lit$49386103$-->Solar System
                        Collection</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/amesresearchcenterimagelibrary" data-event-click-tracking="TopNav|AmesResearchCenterImages"><!--?lit$49386103$-->Ames Research
                        Center</a></li>
                    <!---->
                    </ul>
                    </div>
                    </media-subnav>
              <media-subnav menu="software" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <h3 class="style-scope media-subnav"><!--?lit$49386103$-->Software</h3>
                <div class="icon-links style-scope media-subnav">
                  <!--?lit$49386103$--><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/internetarcade" data-event-click-tracking="TopNav|InternetArcadeSoftware"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/internetarcade"><!--?lit$49386103$-->Internet
                    Arcade</a>
                  <!----><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/consolelivingroom" data-event-click-tracking="TopNav|ConsoleLivingRoomSoftware"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/consolelivingroom"><!--?lit$49386103$-->Console Living Room</a>
                  <!---->
                  </div>
                  <div class="links featured style-scope media-subnav">
                    <h4 class="style-scope media-subnav">Featured</h4>
                    <ul class="style-scope media-subnav">
                      <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/software" data-event-click-tracking="TopNav|AllSoftwareSoftware"><!--?lit$49386103$-->All Software</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/tosec" data-event-click-tracking="TopNav|OldSchoolEmulationSoftware"><!--?lit$49386103$-->Old School
                        Emulation</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwarelibrary_msdos_games" data-event-click-tracking="TopNav|MS-DOSGamesSoftware"><!--?lit$49386103$-->MS-DOS Games</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/historicalsoftware" data-event-click-tracking="TopNav|HistoricalSoftwareSoftware"><!--?lit$49386103$-->Historical
                        Software</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/classicpcgames" data-event-click-tracking="TopNav|ClassicPCGamesSoftware"><!--?lit$49386103$-->Classic PC
                        Games</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwarelibrary" data-event-click-tracking="TopNav|SoftwareLibrarySoftware"><!--?lit$49386103$-->Software
                        Library</a></li>
                    <!---->
                    </ul>
                    </div>
                    <div class="links top style-scope media-subnav">
                      <h4 class="style-scope media-subnav">Top</h4>
                      <ul class="style-scope media-subnav">
                        <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/kodi_archive" data-event-click-tracking="TopNav|KodiArchiveAndSupportFileSoftware"><!--?lit$49386103$-->Kodi
                        Archive and Support File</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/vintagesoftware" data-event-click-tracking="TopNav|VintageSoftwareSoftware"><!--?lit$49386103$-->Vintage
                        Software</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/apkarchive" data-event-click-tracking="TopNav|APKSoftware"><!--?lit$49386103$-->APK</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwarelibrary_msdos" data-event-click-tracking="TopNav|MS-DOSSoftware"><!--?lit$49386103$-->MS-DOS</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/cd-roms" data-event-click-tracking="TopNav|CD-ROMSoftwareSoftware"><!--?lit$49386103$-->CD-ROM
                        Software</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/cdromsoftware" data-event-click-tracking="TopNav|CD-ROMSoftwareLibrarySoftware"><!--?lit$49386103$-->CD-ROM
                        Software Library</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwaresites" data-event-click-tracking="TopNav|SoftwareSitesSoftware"><!--?lit$49386103$-->Software Sites</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/tucows" data-event-click-tracking="TopNav|TucowsSoftwareLibrarySoftware"><!--?lit$49386103$-->Tucows
                        Software Library</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/cdbbsarchive" data-event-click-tracking="TopNav|SharewareCD-ROMsSoftware"><!--?lit$49386103$-->Shareware
                        CD-ROMs</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwarecapsules" data-event-click-tracking="TopNav|SoftwareCapsulesCompilationSoftware"><!--?lit$49386103$-->Software
                        Capsules Compilation</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/cdromimages" data-event-click-tracking="TopNav|CD-ROMImagesSoftware"><!--?lit$49386103$-->CD-ROM Images</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/softwarelibrary_zx_spectrum" data-event-click-tracking="TopNav|ZXSpectrumSoftware"><!--?lit$49386103$-->ZX Spectrum</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/doom-cds" data-event-click-tracking="TopNav|DOOMLevelCDSoftware"><!--?lit$49386103$-->DOOM Level CD</a>
                    </li>
                    <!---->
                    </ul>
                    </div>
                    </media-subnav>
              <media-subnav menu="texts" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <h3 class="style-scope media-subnav"><!--?lit$49386103$-->Texts</h3>
                <div class="icon-links style-scope media-subnav">
                  <!--?lit$49386103$--><!---->
                  <a class="style-scope media-subnav" href="https://openlibrary.org/" data-event-click-tracking="TopNav|OpenLibraryTexts"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/widgetOL.png"><!--?lit$49386103$-->Open Library</a>
                  <!----><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/americana" data-event-click-tracking="TopNav|AmericanLibrariesTexts"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/americana"><!--?lit$49386103$-->American
                    Libraries</a>
                  <!---->
                  </div>
                  <div class="links featured style-scope media-subnav">
                    <h4 class="style-scope media-subnav">Featured</h4>
                    <ul class="style-scope media-subnav">
                      <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/texts" data-event-click-tracking="TopNav|AllTextsTexts"><!--?lit$49386103$-->All Texts</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/smithsonian" data-event-click-tracking="TopNav|SmithsonianLibrariesTexts"><!--?lit$49386103$-->Smithsonian
                        Libraries</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/fedlink" data-event-click-tracking="TopNav|FEDLINK(US)Texts"><!--?lit$49386103$-->FEDLINK (US)</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/genealogy" data-event-click-tracking="TopNav|GenealogyTexts"><!--?lit$49386103$-->Genealogy</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/lincolncollection" data-event-click-tracking="TopNav|LincolnCollectionTexts"><!--?lit$49386103$-->Lincoln
                        Collection</a></li>
                    <!---->
                    </ul>
                    </div>
                    <div class="links top style-scope media-subnav">
                      <h4 class="style-scope media-subnav">Top</h4>
                      <ul class="style-scope media-subnav">
                        <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/americana" data-event-click-tracking="TopNav|AmericanLibrariesTexts"><!--?lit$49386103$-->American
                        Libraries</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/toronto" data-event-click-tracking="TopNav|CanadianLibrariesTexts"><!--?lit$49386103$-->Canadian
                        Libraries</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/universallibrary" data-event-click-tracking="TopNav|UniversalLibraryTexts"><!--?lit$49386103$-->Universal
                        Library</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/gutenberg" data-event-click-tracking="TopNav|ProjectGutenbergTexts"><!--?lit$49386103$-->Project
                        Gutenberg</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/iacl" data-event-click-tracking="TopNav|Children&#39;sLibraryTexts"><!--?lit$49386103$-->Children's
                        Library</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/biodiversity" data-event-click-tracking="TopNav|BiodiversityHeritageLibraryTexts"><!--?lit$49386103$-->Biodiversity
                        Heritage Library</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/booksbylanguage" data-event-click-tracking="TopNav|BooksByLanguageTexts"><!--?lit$49386103$-->Books by
                        Language</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/additional_collections" data-event-click-tracking="TopNav|AdditionalCollectionsTexts"><!--?lit$49386103$-->Additional
                        Collections</a></li>
                    <!---->
                    </ul>
                    </div>
                    </media-subnav>
              <media-subnav menu="video" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <h3 class="style-scope media-subnav"><!--?lit$49386103$-->Video</h3>
                <div class="icon-links style-scope media-subnav">
                  <!--?lit$49386103$--><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/tv" data-event-click-tracking="TopNav|TVNewsVideo"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/tv"><!--?lit$49386103$-->TV News</a>
                  <!----><!---->
                  <a class="style-scope media-subnav" href="https://archive.org/details/911" data-event-click-tracking="TopNav|Understanding9/11Video"><img loading="lazy" class="style-scope media-subnav" src="./Full text of _Hacking Secret Ciphers With Python__files/911"><!--?lit$49386103$-->Understanding
                    9/11</a>
                  <!---->
                  </div>
                  <div class="links featured style-scope media-subnav">
                    <h4 class="style-scope media-subnav">Featured</h4>
                    <ul class="style-scope media-subnav">
                      <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/movies" data-event-click-tracking="TopNav|AllVideoVideo"><!--?lit$49386103$-->All Video</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/prelinger" data-event-click-tracking="TopNav|PrelingerArchivesVideo"><!--?lit$49386103$-->Prelinger
                        Archives</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/democracy_now_vid" data-event-click-tracking="TopNav|DemocracyNow!Video"><!--?lit$49386103$-->Democracy Now!</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/occupywallstreet" data-event-click-tracking="TopNav|OccupyWallStreetVideo"><!--?lit$49386103$-->Occupy Wall
                        Street</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/nsa" data-event-click-tracking="TopNav|TVNSAClipLibraryVideo"><!--?lit$49386103$-->TV NSA Clip
                        Library</a></li>
                    <!---->
                    </ul>
                    </div>
                    <div class="links top style-scope media-subnav">
                      <h4 class="style-scope media-subnav">Top</h4>
                      <ul class="style-scope media-subnav">
                        <!--?lit$49386103$--><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/animationandcartoons" data-event-click-tracking="TopNav|Animation&amp;CartoonsVideo"><!--?lit$49386103$-->Animation
                        &amp; Cartoons</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/artsandmusicvideos" data-event-click-tracking="TopNav|Arts&amp;MusicVideo"><!--?lit$49386103$-->Arts &amp; Music</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/computersandtechvideos" data-event-click-tracking="TopNav|Computers&amp;TechnologyVideo"><!--?lit$49386103$-->Computers
                        &amp; Technology</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/culturalandacademicfilms" data-event-click-tracking="TopNav|Cultural&amp;AcademicFilmsVideo"><!--?lit$49386103$-->Cultural
                        &amp; Academic Films</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/ephemera" data-event-click-tracking="TopNav|EphemeralFilmsVideo"><!--?lit$49386103$-->Ephemeral Films</a>
                    </li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/moviesandfilms" data-event-click-tracking="TopNav|MoviesVideo"><!--?lit$49386103$-->Movies</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/newsandpublicaffairs" data-event-click-tracking="TopNav|News&amp;PublicAffairsVideo"><!--?lit$49386103$-->News &amp;
                        Public Affairs</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/spiritualityandreligion" data-event-click-tracking="TopNav|Spirituality&amp;ReligionVideo"><!--?lit$49386103$-->Spirituality
                        &amp; Religion</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/sports" data-event-click-tracking="TopNav|SportsVideosVideo"><!--?lit$49386103$-->Sports Videos</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/television" data-event-click-tracking="TopNav|TelevisionVideo"><!--?lit$49386103$-->Television</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/gamevideos" data-event-click-tracking="TopNav|VideogameVideosVideo"><!--?lit$49386103$-->Videogame
                        Videos</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/vlogs" data-event-click-tracking="TopNav|VlogsVideo"><!--?lit$49386103$-->Vlogs</a></li>
                    <!----><!---->
                    <li class="style-scope media-subnav"><a class="style-scope media-subnav" href="https://archive.org/details/youth_media" data-event-click-tracking="TopNav|YouthMediaVideo"><!--?lit$49386103$-->Youth Media</a></li>
                    <!---->
                    </ul>
                    </div>
                    </media-subnav>
              <media-subnav menu="web" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <wayback-slider class="style-scope media-subnav x-scope wayback-slider-1"><!---->
                  <div class="grid style-scope wayback-slider">
                    <wayback-search class="style-scope wayback-slider x-scope wayback-search-1" waybackpagesarchived="1 trillion"><!---->
                      <form action="https://archive.org/stream/hackingciphers/hackingciphers_djvu.txt" method="post" class="style-scope wayback-search">
                        <p class="style-scope wayback-search">
                          Search the history of more than <!--?lit$49386103$-->1 trillion
                          <a data-event-click-tracking="TopNav|WaybackMachineStatsLink" href="https://blog.archive.org/2016/10/23/defining-web-pages-web-sites-and-web-captures/" class="style-scope wayback-search">web pages</a>.
                          </p>
                          <fieldset class="style-scope wayback-search">
                          <a data-event-click-tracking="TopNav|WaybackMachineLogoLink" href="https://web.archive.org/" class="style-scope wayback-search"><!--?lit$49386103$-->
                            <svg height="55" viewBox="0 0 205 55" width="205" xmlns="http://www.w3.org/2000/svg" class="style-scope wayback-search">
                              <g fill="none" class="style-scope wayback-search">
                                <path d="m41.5442526 5.47625158v36.05869762s-.0825635.8039669.6808836.8039669c.7634442 0 .5779563-.8039669.5779563-.8039669v-36.05869762h5.4674088l.0001982 44.76728562c.0070059.1547261.1602174 4.7191467-6.1484876 4.7191467-6.1999371 0-6.1018528-4.697561-6.0880787-5.0160398l.0008628-1.7899844h5.5092566l.0006247 1.8215446c.0064131.111431.0698016.5292973.6598981.5292973.6808836 0 .5564693-.5981684.5564693-.5981684v-4.3726361s-.9489378 1.6294184-3.4044061 1.2370455c-2.4554712-.39237-2.8060919-1.8148639-2.9712219-2.4967105-.1651328-.6795829-.2680542-1.174855-.2680542-2.0625 0-.8599178-.0383122-34.61864321-.0406109-36.64339281l-.0001077-.09488771zm30.6351382 1.09344342c6.9117365 0 6.7805382 5.4445918 6.7805382 5.4445918v39.5210721h-5.7365952v-1.1522413s-2.086754 2.4978424-5.1507198.8955592c-3.0650979-1.6011513-2.5436924-5.1879097-2.5436924-5.1879097l.0000351-8.8028589c.0025794-.2398669.0684122-2.0251881 1.4352444-3.3674745 1.4669498-1.4405832 3.4553051-1.2178245 3.4553051-1.2178245h2.5425603v-20.4327721s-.0656021-.8966882-.7170766-.8966882c-.6526037 0-.6854033.9566179-.6854033.9566179v16.080489h-6.030665l-.0005626-16.2852138c-.0087587-.3366877-.0366527-5.555347 6.6510318-5.555347zm28.5031432-6.569695v31.41468l.711418.0192211c.593792 0 .593792-.4941403.593792-.4941403v-24.86759869h5.897202v21.90049339s.079171 1.404399-.791723 2.512539c-.870895 1.1081429-1.820962 1.1477197-1.820962 1.1477197s.989654.3946337 1.860548 1.4439758c.870894 1.0482132.791724 2.4921889.791724 2.4921889v14.4024477h-5.936789l-.000309-13.3243353c-.002165-.043998-.019484-.2297601-.158037-.3860879-.158343-.1775284-.277102-.1775284-.277102-.1775284h-.890123v13.8879516h-5.8180296v-49.9715266zm-14.2340414 8.02384579c5.9675612 0 6.2060902 4.59291681 6.2148001 5.06804611l.0002664 15.2041578h-5.556805v-15.4269123s-.0531603-.5009227-.6062332-.5009227c-.5519582 0-.5790885.42064-.5790885.42064v32.2254321s.079173.4477782.6582614.4477782c.4900102 0 .5467595-.3205986.552623-.4192443l.00045-8.2163433h5.4775891l.000339 7.8754281c.0126595.1654646.3391417 5.1294029-6.0570166 5.1294029-6.504565 0-6.1358477-5.1867779-6.1358477-5.1867779l-.0006428-31.5032204c-.0096883-.3249184-.0495263-5.11746431 6.0313048-5.11746431zm-73.7580006-5.70016816v42.49270187h.5575988s.2081099.2374581.5010473-.0554082.1956685-.3901121.1956685-.3901121v-42.04605262l5.7004019.00115789.0007682 41.01721663c.015678.1470376.248026 2.5994908-1.4903372 4.3374305-1.792686 1.7922473-4.4053704 1.6101973-4.4053704 1.6101973h-7.83579091s-2.61381542.18205-4.40650134-1.6101973c-1.79268592-1.7922503-1.48843833-4.344369-1.48843833-4.344369v-41.01027813l5.69927118-.00115789v42.04605262s-.09726862.0972458.19566849.3901121c.29293741.2928663.50217829.0554082.50217829.0554082h.55646783v-42.49270187zm44.8442957-.59701342s2.8128759.11081342 4.2515488 1.54913579 1.3572386 4.52302632 1.3572386 4.52302632v20.17269738s.1085791 1.6825658-.8324397 2.4967105c-.9410187.8141447-1.5743967.9950658-1.5743967.9950658s1.0495978.5789474 1.6105898 1.3026316c.5609919.7236842.7419571 1.3930921.7419571 2.3881579l.0007115 7.6426204c.0126941.1435677.1783816 2.2493941-.8874408 3.6468533-1.1038873 1.4473684-2.4430294 2.1348684-5.2298927 2.1348684h-6.4604558v-46.85176739zm14.5337626 35.74095399s-.1673942-.0203558-.3777654.1843136c-.2092421.2069274-.1459043.3301795-.1459043.3301795v8.4524058s.1673942.4523026.7329089.4523026c.5643854 0 .648084-.4523026.648084-.4523026v-8.9465489zm-44.3104484-34.72101373c5.9643432 0 6.16707 4.5349604 6.1720848 5.00409423l-.0000412 36.6461958h-5.2231058v-1.0674342s-1.8990049 2.3135258-4.6881295.8299731c-2.7891246-1.4824208-2.3140925-4.8057147-2.3140925-4.8057147l.0000416-8.1558683c.0025667-.229176.064831-1.8776574 1.3051717-3.1166422 1.3357486-1.3354261 3.1454001-1.1273669 3.1454001-1.1273669h2.3140896v-18.92660288s-.0588122-.831105-.6526037-.831105-.6232005.88538132-.6232005.88538132v14.89545606h-5.4888988l-.0005553-15.08585244c-.0080458-.3266358-.0237133-5.14451389 6.0538395-5.14451389zm28.932117 33.13115253-.4776089-.0000064v8.3947599h.705764c.5067025 0 .560992-.7236842.560992-.7236842v-6.712171c0-.9769737-.7962466-.9589047-.7962466-.9589047zm-29.0339092-4.5105709s-.1526883-.0203529-.3438338.1707431c-.1900134.191099-.1323304.305305-.1323304.305305v7.8282282s.1515591.419511.6661776.419511c.5146186 0 .5915302-.419511.5915302-.419511v-8.2861842zm29.0087131-25.54039926c-.6808813 0-.5443092.01385177-.4995274.01731471l.0109215.0007774v25.52796055s1.3391421.1085526 1.3391421-1.3569079v-23.35690792s.1085791-.83223684-.8505362-.83223684z" fill="#ab2e33" class="style-scope wayback-search"></path>
                                <path d="m164.347608 2.25946661v7.4442539c.21729-.35229187 1.198489-1.67028746 3.735798-1.67028746 3.534354 0 3.281982 3.91684325 3.281982 3.91684325v39.9180342h-3.988173l-.000094-38.4191634c-.002249-.1296195-.058484-1.7498629-1.464346-1.7498629-1.087582 0-1.450864.5267465-1.565167 1.1683005v39.1020256h-4.190748v-49.71014369zm23.367699 5.4959617c3.58528 0 3.32838 3.94160559 3.32838 3.94160559v40.1712766h-4.045888l-.000761-38.6884533c-.008742-.2394578-.118025-1.7360686-1.484053-1.7360686-1.103423 0-1.471231.5301234-1.587799 1.1750516v39.3496435h-4.250729v-43.92154285h4.250729v1.38890288c.220685-.35566881 1.216596-1.68041542 3.790121-1.68041542zm11.392998-.52112204c6.124855 0 5.736674 5.39691513 5.736674 5.39691513v24.2844279h-7.17056l.000077 9.2728055c.001997 1.1852594.055922 2.3291557 1.511897 2.3291557 1.511974 0 1.588933-1.3483852 1.588933-1.3483852v-6.1679026h4.108134l-.00035 5.6892637c-.01289 1.7887967-.410235 4.8333128-5.736327 4.8333128-5.22451 0-5.490421-3.8596058-5.502952-4.1455025l-.000589-34.6706379s-.65866-5.47345253 5.465063-5.47345253zm-72.839588-6.23430627c4.55044 0 4.748706 4.49835393 4.756437 5.01739476l.000233 44.68489444h-4.246265l-.000015-45.39546442c-.001065-.11122824-.038841-1.27912478-1.155468-1.27912478-.689016 0-1.239407-.0003988-1.575847-.00072723l-.366181-.00042531v46.67574174h-4.288077v-46.69262361h-1.942025c-1.0608 0-1.147931 1.05402663-1.154906 1.2547936l-.00058 45.43783001h-4.296023l.000269-45.03840883c.008379-.46638804.223774-4.66388037 5.263374-4.66388037zm12.746531 4.73059864c5.939252 0 5.529572 4.80151166 5.529572 4.80151166v39.1864407h-3.791254v-1.7040541s-.748065 1.776088-2.920962 1.8481219-4.418224-.1913422-4.418224-3.9371049l.000537-10.0356421c.009666-.3007246.1911-3.4583326 3.548528-3.4583326h3.5253l-.000596-22.2422593c-.009853-.1121552-.157986-1.45801702-1.592862-1.45801702-1.497271 0-1.484813 1.94491522-1.484813 1.94491522v17.4051907h-3.99949l-.000952-17.7112484c-.014831-.304231-.125641-4.63952176 5.605216-4.63952176zm12.457944.74622797c5.704988 0 5.452616 4.56852529 5.452616 4.56852529v16.2188817h-3.836522v-16.7703934s-.202578-1.40578478-1.51537-1.40578478c-1.193447 0-1.427274 1.16180558-1.459925 1.37304298l-.004518.0327418v32.5368129c0 .9038006.353096 1.9584201 1.565167 1.9584201 1.212068 0 1.363719-1.3551363 1.363719-1.3551363v-9.239474h3.786725l.000848 7.3579585c.013087 2.5821014.10472 5.9480539-5.301813 5.9480539-5.604264 0-5.201371-4.7699955-5.201371-4.7699955l-.000475-31.3866454c-.017056-.171763-.453979-5.06700779 5.150919-5.06700779zm26.215101 3.66584829v37.0051649h-3.533221v-37.0051649zm-37.199548 25.1702202h-1.714552s-.530775.0720339-.917823.4558391c-.385924.3838082-.409681.9848389-.409681.9848389v8.5236357s.096195 1.56111 1.568559 1.56111c1.473497 0 1.473497-1.6095052 1.473497-1.6095052zm58.697648-25.2264959c-1.433886 0-1.511974 1.7344408-1.511974 1.7344408v21.9725922h3.100907v-22.1256642s-.155047-1.5813688-1.588933-1.5813688zm-23.264712-5.31700073c1.129455 0 2.045015.68657238 2.045015 1.53184407 0 .84639831-.91556 1.53184695-2.045015 1.53184695s-2.045012-.68544864-2.045012-1.53184695c0-.84527169.915557-1.53184407 2.045012-1.53184407z" fill="#211e1e" class="style-scope wayback-search"></path>
                              </g>
                            </svg>
                          </a>
                          <label for="url" class="style-scope wayback-search">Search the Wayback Machine</label>
                          <div class="search-field style-scope wayback-search">
                            <input type="text" name="url" id="url" placeholder="enter URL or keywords" class="style-scope wayback-search">
                            <!--?lit$49386103$-->
                            <svg height="40" viewBox="0 0 40 40" width="40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="searchTitleID searchDescID" class="style-scope wayback-search">
                              <title id="searchTitleID" class="style-scope wayback-search">Search icon</title>
                              <desc id="searchDescID" class="style-scope wayback-search">An illustration of a magnifying
                                glass.</desc>
                              <path class="fill-color style-scope wayback-search" d="m32.4526364 29.8875889-8.1719472-7.9751279c1.1046135-1.4876138 1.7652549-3.3102407 1.7652549-5.2846451 0-.101185-.0142895-.1981539-.030573-.2944743.0166158-.0976175.0309053-.196208.0309053-.2990145 0-4.9814145-4.152935-9.0343271-9.2572866-9.0343271-.0907218 0-.1781206.01394537-.2655193.02594487-.0880633-.0119995-.1747974-.02594487-.2655193-.02594487-5.1046839 0-9.25761889 4.0529126-9.25761889 9.0343271 0 .1011849.01395722.1981539.03057294.2947985-.01694804.0976176-.03090525.1958838-.03090525.2986903 0 4.9814145 4.1526027 9.0346514 9.2572866 9.0346514.0907218 0 .1777882-.0139454.2658516-.0262692.0873987.0123238.1741328.0262692.265187.0262692 1.7306942 0 3.3467399-.4747911 4.7338208-1.2852439l8.2882574 8.0886366c.3652137.3564177.843082.53414 1.3212826.53414.4782007 0 .9567336-.1780467 1.3212827-.53414.7294304-.7118622.7294304-1.8660845-.0003323-2.5782711zm-15.9526364-7.8875889c-.0832667-.0118703-.1652765-.0253024-.2513711-.0253024-2.8781993 0-5.2197212-2.3278242-5.2197212-5.1891862 0-.0974612-.013197-.1908615-.0289077-.2836371.0160249-.0940251.0292219-.1889874.0292219-.2880105 0-2.861362 2.3418361-5.1891861 5.2200354-5.1891861.0854662 0 .1677902-.0131198.2510569-.0246777.0826383.0115579.1649623.0246777.2510569.0246777 2.8781993 0 5.2197212 2.3278241 5.2197212 5.1891861 0 .0974612.0135112.1908616.0289077.2839496-.0157107.0940251-.0295361.1886749-.0295361.287698 0 2.861362-2.3415219 5.1891862-5.2197212 5.1891862-.0860946 0-.1684187.0134321-.2507427.0253024z" fill-rule="evenodd"></path>
                              </svg>

                          </div>
                          </fieldset>
                          </form>
                          </wayback-search>
                          <div class="link-lists style-scope wayback-slider">
                            <div class="style-scope wayback-slider">
                              <h4 class="style-scope wayback-slider">Mobile Apps</h4>
                              <ul class="mobile-apps style-scope wayback-slider">
                          <!--?lit$49386103$--><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://apps.apple.com/us/app/wayback-machine/id1201888313" data-event-click-tracking="TopNav|WaybackWaybackMachine(iOS)" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Wayback Machine (iOS)</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://play.google.com/store/apps/details?id=com.internetarchive.waybackmachine" data-event-click-tracking="TopNav|WaybackWaybackMachine(Android)" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Wayback Machine (Android)</a>
                          </li><!---->
                          </ul>
                          <h4 class="style-scope wayback-slider">Browser Extensions</h4>
                          <ul class="browser-extensions style-scope wayback-slider">
                          <!--?lit$49386103$--><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://chrome.google.com/webstore/detail/wayback-machine/fpnmgdkabkmnadcjpehmlllkndpkmiak" data-event-click-tracking="TopNav|WaybackChrome" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Chrome</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://addons.mozilla.org/en-US/firefox/addon/wayback-machine_new/" data-event-click-tracking="TopNav|WaybackFirefox" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Firefox</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://apps.apple.com/us/app/wayback-machine/id1472432422?mt=12" data-event-click-tracking="TopNav|WaybackSafari" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Safari</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://microsoftedge.microsoft.com/addons/detail/wayback-machine/kjmickeoogghaimmomagaghnogelpcpn?hl=en-US" data-event-click-tracking="TopNav|WaybackEdge" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Edge</a>
                          </li><!---->
                          </ul>
                          </div>
                          <div class="style-scope wayback-slider">
                            <h4 class="style-scope wayback-slider">Archive-It Subscription</h4>
                            <ul class="archive-it style-scope wayback-slider">
                          <!--?lit$49386103$--><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://www.archive-it.org/explore" data-event-click-tracking="TopNav|ArchiveItExploreTheCollections" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Explore the Collections</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://www.archive-it.org/blog/learn-more/" data-event-click-tracking="TopNav|ArchiveItLearnMore" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Learn More</a>
                          </li><!----><!---->
                          <li class="style-scope wayback-slider">
                            <a class="style-scope wayback-slider" href="https://www.archive-it.org/contact-us" data-event-click-tracking="TopNav|ArchiveItBuildCollections" target="_blank" rel="noreferrer noopener"><!--?lit$49386103$-->Build Collections</a>
                          </li><!---->
                          </ul>
                          </div>
                          </div>
                          <save-page-form class="style-scope wayback-slider x-scope save-page-form-1"><!---->
                      <form action="https://web.archive.org/save" method="post" class="style-scope save-page-form" data-event-submit-tracking="TopNav|SavePageSubmit">
                        <h3 class="style-scope save-page-form">Save Page Now</h3>
                        <p class="style-scope save-page-form">Capture a web page as it appears now for use as a trusted
                          citation in the future.</p>
                        <div class="style-scope save-page-form">
                          <input type="text" name="url_preload" placeholder="https://" class="style-scope save-page-form">
                          <input type="submit" value="Save" class="style-scope save-page-form">
                          </div>
                          <p class="error style-scope save-page-form">Please enter a valid web address</p>
                          </form>
                          </save-page-form>
                          </div>
                          </wayback-slider></media-subnav>
              <media-subnav menu="more" class="hidden style-scope media-slider x-scope media-subnav-1"><!---->
                <more-slider class="style-scope media-subnav x-scope more-slider-1"><!---->
                  <ul class="style-scope more-slider">
                    <!--?lit$49386103$--><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/about/" data-event-click-tracking="TopNav|NavMoreAbout"><!--?lit$49386103$-->About</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://blog.archive.org/" data-event-click-tracking="TopNav|NavMoreBlog"><!--?lit$49386103$-->Blog</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/events" data-event-click-tracking="TopNav|NavMoreEvents"><!--?lit$0049150236$-->Events</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/projects/" data-event-click-tracking="TopNav|NavMoreProjects"><!--?lit$49386103$-->Projects</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/about/faqs.php" data-event-click-tracking="TopNav|NavMoreHelp"><!--?lit$49386103$-->Help</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/donate?origin=iawww-TopNavDonateButton" data-event-click-tracking="TopNav|NavMoreDonate"><!--?lit$49386103$-->Donate</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/about/contact" data-event-click-tracking="TopNav|NavMoreContact"><!--?lit$49386103$-->Contact</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/about/jobs" data-event-click-tracking="TopNav|NavMoreJobs"><!--?lit$49386103$-->Jobs</a></li>
                    <!----><!---->
                    <li class="style-scope more-slider"><a class="style-scope more-slider" href="https://archive.org/about/volunteer-positions" data-event-click-tracking="TopNav|NavMoreVolunteer"><!--?lit$49386103$-->Volunteer</a></li>
                    </ul>
                    </more-slider></media-subnav>
            </div>
          </div>
        </div>
      </div>
    </media-slider>
  </div>
  <!--?lit$49386103$-->
  <signed-out-dropdown class="style-scope ia-topnav x-scope signed-out-dropdown-1" tabindex="-1"><!---->
    <div class="nav-container style-scope signed-out-dropdown">
      <nav class="initial style-scope signed-out-dropdown" aria-hidden="true" aria-expanded="false">
        <ul class="style-scope signed-out-dropdown">
          <!--?lit$49386103$--><!---->
          <li class="style-scope signed-out-dropdown"><!--?lit$49386103$--><a class="style-scope signed-out-dropdown" href="https://archive.org/account/signup" tabindex="-1" data-event-click-tracking="TopNav|NavAvatarMenu-Signup">
              <!--?lit$49386103$-->
              <!--?lit$49386103$-->Sign up for free
              <!--?lit$49386103$-->
            </a></li>
          <!----><!---->
          <li class="style-scope signed-out-dropdown"><!--?lit$49386103$--><a class="style-scope signed-out-dropdown" href="https://archive.org/account/login" tabindex="-1" data-event-click-tracking="TopNav|NavAvatarMenu-Login">
              <!--?lit$49386103$-->
              <!--?lit$49386103$-->Log in
              <!--?lit$49386103$-->
            </a></li>
          <!---->
          </ul>
          </nav>
          </div>
          </signed-out-dropdown>

  <search-menu class="style-scope ia-topnav x-scope search-menu-1" tabindex="-1"><!---->
    <div class="menu-wrapper style-scope search-menu">
      <div class="search-menu-inner tx-slide closed style-scope search-menu" aria-hidden="true" aria-expanded="false">
        <!--?lit$49386103$--><!---->
        <label class="style-scope search-menu">
          <input form="nav-search" type="radio" name="sin" class="style-scope search-menu" value="" checked="">
          Search <!--?lit$49386103$-->metadata
        </label>
        <!----><!---->
        <label class="style-scope search-menu">
          <input form="nav-search" type="radio" name="sin" class="style-scope search-menu" value="TXT">
          Search <!--?lit$49386103$-->text contents
        </label>
        <!----><!---->
        <label class="style-scope search-menu">
          <input form="nav-search" type="radio" name="sin" class="style-scope search-menu" value="TV">
          Search <!--?lit$49386103$-->TV news captions
        </label>
        <!----><!---->
        <label class="style-scope search-menu">
          <input form="nav-search" type="radio" name="sin" class="style-scope search-menu" value="RADIO">
          Search <!--?lit$49386103$-->radio transcripts
        </label>
        <!----><!---->
        <label class="style-scope search-menu">
          <input form="nav-search" type="radio" name="sin" class="style-scope search-menu" value="WEB">
          Search <!--?lit$49386103$-->archived web sites
        </label>
        <!---->
        <a class="advanced-search style-scope search-menu" href="https://archive.org/advancedsearch.php" data-event-click-tracking="TopNav|NavAdvancedSearch">Advanced Search</a>
        </div>
        </div>
        </search-menu>
        <desktop-subnav class="style-scope ia-topnav x-scope desktop-subnav-1"><!---->
          <ul class="style-scope desktop-subnav">
            <!--?lit$49386103$--><!---->
            <li class="style-scope desktop-subnav">
        <a class="about style-scope desktop-subnav" href="https://archive.org/about/"><!--?lit$49386103$-->About<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="blog style-scope desktop-subnav" href="https://blog.archive.org/"><!--?lit$49386103$-->Blog<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="events style-scope desktop-subnav" href="https://archive.org/events"><!--?lit$49386103$-->Events<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="projects style-scope desktop-subnav" href="https://archive.org/projects/"><!--?lit$49386103$-->Projects<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="help style-scope desktop-subnav" href="https://archive.org/about/faqs.php"><!--?lit$49386103$-->Help<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="donate style-scope desktop-subnav" href="https://archive.org/donate?origin=iawww-TopNavDonateButton"><!--?lit$49386103$-->Donate<!--?lit$49386103$-->
          <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg" aria-labelledby="donateTitleID donateDescID" class="style-scope desktop-subnav">
            <title id="donateTitleID" class="style-scope desktop-subnav">Donate icon</title>
            <desc id="donateDescID" class="style-scope desktop-subnav">An illustration of a heart shape</desc>
            <path class="fill-color style-scope desktop-subnav" d="m30.0120362 11.0857287c-1.2990268-1.12627221-2.8599641-1.65258786-4.682812-1.57894699-.8253588.02475323-1.7674318.3849128-2.8262192 1.08047869-1.0587873.6955659-1.89622 1.5724492-2.512298 2.63065-.591311-1.0588196-1.4194561-1.9357029-2.4844351-2.63065-1.0649791-.69494706-2.0039563-1.05510663-2.8169316-1.08047869-1.2067699-.04950647-2.318187.17203498-3.3342513.66462439-1.0160643.4925893-1.82594378 1.2002224-2.42963831 2.1228992-.60369453.9226769-.91173353 1.9629315-.92411701 3.1207641-.03715043 1.9202322.70183359 3.7665141 2.21695202 5.5388457 1.2067699 1.4035084 2.912594 3.1606786 5.1174721 5.2715107 2.2048782 2.1108321 3.7565279 3.5356901 4.6549492 4.2745742.8253588-.6646243 2.355647-2.0647292 4.5908647-4.2003145s3.9747867-3.9171994 5.218707-5.3448422c1.502735-1.7723316 2.2355273-3.6186135 2.1983769-5.5388457-.0256957-1.7608832-.6875926-3.2039968-1.9866194-4.3302689z">
            </path>
            </svg>
            </a>
            </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="contact style-scope desktop-subnav" href="https://archive.org/about/contact"><!--?lit$49386103$-->Contact<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="jobs style-scope desktop-subnav" href="https://archive.org/about/jobs"><!--?lit$49386103$-->Jobs<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
      <li class="style-scope desktop-subnav">
        <a class="volunteer style-scope desktop-subnav" href="https://archive.org/about/volunteer-positions"><!--?lit$49386103$-->Volunteer<!--?lit$49386103$--><!--?--></a>
        </li>
      <!----><!---->
    </ul>
    </desktop-subnav>
    <div id="close-layer" class="style-scope ia-topnav"></div>
    </ia-topnav>
                  </div>
            <input class="js-tvsearch" type="hidden" value="{&quot;ands&quot;:[],&quot;minday&quot;:&quot;06/04/2009&quot;,&quot;maxday&quot;:&quot;11/21/2025&quot;}">
    
        <!-- Begin page content -->
        <main id="maincontent">
          <div class="container container-ia">

                  <h1>
          Full text of "<a href="https://archive.org/details/hackingciphers">Hacking Secret Ciphers With Python</a>"
        </h1>
        <h2 class="pull-right">
          <small><a href="https://archive.org/details/hackingciphers">See other formats</a></small>
        </h2>
        <br class="clearfix" clear="right">
      <pre>Hacking Secret 
Ciphers with Python 



By Al Sweigart 



Copyright ¬© 2013 by Al Sweigart 



Some Rights Reserved. "Hacking Secret Ciphers with Python" is licensed under a Creative 
Commons Attribution-Noncommercial-Share Alike 3.0 United States License. 

You are free: 

To Share ‚Äî to copy, distribute, display, and perform the work 

To Remix ‚Äî to make derivative works 
Under the following conditions: 

Attribution ‚Äî You must attribute the work in the manner specified by the author or 
licensor (but not in any way that suggests that they endorse you or your use of the work). 
(Visibly include the title and author's name in any excerpts of this work.) 

Noncommercial ‚Äî You may not use this work for commercial purposes. 

Share Alike ‚Äî If you alter, transform, or build upon this work, you may distribute 
the resulting work only under the same or similar license to this one. 

This summary is located here: ht^://creatiy Your fair use and other rights are 

in no way affected by the above. There is a human-readable summary of the Legal Code (the full license), located here: 
http.://creativecprrmpns^ 

Book Version 3 

Special thanks to Ari Lacenski. I can't thank her enough. Without her efforts there'd be typos literally on every page. 

Thanks to Jason Kibbe. Cover lock photo by "walknboston" http://www.flickr.com/photos/walkn/3859852351/ Romeo 
&amp; Juliet and other public domain texts from Project Gutenberg. Various image resources from Wikipedia. Wrinkled 
paper texture by Pink Sherbet Photography http://www.flickr.com/photos/pinksherbet/2978651767/ Computer User 
icon by Katzenbaer. 

If you've downloaded this book from a torrent, it's probably out of date. Go 
to http://inventwithpython.com/hacking to download the latest version. 

ISBN 978-1482614374 
1st Edition 









Nedroid Picture Diary by Anthony Clark, http://nedrpid.com 



Movies and TV shows always make hacking look exciting with furious typing and meaningless 
ones and zeros flying across the screen. They make hacking look like something that you have to 
be super smart to learn. They make hacking look like magic. 

It's not magic. It's based on computers, and everything computers do have logical 
principles behind them which can be learned and understood. Even when you don't 
understand or when the computer does something frustrating or mysterious, there is always, 
always, always a reason why. 

And it's not hard to learn. This book assumes you know nothing about cryptography or 
programming, and helps you learn, step by step, how to write programs that can hack encrypted 
messages. Good luck and have fun! 



100% of the profits from this book are donated 
to the Electronic Frontier Foundation, the Creative Commons, and the Tor Project. 



Dedicated to Aaron Swartz, 1986 - 2013 



"Aaron was part of an army of citizens that believes democracy 
only works when the citizenry are informed, when we know about 
our rights ‚Äî and our obligations. An army that believes we must 
make justice and knowledge available to all ‚Äî not just the well born 
or those that have grabbed the reins of power ‚Äî so that we may 
govern ourselves more wisely. 

When I see our army, I see Aaron Swartz and my heart is broken. 
We have truly lost one of our better angels." 



-CM. 



About This Book 



There are many books that teach beginners how to write secret messages using ciphers. There are 
a couple books that teach beginners how to hack ciphers. As far as I can tell, there are no books to 
teach beginners how to write programs to hack ciphers. This book fills that gap. 

This book is for complete beginners who do not know anything about encryption, hacking, or 
cryptography. The ciphers in this book (except for the RSA cipher in the last chapter) are all 
centuries old, and modern computers now have the computational power to hack their encrypted 
messages. No modern organization or individuals use these ciphers anymore. As such, there's no 
reasonable context in which you could get into legal trouble for the information in this book. 

This book is for complete beginners who have never programmed before. This book teaches basic 
programming concepts with the Python programming language. Python is the best language for 
beginners to learn programming: it is simple and readable yet also a powerful programming 
language used by professional software developers. The Python software can be downloaded for 
free from http://python,prg and runs on Linux, Windows, OS X, and the Raspberry Pi. 

There are two definitions of "hacker". A hacker is a person who studies a system (such as the 
rules of a cipher or a piece of software) to understand it so well that they are not limited by the 
original rules of that system and can creatively modify it to work in new ways. "Hacker" is also 
used to mean criminals who break into computer systems, violate people's privacy, and cause 
damage. This book uses "hacker" in the first sense. Hackers are cool. Criminals are just people 
who think they're being clever by breaking stuff. Personally, my day job as a software 
developer pays me way more for less work than writing a virus or doing an Internet scam would. 

On a side note, don't use any of the encryption programs in this book for your actual files. 
They're fun to play with but they don't provide true security. And in general, you shouldn't trust 
the ciphers that you yourself make. As legendary cryptographer Bruce Schneier put it, "Anyone, 
from the most clueless amateur to the best cryptographer, can create an algorithm that he himself 
can't break. It's not even hard. What is hard is creating an algorithm that no one else can break, 
even after years of analysis. And the only way to prove that is to subject the algorithm to years of 
analysis by the best cryptographers around." 

This book is released under a Creative Commons license and is free to copy and distribute (as 
long as you don't charge money for it). The book can be downloaded for free from its website at 
http;//inyentw^ If you ever have questions about how these programs work, 

feel free to email me at al@inventwithpython.com. 



Table of Contents 



About This Book 6 

Table of Contents 7 

Chapter 1 - Making Paper Cryptography Tools 1 

What is Cryptography? 2 

Codes vs. Ciphers 3 

Making a Paper Cipher Wheel 4 

A Virtual Cipher Wheel 7 

How to Encrypt with the Cipher Wheel 8 

How to Decrypt with the Cipher Wheel 9 

A Different Cipher Tool: The St. Cyr Slide 10 

Practice Exercises, Chapter 1, Set A 11 

Doing Cryptography without Paper Tools 11 

Practice Exercises, Chapter 1, Set B 13 

Double-Strength Encryption? 13 

Programming a Computer to do Encryption 14 

Chapter 2 - Installing Python 16 

Downloading and Installing Python 17 

Downloading pyperclip.py 18 

Starting IDLE 18 

The Featured Programs 19 

Line Numbers and Spaces 20 

Text Wrapping in This Book 20 

Tracing the Program Online 21 

Checking Your Typed Code with the Online Diff Tool 21 

Copying and Pasting Text 21 

More Info Links 22 

Programming and Cryptography 22 

Chapter 3 - The Interactive Shell 26 

Some Simple Math Stuff 26 

Integers and Floating Point Values 27 



Expressions 27 

Order of Operations 28 

Evaluating Expressions 29 

Errors are Okay! 29 

Practice Exercises, Chapter 3, Set A 30 

Every Value has a Data Type 30 

Storing Values in Variables with Assignment Statements 30 

Overwriting Variables 32 

Using More Than One Variable 33 

Variable Names 34 

Practice Exercises, Chapter 3, Set B 35 

Summary - But When Are We Going to Start Hacking? 35 

Chapter 4 - Strings and Writing Programs 36 

Strings 36 

String Concatenation with the + Operator 38 

String Replication with the * Operator 39 

Printing Values with the print ( ) Function 39 

Escape Characters 40 

Quotes and Double Quotes 41 

Practice Exercises, Chapter 4, Set A 42 

Indexing 42 

Negative Indexes 44 

Slicing 44 

Blank Slice Indexes 45 

Practice Exercises, Chapter 4, Set B 46 

Writing Programs in IDLE's File Editor 46 

Hello World! 47 

Source Code of Hello World 47 

Saving Your Program 48 

Running Your Program 49 

Opening The Programs You've Saved 50 

How the "Hello World" Program Works 50 

Comments 50 

Functions 51 



The print () function 51 

The input ( ) function 51 

Ending the Program 52 

Practice Exercises, Chapter 4, Set C 52 

Summary 53 

Chapter 5 - The Reverse Cipher 54 

The Reverse Cipher 54 

Source Code of the Reverse Cipher Program 55 

Sample Run of the Reverse Cipher Program 55 

Checking Your Source Code with the Online Diff Tool 56 

How the Program Works 56 

The len ( ) Function 57 

Introducing the while Loop 58 

The Boolean Data Type 59 

Comparison Operators 59 

Conditions 62 

Blocks 62 

The while Loop Statement 63 

"Growing" a String 64 

Tracing Through the Program, Step by Step 67 

Using input ( ) In Our Programs 68 

Practice Exercises, Chapter 5, Section A 69 

Summary 69 

Chapter 6 - The Caesar Cipher 70 

Implementing a Program 70 

Source Code of the Caesar Cipher Program 71 

Sample Run of the Caesar Cipher Program 72 

Checking Your Source Code with the Online Diff Tool 73 

Practice Exercises, Chapter 6, Set A 73 

How the Program Works 73 

Importing Modules with the import Statement 73 

Constants 74 

The upper ( ) and lower ( ) String Methods 75 



The for Loop Statement 76 

A while Loop Equivalent of a for Loop 77 

Practice Exercises, Chapter 6, Set B 78 

The if Statement 78 

The else Statement 79 

The elif Statement 79 

The in and not in Operators 80 

The find ( ) String Method 81 

Practice Exercises, Chapter 6, Set C 82 

Back to the Code 82 

Displaying and Copying the Encrypted/Decrypted String 85 

Encrypt Non-Letter Characters 86 

Summary 87 

Chapter 7 - Hacking the Caesar Cipher with the Brute-Force Technique 88 

Hacking Ciphers 88 

The Brute-Force Attack 89 

Source Code of the Caesar Cipher Hacker Program 89 

Sample Run of the Caesar Cipher Hacker Program 90 

How the Program Works 91 

The range ( ) Function 91 

Back to the Code 93 

String Formatting 94 

Practice Exercises, Chapter 7, Set A 95 

Summary 95 

Chapter 8 - Encrypting with the Transposition Cipher 96 

Encrypting with the Transposition Cipher 96 

Practice Exercises, Chapter 8, Set A 98 

A Transposition Cipher Encryption Program 98 

Source Code of the Transposition Cipher Encryption Program 98 

Sample Run of the Transposition Cipher Encryption Program 99 

How the Program Works 100 

Creating Your Own Functions with def Statements 100 

The Program's main ( ) Function 101 



Parameters 102 

Variables in the Global and Local Scope 104 

The global Statement 104 

Practice Exercises, Chapter 8, Set B 106 

The List Data Type 106 

Using the list ( ) Function to Convert Range Objects to Lists 109 

Reassigning the Items in Lists 110 

Reassigning Characters in Strings 110 

Lists of Lists 110 

Practice Exercises, Chapter 8, Set C Ill 

Using len ( ) and the in Operator with Lists Ill 

List Concatenation and Replication with the + and * Operators 112 

Practice Exercises, Chapter 8, Set D 113 

The Transposition Encryption Algorithm 113 

Augmented Assignment Operators 115 

Back to the Code 116 

The j oin ( ) String Method 118 

Return Values and return Statements 119 

Practice Exercises, Chapter 8, Set E 120 

Back to the Code 120 

The Special name Variable 120 

Key Size and Message Length 121 

Summary 122 

Chapter 9 - Decrypting with the Transposition Cipher 123 

Decrypting with the Transposition Cipher on Paper 124 

Practice Exercises, Chapter 9, Set A 125 

A Transposition Cipher Decryption Program 126 

Source Code of the Transposition Cipher Decryption Program 126 

How the Program Works 127 

The math . ceil (), math . floor ( ) and round () Functions 128 

The and and or Boolean Operators 132 

Practice Exercises, Chapter 9, Set B 133 

Truth Tables 133 



The and and or Operators are Shortcuts 134 

Order of Operations for Boolean Operators 135 

Back to the Code 135 

Practice Exercises, Chapter 9, Set C 137 

Summary 137 

Chapter 10 - Programming a Program to Test Our Program 138 

Source Code of the Transposition Cipher Tester Program 139 

Sample Run of the Transposition Cipher Tester Program 140 

How the Program Works 141 

Pseudorandom Numbers and the random . seed ( ) Function 141 

The random, randint ( ) Function 143 

References 143 

The copy . deepcopy ( ) Functions 147 

Practice Exercises, Chapter 10, Set A 148 

The random, shuffle ( ) Function 148 

Randomly Scrambling a String 149 

Back to the Code 149 

The sys . exit ( ) Function 150 

Testing Our Test Program 151 

Summary 152 

Chapter 11 - Encrypting and Decrypting Files 153 

Plain Text Files 154 

Source Code of the Transposition File Cipher Program 154 

Sample Run of the Transposition File Cipher Program 157 

Reading From Files 157 

Writing To Files 158 

How the Program Works 159 

The os . path . exists ( ) Function 160 

The startswith ( ) and endswith ( ) String Methods 161 

The title ( ) String Method 162 

The time Module and time . time ( ) Function 163 

Back to the Code 164 

Practice Exercises, Chapter 11, Set A 165 



Summary 165 

Chapter 12 - Detecting English Programmatically 166 

How Can a Computer Understand English? 167 

Practice Exercises, Chapter 12, Section A 169 

The Detect English Module 169 

Source Code for the Detect English Module 169 

How the Program Works 170 

Dictionaries and the Dictionary Data Type 171 

Adding or Changing Items in a Dictionary 172 

Practice Exercises, Chapter 12, Set B 173 

Using the len ( ) Function with Dictionaries 173 

Using the in Operator with Dictionaries 173 

Using for Loops with Dictionaries 174 

Practice Exercises, Chapter 12, Set C 174 

The Difference Between Dictionaries and Lists 174 

Finding Items is Faster with Dictionaries Than Lists 175 

The split () Method 175 

The None Value 176 

Back to the Code 177 

"Divide by Zero" Errors 179 

The float ( ) , int ( ) , and str ( ) Functions and Integer Division 179 

Practice Exercises, Chapter 12, Set D 180 

Back to the Code 180 

The append() List Method 182 

Default Arguments 183 

Calculating Percentage 184 

Practice Exercises, Chapter 12, Set E 185 

Summary 186 

Chapter 13 - Hacking the Transposition Cipher 187 

Source Code of the Transposition Cipher Hacker Program 187 

Sample Run of the Transposition Breaker Program 189 

How the Program Works 190 

Multi-line Strings with Triple Quotes 190 



Back to the Code 191 

The strip ( ) String Method 193 

Practice Exercises, Chapter 13, Set A 195 

Summary 195 

Chapter 14 - Modular Arithmetic with the Multiplicative and Affine Ciphers 196 

Oh No Math! 197 

Math Oh Yeah! 197 

Modular Arithmetic (aka Clock Arithmetic) 197 

The % Mod Operator 199 

Practice Exercises, Chapter 14, Set A 199 

CCD: Greatest Common Divisor (aka Greatest Common Factor) 199 

Visualize Factors and GCD with Cuisenaire Rods 200 

Practice Exercises, Chapter 14, Set B 202 

Multiple Assignment 202 

Swapping Values with the Multiple Assignment Trick 203 

Euclid's Algorithm for Finding the GCD of Two Numbers 203 

"Relatively Prime" 205 

Practice Exercises, Chapter 14, Set C 205 

The Multiplicative Cipher 205 

Practice Exercises, Chapter 14, Set D 207 

Multiplicative Cipher + Caesar Cipher = The Affine Cipher 207 

The First Affine Key Problem 207 

Decrypting with the Affine Cipher 208 

Finding Modular Inverses 209 

The / / Integer Division Operator 210 

Source Code of the cryptomath Module 210 

Practice Exercises, Chapter 14, Set E 211 

Summary 211 

Chapter 15 - The Affine Cipher 213 

Source Code of the Affine Cipher Program 214 

Sample Run of the Affine Cipher Program 216 

Practice Exercises, Chapter 15, Set A 216 

How the Program Works 216 

Splitting One Key into Two Keys 218 



The Tuple Data Type 218 

Input Validation on the Keys 219 

The Affine Cipher Encryption Function 220 

The Affine Cipher Decryption Function 221 

Generating Random Keys 222 

The Second Affine Key Problem: How Many Keys Can the Affine Cipher Have? 223 

Summary 225 

Chapter 16 - Hacking the Affine Cipher 226 

Source Code of the Affine Cipher Hacker Program 226 

Sample Run of the Affine Cipher Hacker Program 228 

How the Program Works 228 

The Affine Cipher Hacking Function 230 

The * * Exponent Operator 230 

The continue Statement 231 

Practice Exercises, Chapter 16, Set A 234 

Summary 234 

Chapter 17 - The Simple Substitution Cipher 235 

The Simple Substitution Cipher with Paper and Pencil 236 

Practice Exercises, Chapter 17, Set A 236 

Source Code of the Simple Substitution Cipher 237 

Sample Run of the Simple Substitution Cipher Program 239 

How the Program Works 239 

The Program's main ( ) Function 240 

The sort ( ) List Method 241 

Wrapper Functions 242 

The Program's translateMessage ( ) Function 243 

The i supper ( ) and i slower ( ) String Methods 245 

Practice Exercises, Chapter 17, Set B 247 

Generating a Random Key 247 

Encrypting Spaces and Punctuation 248 

Practice Exercises, Chapter 17, Set C 249 

Summary 249 

Chapter 18 - Hacking the Simple Substitution Cipher 250 



Computing Word Patterns 251 

Getting a List of Candidates for a Cipherword 252 

Practice Exercises, Chapter 18, Set A 253 

Source Code of the Word Pattern Module 253 

Sample Run of the Word Pattern Module 255 

How the Program Works 256 

The ppr int . pprint ( ) and pprint . pf ormat ( ) Functions 256 

Building Strings in Python with Lists 257 

Calculating the Word Pattern 258 

The Word Pattern Program's main ( ) Function 259 

Hacking the Simple Substitution Cipher 262 

Source Code of the Simple Substitution Hacking Program 262 

Hacking the Simple Substitution Cipher (in Theory) 266 

Explore the Hacking Functions with the Interactive Shell 266 

How the Program Works 271 

Import All the Things 272 

A Brief Intro to Regular Expressions and the sub() Regex Method 272 

The Hacking Program's main ( ) Function 273 

Partially Hacking the Cipher 274 

Blank Cipherletter Mappings 275 

Adding Letters to a Cipherletter Mapping 276 

Intersecting Two Letter Mappings 277 

Removing Solved Letters from the Letter Mapping 278 

Hacking the Simple Substitution Cipher 281 

Creating a Key from a Letter Mapping 283 

Couldn't We Just Encrypt the Spaces Too? 285 

Summary 286 

Chapter 19 - The Vigenere Cipher 287 

Le Chiffre Indechiffrable 288 

Multiple "Keys" in the Vigenere Key 288 

Source Code of Vigenere Cipher Program 291 

Sample Run of the Vigenere Cipher Program 294 

How the Program Works 294 

Summary 298 



Chapter 20 - Frequency Analysis 299 

The Code for Matching Letter Frequencies 304 

How the Program Works 306 

The Most Common Letters, "ETAOIN" 307 

The Program's getLettersCount ( ) Function 307 

The Program's getltemAtlndexZero ( ) Function 308 

The Program's getFrequencyOrder ( ) Function 308 

The sort ( ) Method's key and reverse Keyword Arguments 310 

Passing Functions as Values 311 

Converting Dictionaries to Lists with the keys(), values(), items() Dictionary Methods 313 

Sorting the Items from a Dictionary 315 

The Program's englishFreqMatchScore () Function 316 

Summary 317 

Chapter 21 - Hacking the Vigenere Cipher 318 

The Dictionary Attack 319 

Source Code for a Vigenere Dictionary Attack Program 319 

Sample Run of the Vigenere Dictionary Hacker Program 320 

Thereadlines () File Object Method 321 

The Babbage Attack &amp; Kasiski Examination 321 

Kasiski Examination, Step 1 - Find Repeat Sequences' Spacings 321 

Kasiski Examination, Step 2 - Get Factors of Spacings 322 

Get Every Nth Letters from a String 323 

Frequency Analysis 323 

Brute-Force through the Possible Keys 325 

Source Code for the Vigenere Hacking Program 326 

Sample Run of the Vigenere Hacking Program 332 

How the Program Works 334 

Finding Repeated Sequences 335 

Calculating Factors 337 

Removing Duplicates with the set() Function 338 

The Kasiski Examination Algorithm 341 

The extend ( ) List Method 342 

The end Keyword Argument for print ( ) 347 



The itertools .product ( ) Function 348 

The break Statement 352 

Practice Exercises, Chapter 21, Set A 354 

Modifying the Constants of the Hacking Program 354 

Summary 355 

Chapter 22 - The One-Time Pad Cipher 356 

The Unbreakable One-Time Pad Cipher 357 

Why the One-Time Pad is Unbreakable 357 

Beware Pseudorandomness 358 

Beware the Two-Time Pad 358 

The Two-Time Pad is the Vigenere Cipher 359 

Practice Exercises, Chapter 22, Set A 360 

Summary 360 

Chapter 23 - Finding Prime Numbers 361 

Prime Numbers 362 

Composite Numbers 363 

Source Code for The Prime Sieve Module 363 

How the Program Works 364 

How to Calculate if a Number is Prime 365 

The Sieve of Eratosthenes 366 

The primeSieve ( ) Function 368 

Detecting Prime Numbers 369 

Source Code for the Rabin-Miller Module 370 

Sample Run of the Rabin Miller Module 372 

How the Program Works 372 

The Rabin-Miller Primality Algorithm 372 

The New and Improved isPrime ( ) Function 373 

Summary 375 

Chapter 24 - Public Key Cryptography and the RSA Cipher 378 

Public Key Cryptography 379 

The Dangers of "Textbook" RSA 381 

A Note About Authentication 381 

The Man-In-The-Middle Attack 382 



Generating Public and Private Keys 383 

Source Code for the RS A Key Generation Program 383 

Sample Run of the RSA Key Generation Program 385 

How the Key Generation Program Works 386 

The Program's generateKey ( ) Function 387 

RSA Key File Format 390 

Hybrid Cryptosystems 391 

Source Code for the RSA Cipher Program 391 

Sample Run of the RSA Cipher Program 395 

Practice Exercises, Chapter 24, Set A 397 

Digital Signatures 397 

How the RSA Cipher Program Works 398 

ASCII: Using Numbers to Represent Characters 400 

The chr ( ) and ord ( ) Functions 400 

Practice Exercises, Chapter 24, Set B 401 

Blocks 401 

Converting Strings to Blocks with getBlocksFromText ( ) 404 

The encode ( ) String Method and the Bytes Data Type 405 

The bytes ( ) Function and decode ( ) Bytes Method 405 

Practice Exercises, Chapter 24, Set C 406 

Back to the Code 406 

The min ( ) and max ( ) Functions 407 

The insert () List Method 410 

The Mathematics of RSA Encrypting and Decrypting 41 1 

The pow ( ) Function 411 

Reading in the Public &amp; Private Keys from their Key Files 413 

The Full RSA Encryption Process 413 

The Full RSA Decryption Process 416 

Practice Exercises, Chapter 24, Set D 418 

Why Can't We Hack the RSA Cipher 418 

Summary 420 

About the Author 422 



Chapter 1 - Making Paper Cryptography Tools 1 



Chapter 1 

Making Paper 
Cryptography Tools 

Topics Covered In This Chapter: 

‚Ä¢ What is cryptography? 

‚Ä¢ Codes and ciphers 

‚Ä¢ The Caesar cipher 

‚Ä¢ Cipher wheels 

‚Ä¢ St. Cyr slides 

‚Ä¢ Doing cryptography with paper and pencil 

‚Ä¢ "Double strength" encryption 



"I couldn't help but overhear, probably because I 
was eavesdropping." 

Anonymous 




2 http://inventwithpython.com/hacking 



What is Cryptography? 



Look at the following two pieces of text: 



"Zsijwxyfsi niqjsjxx gjyyjw. Ny 
nx jnymjw ktqqd tw bnxitr; ny 
nx anwyzj ns bjfqym fsi anhj ns 
utajwyd. Ns ymj bnsyjw tk tzw 
qnkj, bj hfs jsotd ns u j f h j ymj 



"Flwyt tsytbbnz jqtw yjxndwri 
iyn fqq knqrqt xj mh ndyn 
jxwqswbj. Dyi jjkxxx sg ttwt 
gdhz js jwsn; wnjyiyb aijnn 
snagdqt nnjwww, xstsxsu jdnxzz 
xkw znfs uwwh xni xjzw jzwyjy 
jwnmns mnyfjx. St j j wwzj ti 
fnu, qt uyko qqsbay jmwskj. 
Sxitwru nwnqn nxfzfbl yy 
hnwydsj mhnxytb myysyt." 



kwznyx bmnhm ns nyx xuwnsl tzw 
nsizxywd uqfsyji. Htzwynjwx tk 
lqtwd, bwnyjwx tw bfwwntwx, 



xqzrgjw nx ujwrnyyji dtz, gzy 
tsqd zuts qfzwjqx." 



The text on the left side is a secret message. The message has been encrypted, or turned into a 
secret code. It will be completely unreadable to anyone who doesn't know how to decrypt it 
(that is, turn it back into the plain English message.) This book will teach you how to encrypt and 
decrypt messages. 

The message on the right is just random gibberish with no hidden meaning whatsoever. 
Encrypting your written messages is one way to keep them secret from other people, even if they 
get their hands on the encrypted message itself. It will look exactly like random nonsense. 

Cryptography is the science of using secret codes. A cryptographer is someone who uses and 
studies secret codes. This book will teach you what you need to know to become a cryptographer. 

Of course, these secret messages don't always stay secret. A cryptanalyst is someone who can 
hack secret codes and read other people's encrypted messages. Cryptanalysts are also called code 
breakers or hackers. This book will also teach you what you need to know to become a 
cryptanalyst. Unfortunately the type of hacking you learn in this book isn't dangerous enough to 
get you in trouble with the law. (I mean, fortunately.) 

Spies, soldiers, hackers, pirates, royalty, merchants, tyrants, political activists, Internet shoppers, 
and anyone who has ever needed to share secrets with trusted friends have relied on cryptography 
to make sure their secrets stay secret. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 3 



Codes vs. Ciphers 

The development of the electric telegraph in the early 19 th century allowed for near-instant 
communication through wires across continents. This was much faster than sending a horseback 
rider carrying a bag of letters. However, the telegraph couldn't directly send written letters drawn 
on paper. Instead it could send electric pulses. A short pulse is called a "dot" and a long pulse is 
called a "dash". 





Figure 1-1. Samuel Morse 
April 27, 1791 -April 2, 1872 

In order to convert these dots and dashes to 
English letters of the alphabet, an encoding 
system (or code) is needed to translate from 
English to electric pulse code (called 
encoding) and at the other end translate 
electric pulses to English (called decoding). 
The code to do this over telegraphs (and later, 
radio) was called Morse Code, and was 
developed by Samuel Morse and Alfred Vail. 
By tapping out dots and dashes with a one- 
button telegraph, a telegraph operator could 
communicate an English message to someone 
on the other side of the world almost instantly! 
(If you'd like to learn Morse code, visit 
http;//inypy .conVmor se . ) 



Figure 1-2. Alfred Vail 
September 25, 1807 - January 18, 1859 



A 
B 
C 
D 
E 
F 
G 
H 
I 

J 

K 
L 
M 
N 
O 
P 
Q 
R 
S 



‚Äî ‚Ä¢ ‚Ä¢ ‚Ä¢ 

‚Äî ‚Ä¢ ‚Äî ‚Ä¢ 

‚Äî ‚Ä¢ ‚Ä¢ 

‚Ä¢ ‚Ä¢ ‚Äî ‚Ä¢ 

‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ 

‚Ä¢ ‚Äî ‚Ä¢ ‚Ä¢ 



‚Ä¢ ‚Äî ‚Ä¢ 

‚Ä¢ ‚Ä¢ ‚Ä¢ 



T 
U 
V 

w 

X 
Y 
Z 



1 

2 
3 
4 
5 
6 
7 
8 
9 
0 



‚Ä¢ ‚Ä¢ ‚Äî 

‚Ä¢ ‚Ä¢ ‚Ä¢ - 

‚Ä¢ ‚Äî ‚Äî 

‚Äî ‚Ä¢ ‚Ä¢ 

‚Äî ‚Ä¢ ‚Äî 



‚Ä¢ ‚Äî - 

‚Ä¢ ‚Ä¢ ‚Äî 

‚Ä¢ ‚Ä¢ ‚Ä¢ 



‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ 

‚Äî ‚Ä¢ ‚Ä¢ ‚Ä¢ 

‚Äî ‚Äî ‚Ä¢ ‚Ä¢ 



Figure 1-3. International Morse Code, with 
characters represented as dots and dashes. 



4 http://inventwithpython.com/hacking 



Codes are made to be understandable and publicly available. Anyone should be able to look 
up what a code's symbols mean to decode an encoded message. 

Making a Paper Cipher Wheel 

Before we learn how to program computers to do encryption and decryption for us, let's learn 
how to do it ourselves with simple paper tools. It is easy to turn the understandable English text 
(which is called the plaintext) into the gibberish text that hides a secret code (called the 
ciphertext). A cipher is a set of rules for converting between plaintext and ciphertext. These 
rules often use a secret key. We will learn several different ciphers in this book. 

Let's learn a cipher called the Caesar cipher. This cipher was used by Julius Caesar two thousand 
years ago. The good news is that it is simple and easy to learn. The bad news is that because it is 
so simple, it is also easy for a cryptanalyst to break it. But we can use it as a simple learning 
exercise. More information about the Caesar cipher is given on Wikipedia: 
http://en.wikipedia.prg/w 

To convert plaintext to ciphertext using the Caesar cipher, we will create something called a 
cipher wheel (also called a cipher disk). You can either photocopy the cipher wheel that 
appears in this book, or print out the one from http://iny^ Cut out the two 

circles and lay them on top of each other like in Figure 1-8. 



Email questions to the author: al@inventwithpython.com 




Figure 1-4. The inner circle of the cipher wheel cutout. 



6 http://inventwithpython.com/hacking 



c. 



LP 



6 



o 



N W 



-n 



CD 

5: 




Figure 1-5. The outer circle of the cipher wheel cutout. 



Don't cut out the page from this book! 
Just make a photocopy of this page or print it from http://inypy .com/ciphCT 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 7 




After you cut out the circles, place the smaller one in the middle of the larger one. Put a pin or 
brad through the center of both circles so you can spin them around in place. You now have a tool 
for creating secret messages with the Caesar cipher. 



A Virtual Cipher Wheel 

There is also a virtual cipher wheel online if you 
don't have scissors and a photocopier handy. 
Open a web browser to 

h|^.'/^ypy:CO^dphemheel to use the software 
version of the cipher wheel. 

To spin the wheel around, click on it with the 
mouse and then move the mouse cursor around 
until the key you want is in place. Then click the 
mouse again to stop the wheel from spinning. 




Figure 1-9. The online cipher wheel. 



8 http://inventwithpython.com/hacking 



How to Encrypt with the Cipher Wheel 

First, write out your message in English on paper. For this example we will encrypt the message, 
"The secret password is Rosebud." Next, spin the inner wheel around until its letters match up 
with letters in the outer wheel. Notice in the outer wheel there is a dot next to the letter A. Look at 
the number in the inner wheel next to the dot in the outer wheel. This number is known the 
encryption key. 

The encryption key is the secret to encrypting or decrypting the message. Anyone who reads this 
book can learn about the Caesar cipher, just like anyone who reads a book about locks can learn 
how a door lock works. But like a regular lock and key, unless they have the encryption key, they 
will not be able to unlock (that is, decrypt) the secret encrypted message. In Figure 1-9, the outer 
circle's A is over the inner circle's number 8. That means we will be using the key 8 to encrypt 
our message. The Caesar cipher uses the keys from 0 to 25. Let's use the key 8 for our example. 
Keep the encryption key a secret; the ciphertext can be read by anyone who knows that the 
message was encrypted with key 8. 



T 


H 


E 


S 


E 


C 


R 


E 


T 


P 


A 


s 


S 


W 


0 


R 


D 


I 


4 


4 


4 


4 


4 


4 


4 


4 


4 


4 


4 


I 


4 


4 


4 


4 


B 


p 


M 


A 


M 


K 


z 


M 


B 


X 


I 


A 


A 


E 


w 


z 


L 








I 


S 




R 


0 


S 


E B 


u 


D 


















I 


4 




4 


4 


4 


4 4 


4 


4 


















Q 


A 




z 


w 


A 


M J 


c 


L 













For each letter in our message, we will find where it is in the outer circle and replace it with the 
lined-up letter in the inner circle. The first letter in our message is T (the first "T" in "The 
secret. . ."), so we find the letter T in the outer circle, and then find the lined-up letter in the inner 
circle. This letter is B, so in our secret message we will always replace T's with B's. (If we were 
using some other encryption key besides 8, then the T's in our plaintext would be replaced with a 
different letter.) 

The next letter in our message is H, which turns into P. The letter E turns into M. When we have 
encrypted the entire message, the message has transformed from "The secret password is 
Rosebud." to "Bpm amkzmb xiaaewzl qa Zwamjcl." Now you can send this message to someone 
(or keep it written down for yourself) and nobody will be able to read it unless you tell them the 
secret encryption key (the number 8). 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 9 



Tke sec ret password. Is Rosebud.. 

\ . , . . . . 




Figure 1-10. A message encrypted with the cipher wheel. 

Each letter on the outer wheel will always be encrypted to the same letter on the inner wheel. To 
save time, after you look up the first T in "The secret. . ." and see that it encrypts to B, you can 
replace every T in the message with B. This way you only need to look up a letter once. 

How to Decrypt with the Cipher Wheel 

To decrypt a ciphertext, go from the inner circle to the outer circle. Let's say you receive this 
ciphertext from a friend, "Iwt ctl ephhldgs xh Hldgsuxhw." You and everyone else won't be able 
to decrypt it unless you know the key (or unless you are a clever hacker). But your friend has 
decided to use the key 15 for each message she sends you. 

Line up the letter A on the outer circle (the one with the dot below it) over the letter on the inner 
circle that has the number 15 (which is the letter P). The first letter in the secret message is I, so 
we find I on the inner circle and look at the letter next to it on the outer circle, which is T. The W 
in the ciphertext will decrypt to the letter H. One by one, we can decrypt each letter in the 
ciphertext back to the plaintext, "The new password is Swordfish." 



I 


W 


T 


C 


T 


L 


E 


P 


H 


H 


L 


D 


G 


S 


I 


I 


I 


I 


I 


I 


1 


I 


I 


I 


4 


I 


I 


I 


T 


H 


E 


N 


E 


W 


P 


A 


S 


S 


w 


0 


R 


D 



XH HLDGSUXHW 
IS SWORDFISH 



If we use an incorrect key like 16 instead of the correct key 15, the decrypted message is "Sgd 
mdv ozrrvnqc hr Rvnqcehrg." This plaintext doesn't look plain at all. Unless the correct key is 
used, the decrypted message will never be understandable English. 



10 http://inventwithpython.com/hacking 



A Different Cipher Tool: The St. Cyr Slide 

There's another paper tool that can be used to do encryption and 
decryption, called the St. Cyr slide. It's like the cipher wheel 
except in a straight line. 



LT) 

(Nl 


N 




"nT 

(Nl 


&gt; 




ro 

(Nl 


X 




(NJ 
(Nl 


3 




rH 

(Nl 


&gt; 




o 

(Nl 


=&gt; 




CTi 
rH 


1- 




CO 
rH 


(/) 




r^- 
rH 






rH 


a 




i_n 
rH 






rH 


o 




ro 
rH 


z 




(Nl 
rH 






rH 
rH 






o 

rH 






en 


n 




00 


H 




N. 


X 




ID 






L/1 


ll 






LU 




m 


Q 




(Nl 


u 




rH 


CD 




o 


&lt; 





Figure 1-11. Photocopy 
these strips to make a St. 
Cyr Slide. 



Photocopy the image of the St. Cyr slide on the following page (or 
print it out from http://inypy.conystcyrshde and cut out the three 
strips. 

Tape the two alphabet strips together, with the black box A next to 
the white box Z on the other strip. Cut out the slits on either side of 
the main slide box so that the taped-together strip can feed through 
it. It should look like this: 




Figure 1-12. The completed St. Cyr Slide 

When the black box A is underneath the letter H (and the number 
7), then to encrypt you must find where the plaintext letter is on 
the long strip, and replace it with the letter above it. To decrypt, 
find the ciphertext letter on the top row of letters and replace it 
with the letter on the long strip below it. 

The two slits on the larger box will hide any extra letters so that 
you only see one of each letter on the slide for any key. 

The benefit of the St. Cyr slide is that it might be easier to find the 
letters you are looking for, since they are all in a straight line and 
will never be upside down like they sometimes are on the cipher 
wheel. 

A virtual and printable St. Cyr slide can be found at 
http;//inyp 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 1 1 

Practice Exercises, Chapter 1, Set A 

Practice exercises can be found at ht^://invpxAQr^^J^^ra^celA. 

Don't ignore the practice exercises! 

There isn't enough room in this book to put in all the practice 
exercises, but they're still important. 

You don't become a hacker by just reading about hacking and 
programming. You have to actually do it! 

Doing Cryptography without Paper Tools 

The cipher wheel and St. Cyr slide are nice tools to do encryption and decryption with the Caesar 
cipher. But we can implement the Caesar cipher with just pencil and paper. 

Write out the letters of the alphabet from A to Z with the numbers from 0 to 25 under each letter. 
0 goes underneath the A, 1 goes under the B, and so on until 25 is under Z. (There are 26 letters 
in the alphabet, but our numbers only go up to 25 because we started at 0, not 1.) It will end up 
looking something like this: 



A 


B 


C 


D 


E 


F 


G 


H 


I 


J 


K 


L 


M 


0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


10 


11 


12 


N 


O 


P 


Q 


R 


S 


T 


U 


V 


W 


X 


Y 


Z 


13 


14 


15 


16 


17 


18 


19 


20 


21 


22 


23 


24 


25 



With the above letters -to-numbers code, we can use numbers to represent letters. This is a very 
powerful concept, because math uses numbers. Now we have a way to do math on letters. 

Now to encrypt we find the number under the letter we wish to encrypt and add the key number 
to it. This sum will be the number under the encrypted letter. For example, we encrypt, "Hello. 
How are you?" with the key 13. First we find the number under the H, which is 7. Then we add 
the key to this number. 7 + 13 = 20. The number 20 is under the letter U, which means the letter 
H encrypts to the letter U. To encrypt the letter E, we add the 4 under E to 13 to get 17. The 
number above 17 is R, so E gets encrypted to R. And so on. 

This works fine until we get to the letter O. The number under O is 14. But when we add 14+13 
we get 27. But our list of numbers only goes up to 25. If the sum of the letter's number and the 



12 http://inventwithpython.com/hacking 



key is 26 or more, we should subtract 26 from it. So 27 - 26 is 1. The letter above the number 1 is 
B. So the letter O encrypts to the letter B when we are using the key 13. One by one, we can then 
encrypt the letters in, "Hello. How are you?" to "Uryyb. Ubj ner lbh?" 

So the steps to encrypt a letter are: 

1. Decide on a key from 1 to 25. Keep this key secret! 

2. Find the plaintext letter's number. 

3. Add the key to the plaintext letter's number. 

4. If this number is larger than 26, subtract 26. 

5. Find the letter for the number you've calculated. This is the ciphertext letter. 

6. Repeat steps 2 to 5 for every letter in the plaintext message. 

Look at the following table to see how this is done with each letter in "Hello. How are you?" with 
key 13. Each column shows the steps for turning the plaintext letter on the left to the ciphertext 
letter on the right. 



Table 1-1. The steps to encrypt "Hello. How are you?" with paper and pencil. 



Plaintext 
Letter 


Plaintext 
Number 


+ 


Key 


Result 


Subtract 
26? 


Result 


Ciphertext 
Letter 


H 


7 


+ 


13 


= 20 




= 20 


20 = U 


E 


4 


+ 


13 


= 17 




= 17 


17 = R 


L 


11 


+ 


13 


= 24 




= 24 


24 = Y 


L 


11 


+ 


13 


= 24 




= 24 


24 = Y 


0 


14 


+ 


13 


= 27 


-26 


= 1 


1 =B 


H 


7 


+ 


13 


= 20 




= 20 


20 = U 


0 


14 


+ 


13 


= 27 


-26 


= 1 


1 =B 


W 


22 


+ 


13 


= 35 


-26 


= 9 


9 = J 


A 


0 


+ 


13 


= 13 




= 13 


13 = N 


R 


17 


+ 


13 


= 30 


-26 


= 4 


4 = E 


E 


4 


+ 


13 


= 17 




= 17 


17 = R 


Y 


24 


+ 


13 


= 37 


-26 


= 11 


11 =L 


0 


14 


+ 


13 


= 27 


-26 


= 1 


1 =B 


u 


20 


+ 


13 


= 33 


-26 


= 7 


7 = H 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 13 



To decrypt, you will have to understand what negative numbers are. If you don't know how to 
add and subtract with negative numbers, there is a tutorial on it here: http;//mypy.cpm/neg. 

To decrypt, subtract the key instead of adding it. For the ciphertext letter B, the number is 1. 
Subtract 1 - 13 to get -12. Like our "subtract 26" rule for encrypting, when we are decrypting and 
the result is less than 0, we have an "add 26" rule. -12 + 26 is 14. So the ciphertext letter B 
decrypts back to letter O. 



Table 1-2. The steps to decrypt the ciphertext with paper and pencil. 



Ciphertext 
Letter 


Ciphertext - 
Number 


Key 


Result 


Add 

Zo; 


Result 


Plaintext 
Letter 


T T 
U 


21) 


1 1 

13 


‚Äî / 




= / 


/ ‚Äî H 


rv 


17 




‚Äî 4 




‚Äî 4 


4 - F 

*T L/ 


Y 


24 


13 


= 11 




= 11 


11 =L 


Y 


24 


13 


= 11 




= 11 


11 =L 


B 


1 


13 


= -12 


+ 26 


= 14 


14 = 0 


U 


20 


13 


= 7 




= 7 


7 = H 


B 


1 


13 


= -12 


+ 26 


= 14 


14 = 0 


J 


9 


13 


= -4 


+ 26 


= 22 


22 = W 


N 


13 


13 


= 0 




= 0 


0 = A 


E 


4 


13 


= -9 


+ 26 


= 17 


17 = R 


R 


17 


13 


= 4 




= 4 


4 = E 


L 


11 


13 


= -2 


+ 26 


= 24 


24 = Y 


B 


1 


13 


= -12 


+ 26 


= 14 


14 = 0 


H 


7 


13 


= -6 


+ 26 


= 20 


20 = U 



As you can see, we don't need an actual cipher wheel to do the Caesar cipher. If you memorize 
the numbers and letters, then you don't even need to write out the alphabet with the numbers 
under them. You could just do some simple math in your head and write out secret messages. 

Practice Exercises, Chapter 1, Set B 

Practice exercises can be found at http://inypy.co^ 

Double-Strength Encryption? 

You might think that encrypting a message twice with two different keys would double the 
strength of our encryption. But this turns out not to be the case with the Caesar cipher (and most 
other ciphers). Let's try double-encrypting a message to see why. 



1 4 http ://inventwithpy thon. com/hacking 



If we encrypt the word "KITTEN" with the key 3, the resulting cipher text would be 
"NLWWHQ". If we encrypt the word "NLWWHQ" with the key 4, the resulting cipher text of 
that would be "RPAALU". But this is exactly the same as if we had encrypted the word 
"KITTEN" once with a key of 7. Our "double" encryption is the same as normal encryption, so it 
isn't any stronger. 

The reason is that when we encrypt with the key 3, we are adding 3 to plaintext letter's number. 
Then when we encrypt with the key 4, we are adding 4 to the plaintext letter's number. But 
adding 3 and then adding 4 is the exact same thing as adding 7. Encrypting twice with keys 3 and 
4 is the same as encrypting once with the key 7. 

For most encryption ciphers, encrypting more than once does not provide additional 
strength to the cipher. In fact, if you encrypt some plaintext with two keys that add up to 26, the 
ciphertext you end up with will be the same as the original plaintext! 

Programming a Computer to do Encryption 

The Caesar cipher, or ciphers like it, were used to encrypt secret information for several centuries. 
Here's a cipher disk of a design invented by Albert Myer that was used in the American Civil 
War in 1863. 




Figure 1-13. American Civil War Union Cipher Disk at the National Cryptologic Museum. 

If you had a very long message that you wanted to encrypt (say, an entire book) it would take you 
days or weeks to encrypt it all by hand. This is how programming can help. A computer could do 



Email questions to the author: al@inventwithpython.com 



Chapter 1 - Making Paper Cryptography Tools 15 



the work for a large amount of text in less than a second! But we need to learn how to instruct 
(that is, program) the computer to do the same steps we just did. 

We will have to be able to speak a language the computer can understand. Fortunately, learning a 
programming language isn't nearly as hard as learning a foreign language like Japanese or 
Spanish. You don't even need to know much math besides addition, subtraction, and 
multiplication. You just need to download some free software called Python, which we will cover 
in the next chapter. 



1 6 http://inventwithpython.com/hacking 




Chapter 2 



Installing Python 



Topics Covered In This Chapter: 

‚Ä¢ Downloading and installing Python 

‚Ä¢ Downloading the Pyperclip module 

‚Ä¢ How to start IDLE 

‚Ä¢ Formatting used in this book 

‚Ä¢ Copying and pasting text 



"Privacy in an open society also requires 
cryptography. If I say something, I want it 
heard only by those for whom I intend it. If the 
content of my speech is available to the world, I 
have no privacy." 

Eric Hughes, "A Cypherpunk's Manifesto", 1993 



The content of this chapter is very similar to the first chapter of Invent Your Own Computer 
Games with Python. If you have already read that book or have already installed Python, you only 
need to read the "Downloading pyperclip.py" section in this chapter. 



Email questions to the author: al@inventwithpython.com 



Chapter 2 - Downloading and Installing Python 17 



Downloading and Installing Python 

Before we can begin programming, you'll need to install software called the Python interpreter. 
(You may need to ask an adult for help here.) The interpreter is a program that understands the 
instructions that you'll write in the Python language. Without the interpreter, your computer won't 
understand these instructions. (We'll refer to "the Python interpreter" as "Python" from now on.) 

Because we'll be writing our programs in the Python language we need to download Python from 
the official website of the Python programming language, http://www.pyth0n.0r5. The installation 
is a little different depending on if your computer's operating system is Windows, OS X, or a 
Linux distribution such as Ubuntu. You can also find videos of people installing the Python 
software online at http://inypyx^ 

Important Note! Be sure to install Python 3, and not Python 2. The programs in this book use 
Python 3, and you'll get errors if you try to run them with Python 2. It is so important, I am 
adding a cartoon penguin telling you to install Python 3 so that you do not miss this message: 




Figure 2-1. "Be sure to install Python 3, not Python 2\" , says the incongruous penguin. 

Windows Instructions 

There is a list of links on the left side of the web page at http://www,python,org. Click on the 
Download link to go to the download page, then look for the file called Python 3.3.0 Windows 
Installer ("Windows binary ‚Äî does not include source") and click on its link to download Python 
for Windows. (If there is a newer version than Python 3.3.0, you can download that one.) 
Double-click on the python-3.3.0.msi file that you've just downloaded to start the Python 
installer. (If it doesn't start, try right-clicking the file and choosing Install.) Once the installer 
starts up, click the Next button and accept the choices in the installer as you go. There's no need 
to make any changes. When the installer is finished, click Finish. 



1 8 http://inventwithpython.com/hacking 

OS X Instructions 

The installation for OS X is similar. Instead of downloading the .msi file from the Python 
website, download the .dmg Mac Installer Disk Image file instead. The link to this file will look 
something like "Python 3.3.0 Mac OS X" on the "Download Python Software" web page. 

Ubuntu and Linux Instructions 

If your operating system is Ubuntu, you can install Python by opening a terminal window (click 
on Applications ‚ñ∫ Accessories ‚ñ∫ Terminal) and entering sudo apt-get install 
python3 . 3 then pressing Enter. You will need to enter the root password to install Python, so 
ask the person who owns the computer to type in this password. 

You also need to install the IDLE software. From the terminal, type in sudo apt-get 
install idle3. You will also need the root password to install IDLE. 

Downloading pyperclip.py 

Almost every program in this book uses a custom module I wrote called pyperclip.py. This 
module provides functions for letting your program copy and paste text to the clipboard. This 
module does not come with Python, but you can download it from: h^;//mypy.corn/pjpercUp.py 

This file must be in the same folder as the Python program files that you type. (A folder is also 
called a directory.) Otherwise you will see this error message when you try to run your program: 



ImportError : No module named pyperclip 



Starting IDLE 

We will be using the IDLE software to type in our programs and run them. IDLE stands for 
Interactive DeveLopment Environment. While Python is the software that interprets and runs 
your Python programs, the IDLE software is what you type your programs in. 

If your operating system is Windows XP, you should be able to run Python by clicking the Start 
button, then selecting Programs ‚ñ∫ Python 3.3 ‚ñ∫ IDLE (Python GUI). For Windows Vista or 
Windows 7, click the Windows button in the lower left corner, type "IDLE" and select "IDLE 
(Python GUI)". 

If your operating system is Max OS X, start IDLE by opening the Finder window and clicking on 
Applications, then click Python 3.3, then click the IDLE icon. 



Email questions to the author: al@inventwithpython.com 



Chapter 2 - Downloading and Installing Python 19 



If your operating system is Ubuntu or Linux, start IDLE by clicking Applications ‚ñ∫ Accessories 
‚ñ∫ Terminal and then type idle3. You may also be able to click on Applications at the top of 
the screen, and then select Programming and then IDLE 3. 




Figure 2-2. IDLE running on Windows (left), OS X (center), and Ubuntu Linux (right). 
The window that appears will be mostly blank except for text that looks something like this: 

Python 3.3.0 (v3 . 3 . 0: bd8afb90ebf2 , Sep 29 2012, 10:57:17) [MSC v. 1600 64 bit 
(AMD64)] on Win32 

Type "copyright", "credits" or "licenseO" for more information. 

¬ª&gt; 



The window that appears when you first run IDLE is called the interactive shell. A shell is a 
program that lets you type instructions into the computer. The Python shell lets you type Python 
instructions in and then sends these instructions to the Python interpreter software to run. We can 
type Python instructions into the shell and, because the shell is interactive, the computer will read 
our instructions and perform them immediately. 

The Featured Programs 

"Hacking Secret Ciphers with Python" is different from other programming books because it 
focuses on the source code for complete programs. Instead of teaching you programming 
concepts and leaving it up to you to figure out how to make your own programs, this book shows 
you complete programs and explains how they work. 

As you read through this book, type the source code from this book into IDLE yourself. But you 
can also download the source code files from this book's website. Go to the web site 
htWU/MY^J-99^^^y^S^Q\^c¬ß. and follow the instructions to download the source code files. 

In general, you should read this book from front to back. The programming concepts build on 
the previous chapters. However, Python is such a readable language that after the first few 
chapters you can probably piece together what the code does. If you jump ahead and feel lost, try 



20 http://inventwithpython.com/hacking 



going back to the previous chapters. Or email your programming questions to the author at 
al @ inventwithpy thon. com. 

Line Numbers and Spaces 

When entering the source code yourself, do not type the line numbers that appear at the beginning 
of each line. For example, if you see this in the book: 



1. number = random . ranch' nt(l, 20) 

spam = 42 
3. print ('Hello world! ') 

. . .then you do not need to type the "1." on the left side, or the space that immediately follows it. 
Just type it like this: 



number = random. randint(l, 20) 
spam = 42 

print('Hello world! ') 

Those numbers are only used so that this book can refer to specific lines in the code. They are not 
a part of the actual program. Aside from the line numbers, be sure to enter the code exactly as it 
appears. This includes the letter casing. In Python, HELLO and hello and Hello could refer to 
three different things. 

Notice that some of the lines don't begin at the leftmost edge of the page, but are indented by four 
or eight spaces. Be sure to put in the correct number of spaces at the start of each line. (Since each 
character in IDLE is the same width, you can count the number of spaces by counting the number 
of characters above or below the line you're looking at.) 

For example, you can see that the second line is indented by four spaces because the four 
characters ("whil") on the line above are over the indented space. The third line is indented by 
another four spaces (the four characters "i f n" are above the third line's indented space): 



while spam &lt; 10: 

if number == 42: 
print('Hello') 



Text Wrapping in This Book 

Some lines of code are too long to fit on one line on the page, and the text of the code will wrap 
around to the next line. When you type these lines into the file editor, enter the code all on one 
line without pressing Enter. 



Email questions to the author: al@inventwithpython.com 



Chapter 2 - Downloading and Installing Python 21 



You can tell when a new line starts by looking at the line numbers on the left side of the code. 
The example below has only two lines of code, even though the first line is too long to fit on the 
page: 



1. print('This is 


the 


first line! xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 


xxxxxxxxxxxxxx ' ) 






2. print('This is 


the 


second 1 i ne ! 1 ) 



Tracing the Program Online 

Tracing a program means to step through the code one line at a time, in the same way that a 
computer would execute it. You can visit ht^://inypy.cpm^^.^^traces to see a trace through of 
each program in this book. The traces web page has notes and helpful reminders at each step of 
the trace to explain what the program is doing, so it can help you better understand why these 
programs work the way they do. 

Checking Your Typed Code with the Online Diff Tool 

Although it is very helpful to learn Python by typing out the source code for these programs, you 
may accidentally make typos that cause your programs to crash. It may not be obvious where the 
typo is. 

You can copy and paste the text of your typed source code to the online diff tool on the book's 
website. The diff tool will show any differences between the source code in the book and the 
source code you've typed. This is an easy way of finding any typos in your programs. 

The online diff tool is at this web page: http://inypy.conVhackingdffi A video tutorial of how to 
use the diff tool is available from this book's website at ht^;//mypy.cpj(^^l^^deps. 

Copying and Pasting Text 

Copying and pasting text is a very useful computer skill, especially for this book because many of 
the texts that will be encrypted or decrypted are quite long. Instead of typing them out, you can 
look at electronic versions of the text on this book's website and copy the text from your browser 
and paste it into IDLE. 

To copy and paste text, you first need to drag the mouse over the text you want to copy. This will 
highlight the text. Then you can either click on the Edit ‚ñ∫ Copy menu item, or on Windows 
press Ctrl-C. (That's press and hold the Ctrl button, then press C once, then let go of the Ctrl 
button.) On Macs, the keyboard shortcut is Command-C (the 3g button). This will copy the 
highlighted text to the computer's memory, or clipboard. 



22 http://inventwithpython.com/hacking 



To paste the text that is on the clipboard, move the cursor to the place you want the text to be 
inserted. Then either click on the Edit ‚ñ∫ Paste menu item or press Ctrl-V or Command-V. 
Pasting will have the same effect as if you typed out all the characters that were copied to the 
clipboard. Copying and pasting can save you a lot of typing time, and unlike typing it will never 
make a mistake in reproducing the text. 

You should note that every time you copy text to the clipboard, the previous text that was on the 
clipboard is forgotten. 

There is a tutorial on copying and pasting at this book's website at http://mypy.conVcopypaste, 

More Info Links 

There is a lot that you can learn about programming and cryptography, but you don't need to 
learn all of it now. There are several times where you might like to learn these additional details 
and explanations, but if I included them in this book then it would add many more pages. 
Publication of this larger book would place so much combustible paper into a single space that 
the book would be a fire hazard. Instead, I have included "more info" links in this book that you 
can follow to this book's website. You do not have to read this additional information to 
understand anything in this book, but it will help you learn. These links begin with 
http://inypy,cpm (which is the shortened URL for the "Invent with Python" book website.) 

Even though this book is not a dangerous fire hazard, please do not set it on fire anyway. 

Programming and Cryptography 

Programming and cryptography are two separate skills, but learning both is useful because a 
computer can do cryptography much faster than a human can. For example, here is the entire text 
of William Shakespeare's "Romeo and Juliet" encrypted with a simple substitution cipher: 



IV.' Hl-MJUU) ]-\. allil: uulia.1 iiiitlhi. liv. haii-v rat- 

igiK nchb HFMJHUO Ofx. Ill bgw tfwi.Ckcnn qcbiir. 

'XUu.HKMJHiiOIXi.llu 
io.HFMJHUO Xih.qih 



w.i liit.iL.ii. I -hum. iliMl lk:.i. l:-i/.u:i .M I &lt; Ilii'K /] lul NJ- l\ 

v bglb, kgcdg, gfpcor, mi . - i.: i- ‚ñ† ‚ñ† QIOPUNCUCd niipil 

1 1 . 1 1 ' I li I t i ! ' . '. i a 1 1 - i I I L Li |- _ iv h.aik. I i. hi. :‚ñ†-!!./. 1.1.:- u:.-i.u.' 1_&gt;K&gt;I'1'MT ill.. -Ill ‚ñ†‚ñ† . I ' .M1-..I.- Mil. M I \ill Ru ..I , lit. ' i. I' i ka I' i" nit II' I M '.' K i h, \ I u ..I I-', i u i; ‚ñ†‚ñ† ;.iI:l ii.i. '‚Ä¢'‚Ä¢'. A 1 1 '.' K a ‚Ä¢. . . i/i,u il. ill p.i. :‚ñ†‚ñ† ‚ñ†‚ñ† .1. Ii.li- -. R:: t.iih i .-. :,if. i k.: ill i ai: pi .‚ñ† i in -. .jt. ,1! ih. k, l .1. ' lain- h. .ill i p. i |:i :l 'I. :i al ;-. ‚ñ†.! .p. .1.:- k t:a : iii.mi it. iiam I. hath nil :ii hi lii hi .!‚ñ† 

atllil ll.l.lk:- I'.lh.l 111 lllf -M I 'MlLI IH. |l 1.11 I II /lit llll llll kit Sllpl .il I ll III .l.'l \'. llll ll .\ll-.l h-1 I .L/ULl 1..1 llll all. t.llf.1 l/.-Ull. I L ll ‚Ä¢‚ñ† I ! I . I ‚ñ†-- I I .‚ñ†. I ‚ñ† I I I ‚ñ† 1 1 1 | ' .‚Ä¢‚ñ† I . I \ I.I . 1.1 1 .1 1 1 piN'. I Jill Ull/.l till' I ktill' III | ' ." I .' ' 1 1 : ‚ñ†' I . . kill ti I .'I ILlll I .' '. 111! Ill till 1 1 1 . lil h '. till hi 1 1 1\ I' lll'lllll U I ll.ll Hi 1 " 'I I.I...I '. A 1 ‚ñ†' 1 1. .1 1 1 1 . Ill' '. Il ' t.Ht H 1 ". Nl '‚ñ† ' i ill 111 i ' ' I.'. I .11 II I III ‚ñ† 'I . I '.' LI.' 1 1 _ J | ‚ñ† I 

mihu. KUZ 111 mi kVAln.. WUMHi li/h.li' ajpi r.illLli mvkiilu: I' llll null aia. i. li.aii] til ,-uh Wumiu. ai'll illll:li llhaiii it; ill I. (J]( li'CM'L' bum raitu lilt, -lull. 1,111 til hi Hi \uz iililii. VvCMI,' Ka:h. Ilaiim f n-uiu hit Iililii hail'.' l.lltH'l '.\t 'l ' I' ‚Ä¢‚Ä¢ ll h ' I ka.i. ml. &lt;J/li kltll.i hi:lll mi itiu. V.TM1I.' Q.:\ I ilnk- ill In t u ll ll:-iblll mlti atil knlil. ha. kllv.1 Clin zwrit bu llol 
bgfb th liu tun! Co lilWili. ilu/lin-. flu nupi I kunii'u. (JIOI'IIML T kill liu uitu. kam I' ii/niilm \u/. nupit. wr.VUC h iitiah eliii l mlv.t-i.iti-: lul iiaih nlm c num. IJ]ni-I.Nl'! ‚ñ† J- v.'i-ijh i.tt-v. mlv.v. utt-v. dm. til liuii.-iiili atli. wmir Kiiin. ,u liaib.aih vii/. inilih. k.aiim uuhip.aih kih.a IV.1.1I1 l-.n-uk. hai.allia ItluT. ktli. h..l. til libwmn-jwuLU ua 
djillhth. kinil twill. An inn |L1||H|| kilt liatiLltlla 1.11k llai iLt|iill /‚ñ†.‚ñ†ali-ill 1. I la I k^iiil ujh ilhll. hai lltin lliillupnirhiv.mbl. Out. i|iti ha I LiiilL/.uhiii ll hi IllkltiLtui ulIl.Oiim Ll J i am nil llll iltnih l-.il/ilniIll.iL!. h. Iliiiil ii^-ila t 4 - 4 it*\.in-LI\ Jllliv.-. Bilh kii.-ilaLltill ktlia tLI/li.i ltill am kill.-.- 1. (.IK II ' I M ' 1 iia.i. Ilai a;h, ilkiiini hull. Ila i ktiin hbcnn ncpi 

Llililhi: UTM11' llll al'Li.a. :i.l n- h.alli k|:-n.i iiimll a.i I k:k:-L. Aum i|.l/.hv k:-l.ipi. k.iia ii.i I ‚ñ†. I Vhil i|il..if. .i:.n .ml! 111:1 ;u Ill-it. th.-.. i lai i ll '.ill .1 :.li .i . h.iu .,i ll I. .m ll mi.-, h.i.i :.li .i . llll i ii.i- th i|iLtkh i|' ll .lt.il : ll. llll -It-. . I la. al':a .11 i- hki ‚ñ†.- ‚ñ† ‚ñ† h.i Lilipi. lul i :‚ñ† ' i.al: | iiik I'll ' ' ll.- :ia l':i mpi Liu liiiili .':i :-.ik. 1.111 11". M ' 1 ' Q I t. /II ll i|i. mi. liiiv nil hu 

hi-tl.t uiigiil-. Wli.MU' ('. hikla iiil auk t' llai./iil liiivilIi !u lian/t. 11' 1 Mi' I &lt;)\ itpti.i iln|i.i I it /.ih.1 iia.ui ltill . 1-1 iLi.ui uiia im ipl/h.ill 1\ I M 1 1 ' H.ii hi i i^l.t 11. i lI kill .1 im il /.tlltl-L. n.' ‚Ä¢ /.illhtl.M mull i. Hi ill i a I \ : \ iLillith iialb t.illl lii.m Lilltih' i|.Mii-iH.iiti.i i|iLlilt |/ ll /ll n: mn.l llai' at u hai liI.m . &lt;ii hall- ill hii.i ‚ñ†ikn . i|iLn:l illiiiulli Liil.'lrh Uiii 
;t. lilt .i/.il h-i ilil/.M I mi a.-il .'lii.i in If I lai I. ll.. : il.tl.L‚Äî.l.ii h.ali- .ll I lil.t. il :.li .i . Ka l.i I .ih. . i.i i|i! /'.i.-. in.i .u. i|/' i ! ll I iiii'.u Ka im I I :n I \ .ilk \i .1 Lillii 1 |:klln.:i Lilt‚Äî '.' ik.i.n l-.au/ iki .III. .i.h hil.la : ll I '.ill nil t. : lit Hit ll'l ' M ' I. "mi 1 1 \ h.ali- l.L.I'.i.t .-.-i. mill '..i .‚ñ† i 1 1.|' i. | l-i/ul ^^ '. 'Ml'.' H 1 I l./M 1 11 I I HI. - ' I II : I: i| - ' ' I :il i.h. | li 

tti. WliMIC Xu/.M ||| It. -il.- Ill til iMluliiiMh .11. ‚ñ†.- !ia:h. &lt;IH 11' 1 N&lt; ' I Ai.m ka:h. &lt; ' ‚ñ†‚ñ†‚ñ† I \ ha.i .' 'A I. Mil' ,\u.. .. ii/m ipi i.ti:. iiatu. tjll ll h I 'Nl'l ' Ki.-.. Winn i-.i. l.i h iiau/ nil I .' iVi ' M 1 1 ' t l.ih :u k. i|/h i|ii/ul :u .i.M hi In : I. !‚ñ† ‚ñ† t:i . I l/.l ‚ñ† / i. |v- 1. .|l- I, ../:-. :i -.. i ..I kail I I :u nhi. I :-'. liul l.i .. I ill 1 ink. 1 1 n- pn.li liul if' nil-till, li.' ;w fx . btw. 

‚ñ†Ill) tar. wilV.' Wl,'MlUh'\. Illtui uku .lUUliA.i in ill.-, ir.thiii V. Hmplnh Iniaiil \uz -iliii llitu,-ilthi.fhail/hi|uilt.i|/h. C |V.I\. Jlu l.u/. Hill In- hanmu/ilii'.' \\C. Mil: i-\.ti. (‚ñ†f-uill.iiai nihhit.il hi I llliuv.ki. Ilit.nlnh Xillix alinikliiLV. i-ikli .ill/ mill H vl WHIir Hlit&gt;..ui:]lluk.C illu uill. |Wiltli Htintmi .Mill html iul atll kt.u Inl li/i¬´hiu ll. DilAihl 



Email questions to the author: al@inventwithpython.com 



Chapter 2 - Downloading and Installing Python 23 




24 



http://inventwithpython.com/hacking 




Email questions to the author: al@inventwithpython.com 



Chapter 2 - Downloading and Installing Python 25 



-Ml Kli .il ill a. ia. iiail I: i. li: I 'I ‚ñ†' h- ‚ñ† I _ I ‚ñ† 1 L'l'i. ha L.a : 11/ ha.i I _ 1 1 ‚ñ†- -. I ‚ñ† ‚ñ† -_‚ñ† I ‚ñ† . I..; ai ilia: '.' '. I.u/n'. . I ' . 1 1 .'‚ñ† ..am | M.'.i.il l.a ia.' 1 1 ' kail a kail', an ! k.a ll'. uz.'. ill. I ilii! '.V i i. ‚ñ† ll. .. h. Kn .,la 1,1 [ ..ik i:a in l.il ia..a:li a ill zi. I 'am : .1 !:‚ñ†: Jd'.i kaiia .1 1 .. ak aa.. 11. la 1 L-:l::".. M la 1 &gt;-:Il!-i. lla i ap. .1 11 ..111.111 a 1 all lIl.iiii I M'l i:i\ . ML 1 

iil/..|il Jill all ail'a lull /.i y^Il ‚Ä¢Mill'. Bali: 1 1 &gt;‚ñ† J I _ 1 1 "III- . /I' Liaiiimi Km L.ai.Lkaii mi. MImm\. Lit tmiu. ailia ilii/:.: ail iiai I! ! (' m.ail ! 1 I-. I ‚ñ†_" 1 - 1 " MLI::la mill ill. Milliill ! ]'‚ñ† . ml. ha 1 1: il/.'h.i hki .111/ an ui/ll api. (,:iii: .iiiaiah .' li ‚ñ† 1 j . l' nklia. kail:i .il :..i:i l| 1 . : I /1 u ‚ñ†‚ñ†‚ñ† I a. 1 I'. 1 .!/‚ñ†‚ñ† I'k ‚ñ†'. 1 1 kalh. I" .l.li'i Ll \| /. " ‚ñ† .111.I i.aill! i'ul LLlku lik-iii C 

lu/.. NIK. lllll! 1 i 1 1 -L ‚ñ† hilly Lllll' lillil i. aim! nil nlllil lilr ‚ñ† kAillil I tl.l. hiih iiiIll 1' k til l| u v.'u ! Ullilu l.zl :ialih. i.i! Mi LILI..I! nil iltl.l! + NITiX I1L1/N1B NITX llh.l/Nihl Kyi!; ‚Ä¢. 'i.ahi ‚ñ†_ I L .an. O/.. II: C 11 ; ill 11 1 1; I l 111 ill! MIX HIT /NIB Rail' all iiai ili:l.l::il '.' C &gt;/.. In Nnua. :lil aia! I' iiip.l Ik! NITiX llhl/NIB C I in Ml li.aam. 

‚Ä¢ipa p.. ill .la / . .1" 1. 11 a a 1 . ! 1 i 1 : 1 . . 1 1 1 1 ! . | ha." I II .1 /.'‚ñ† I li I III .1 /'‚ñ† 1 1. Ai :ia .. :a. l|" -‚ñ† 1 ! .‚ñ†: . I ‚Ä¢ . 1 aa. . 1.' '. ..1 I ...1: . 1 1/.' I: . i ia . 1: .1 1'.. I i.l 1: 1: 1.. . 1 a. I . : il :. 1 .1: It " 1 !_‚ñ† 1 1 1 \ ! Nh I \ ! ill /.!‚Ä¢ lil I n hi. ia r.; ‚ñ†. iia 1 ll I:: 1 1. :. I :. La. :i 11 .1 III l/NIB : .&lt;‚ñ† -.- 1 ‚ñ†‚ñ†‚ñ†‚ñ† .i/a. :n:l. II-.'. Il . .ml: (i." : ill .11 ;i.l a'n.l. !‚ñ† 1 aa.' 

.li. Naai ha ill: nail &gt;‚ñ† 1 1- _ 1 L li 1 . 1 apia Lip" hai T.L'a ill 1:1 li.i ai" iil.i I.i zuLl \ niip /.inu h. 1 iiki.i i.ka ;ni li .::. 1 .11: ' il' 1 .i.'iir. . ' 1 ‚Ä¢ ."‚ñ† L 1 1 I .1: mi..' 1: ... 11 1: \ N L 1 \ I Ik.V.N I II 1 ' ki ../ 11 I .. n.1 I II .1 /\ I li ! i.l aa .1 ‚ñ† alia ai ..1 a." a 1.1.1 1 ' in :i; Ili ili i a; a:i. IV 1.1 ‚Ä¢ 1 ili ‚Ä¢. ' m:;| ‚ñ†!. :i .: Lam . ‚ñ† i :‚ñ† 11. 1 ‚ñ† 11 .1 :i Ml . | li .\" . i '\ N I '/\\ II III! i ‚ñ†'. 1 1- Vl'I ' 1 1 . 

I: '."ll' 1 . MvT. Killl I I.i:, 1. lI. l|-...:. ‚ñ†‚ñ†. .1 , l..i ,1 :i ‚ñ†‚ñ† ‚ñ†. I ‚ñ†_‚ñ† " III .l/M:i Vl , |-. , |... 1 11 . .|,|. . ii| / I I: ' ilm . 1.: l|i:..,.m ' il'.l .MI...11 I K I i I' 1- li: h. 11 k ‚ñ† .^l h.L ' il'.l .^.li 1 H.L i.l . I.l'l ill ill. AilmKll. I II Il.lm k:k. : i.m . , 1 1. 1 ‚ñ†‚ñ†. .1 l|' l'liii. I'lihy ili.'. :1m:; .'‚ñ† iLlk. ] M!ill .il ill' l'llll . M. II .1 J.... lli lliIi.l 1 krlil. V k.Lln ..i. i.M :I| Ilii llili 

VIODI iilLll. LLM. LILI.' IL.L'IIIIlI lI I.L : Ll/.l Ll LI 1 1 II L I ‚Ä¢ L'- I Ll ." 1 1 1 1 L I LI I ' ' ' "‚Äî " _ I _ I IL M 1 1.1/ IlL.LL il . I i.L| I.L' LUl .' M/'.l II (ill I '-L |l .'. ' I I L L'l I .1 1 _' L'- 1 1 1 I L I . I '. I k L 1 1 p ¬ª I L I 'l LL kill. I ' L 1 1 I ‚Äî ~l 1 1 "- 1 ‚Äî ' I L| lI 1 1 1 L'l .'Il .' " LI M 'L I I I L 1 1 L'l . X '.I ‚ñ† L'. 1 1 L'. L; l'l I L' I L'. \ M 1 lI .1 '.Ll I 1 1 . 1 1 ' LIT .1 'L II L 1 1 '. I 1. 1 L.' . -' . I p LI i L I . ! I L' L'i I I LL |L .'. ' I L ' I 1 1 1 1 I L'_ 1 1 .. li - . 1 1 . 1 1 1 1 1 1 \ . I ‚Ä¢ Ll M / 1 L'h kj I L LT.L ILL || I II IL !‚ñ† LUl ' . AUlL ilkill 



|l LLIl'I. IJ/'Lill trllLLlllh LLILl-.L.ILlll.lkll. ILL. I/.'.I /'. j'h '|. .ILI'L. kLlLM .'11/ Ll'llk. Ii.L'lIl lIl I | L' !' .'.'./ ll IL I ll I . | ! - J ' \ . ',L 'L I L !‚ñ† M / I|l. 1 .1 1 1 I . L| ‚Ä¢. III.'. |l '.L '.ill LL . h_JI JIIlL lllll 

A.LLLlh M/llLLkl:; U.I. . IIHIW T k.MIL L'LL.I. k| M .!' ' Ll / 1 1 1. /.‚ñ† ' I ll \ . A.LL |||. M.|.l,...:i. LyLi / iL.IIII \.,/ LLpi / 1 1 L I I L i ] I 1 1| L 1 1 . 1 : ‚ñ† I \ . Ll L I I Ll ‚ñ† LI|.':H\ L|/h O'.'i lllLIL. &lt;' kL I L ll I L' |'. ' Ll / |l Ll I ll Ll I ‚ñ† ll I ' LL 1 1 1 . A LL 1 1 1 , *L | ..| .l I.l 1 1 ‚ñ† I i LL II I I ' .,L 1 1 Ll I L I I \ Ll / I ‚ñ†, I '. I I LL . I I ‚ñ† I L I ‚ñ†‚ñ† .L I ‚ñ† / ‚ñ†‚ñ† I . I ! i i I V| By III kXllll &lt; 
1U/. ( ill] L.I IU/HU ILI / I Hi hi Ilii.' Al'"'IiI' \1/ llnl L'l L ' J'U Ml/ '.1 I /.ll l.'l.li /ll. .Ml/ l'IlIIL /ll. HUlll'l M/klLliiiu iLL ll .111/. |/h/| .V.I / lL 1 1 III 1. . lul |* M/P ill/1. kuMIBIW B.LIU jl;li III iJ/iLhL lll.l ktu!f kill II 11. V-L|lih Vli/ kiUE I..LLLMU kill, till |/h/j lll.i L'l'lli' [IliiLL . iullklll Ilii IIILl'I Ilii... 'KfUl lHU |Ll U lUllLI ll.li Bill. |l lUhj kll/ul. llM UlLlii./M l/lll|ll IlLli IL 

M||V.iilll. Bsi..|ll/lliLil kiiia ail. Ikiipii. IlL/.ui kill , LILLipiv. :iil/..l .'kyv iii/IillI kiiia an. Ikil|ii.. IlL/.ul-.' kali' IlK .ill/. Ikiiniu [1:|i|Il:. : ; M/.iKik-lu MILL ll 1. iv.. . L|iJ l/lli iKLipi,-. Llb.L : llkiiliilll/..!. JllilW IlilWii: Kali, lll.l 111/. (I/la Wii|iik-' lliilim M/ilL-Jtiu 1" lll.l Ikiipi.. Im/.ul. LpiLI/.ki iil/Illi:l:i.Ii Illl/.Ul Lllll. iLuiipi.. .lUUW I.. il.Pi I '.I.l ! I, L. I' Ll. 
bgchtfifoz dJ I ] 

|]:.'ii.L ni ; \B&lt;IIIIIA\.Lpi.i|.Ll|i)iklL.ii.LMIL I'll, lll.l ‚ñ† tiliiMiiliL.yiilliallliii: iillLl; hail/ L.i.l. Lp.a.M- iiililiI'I. I., ll li.. lllll h.L'i .HI li .. '.' iiilk luhs nil lllll Mil iLil iitbuiv. ivillLl" I i'.ik L.I '.'ill lll.l l./ikilv hi Hi f :Ill hku. An.. . ' 111; a a. ' I lip- i.ililii. a.ikai i I kiniL.(.ilMi(i|-|IIA\ Bam Nil ail kaiil. :ul uilhaLiii lI:ii ip LIIIL. I il.. a lll.l liniiill a:. llPiiLlil ilMvni:*. la 

" I I.! 'il I " ' I '.i . ' .li ' I I" ' I I' niitilll I. ' JiLpil. Nil. .-. I.i ha i hiL.a Ci|a! h.L'L. ll .(illll I ' I ' I . ' I . ' I III .i.li-NliClillAV Hi . ii.i iii.M .,.,.li Ml 1 ' hian ill. I " h ll I i " M I ' ' h 

I, i.l !..,-.i. |i-ai l.l|N:ilii::iVLi K.i.m. l.n.-.i-. '. ' I.l i.m i.l. I.l ha Lai.h.i .iaL,i. Niili ill. .11. ll m.i|.|.. f n.LlL,laai.i. :ai./ :i.l. Ilka.il. 111. i.i. ill a.- hii hiu/Liiill .1;. lill |r.L Ihi iliiii! C Ili .l all iLlk|i.L In Ip.ihinll .. .1. lin a i.. iUp.i/hll il ! i-. i II 11 ll. kauiia 11 ill L 1 ' 11 11 Ili I C.hlNii.L I il fll. iaah.i MLii'.L k iiLliLiaui ip. Likll. IViiiLlui mli Iiliii milIl. imllii.l kn. i aall iLMi.all. Hal 



I' .11 Li;..! h.i.i lI.i:.|/lli1i.im.Il. I pl.Liaiul iian :..il. I .'.nil..- a." i. V. I. MM. KlilI' hail/ ill llpiki MLii' haLii a'ipii :1' hail, ip.il ! ; B.i il lkl ah II R1 I Nil .'‚ñ† '.. h. 1... .1.1 ah! I I. a ill .. II. 11: k. i.,a. 1 1 .l i IIA1 i i I I. . ',' :; 11 I _ 1 1 

l|/.lli hy.LL aL. lhLLL/.iii|a;luh lllipi! h' ill I pli' P' uu ! I MiuliLi. u. IiilI/.i al.i'.. i 11. /.I .a. .'mi. a 1.'. i Maiil I ./Maiii. ai .'. ip l/hi mlaiil 11. a ah pi/Mil I :.M liiiaui ; .'. liln'ih :./aiil .1:. Li -a ail. i Mb a. Liai hi .1/. I.L'Li' 1. ipi I 1 ill MLI" a.'hi'.. '.. i. | Nl.iaui ! IAWI I .'. ' hai I'mliil| | I. ilii. .i:.ii kai:' ill i:' 1 1. i 111 hai luauh UL. lilba (It 
^uzwdfoClulLHibgu.Befotcbebgfbeiolbgllid/li hai .111,1... .... I . ‚ñ† .. I ‚ñ†‚ñ† I I 1 11 o ? toi lounxi' Auwrcp mi, d nitimiohbwe jb Bgii giwi cotfv 

NFZWIODI. ktbj I | ^ I u Binn mi. mm mi 1 

ILL/ijIl fill II ill illll lie/null.' Ill riLilLlniii.lihL|/..iuihaLii haL I'll j I ill L ll L ll i i/ill ll i h . Ul ‚ñ† Ml&lt; 1 1 1 1 1 A\ (ivuh.i ilii. iLiil.i lla'.L. I,m hi i.. ill Lin MLIilhi... !in h,lh ill/ ll. i.m. AVil.iM M/.M 11)111 Kan lIi l|.. : niNIKIIill \\ W .iilmii A\\ih¬´ M-/H K 111! ( Ink ilii. .1 aliia a. 1 ili. :ai.. (JhNIK IlillAV A,i 

pl/nii. npNiUiliilW P li.li :..ih. Ilci. Mi m.IIiIml. auilklL.'l.hL|/I.C :nl ii.l.l a ii.iii. ia.L :.M .' : .,- 1 1 a, - LaL il,i:.|,Ii iLiiiLh, Liliia. I.li I Lai iihli h.i .,1111a 11. 1 aa.i auii:.hii. AV.liV,- Nh/V.iiUll I II. li. ha.i.. Cm. i.l :i..ii.i. A..i. ; I: /;.,. C. iL,/,la C .ill., iliiili . ailiL /i.M/ilai iiaaui. IJI'NUCIi II'Vl' t "I i 

foubglw auzi'gh. I'ul iial:- lm.i M.pihiLL :i ill. a.ai; .AW TV. Ni/'.V ll ;i II V.i 11 1.1 ! liaii ..I.l. | I iill.l . :ilI L.a. ka:h l|i..iu . ail h.L ll . .aiL ili '. ihk .'il ilai iih.i:..'. luh.' I. ilI i .1:. iia.il IlL/Li.lai' Kal I lu hail li.ii.L 11 lilh I.M l .i.l 1 iikn.. ii 111 Mai ;.iiiiiiiLi./i' i ipi ia.il 11:1:1 11:1 piiii i | !‚ñ† hi., ll h. 1 h. , ^^ ! ‚ñ† . ; Ili 1! Kail ml .1 .' kali'. ‚ñ†‚ñ† ‚ñ†_ I . :i 11'.' I .1 I .:‚Äû : -‚ñ† ‚ñ† L Mil .11 : 

i-a. kalh ll. A.taiil au/.. (il i/aiLln 11:1 li'a.il ill M.i.hlL ML LL.ii 1 ‚ñ† 11 1 Ilai 11:1.1 kia..ii. |[./Ni Hi klaiil| l./NClli I J .11;,:. .i.l hkpn l.l.lI.l: i.an. 1 ill lmi 11. i.li: C :m .. ili i mi i l| i ll k 1:111 i.ar.a 1 ( Ilau/.ILI 1.1. li.l hai.. lC :ill. Kai.. L all mi \\ iiillil,.' lOualu kalia-Lip AWCIA\ M/Al 1(1111 C ail,, iiiun 1 uualli Mil. lImiiii nwum bglb oihb Lla HUbg, miDbftcno, fill HMmzwftl 

I am 1 ‚ñ†..'‚ñ†: I. : -. I'.a- 'hV. Nl /V. PilIP K.ap'l. aa.' li I .l/p i.m In: a a i.l /1 .mpi 11 a:i .1'.' I .lahi.u. C 1. 11. a:h.a 1 1.1. aak :an. I. ilii . C .l.a/.a 11 ! :.l ...a lain. I11I :ii:.ii ai:.:il.i I .. .1: B.i a ai; 1 ML l.iln.. i C k.aiil aaiih iiai i.iii. ( 1 1 ill 1 In ml kin 1 a i.i Ilia a: ‚Ä¢‚Ä¢! 1 ‚Ä¢ ‚ñ† ham . Ill 11 ia . :a. i.a:a I ‚ñ†‚ñ† i.:i. ‚ñ†‚ñ† . liap. Il.IiIliIi aall. Hal :iai ll :‚Ä¢. : k:i. 1 11. Aa.. III. 

K lb J a 1:1 1. ‚Ä¢ ;Kahaa... Nip. ipn: kaa.ha kli.' l./.NCIB Xl: . ulu.-ki? ham fiLM ip ipLaij C al;n Hilill ! 1 1 lulKlaaui WIMII il I lin.. li'aail ail ha.i liailha. |iihk|ll a i.l li ai:. iiai.. 1 i./llh. lul Mill mli l.a |AIM|L|| 1..: WVMIlTl 1.1m. :i.l laih ,l,ihi.. KlKla. kaiia iiai.Pil lili .1 1 A\ Ci i | Hid Baail ail hai ;:mlIi. ha i.l a kai.. 1 hai hui. lia li.lia a/.i.u. Aall-llb Klbdgmfo JJul 

1 I. 1 h 1 1.. .' 1 1.. 11 ' I 1 . hi. 1 ll I.i ill l.i.l ‚ñ†, ,l.,l ...I Mi ..li 11 1. la . Ill 1 ml. 1. ‚Ä¢ I , .... I . I ... Pi I III M II 1 1 , A 11 1 . ...p. p. 1 lih 1. 1 ,.l mi I 1 . 1 '.' 1 I - 1 ' ' . 1 1 . .1 1., 1 . Mil I \\ \l ,A\ |i i|!l| 

Haa..: ki:nl.a:lilu I. ii.L 1 ah I a!. l. iialh ii.LMLlLpLill. Illi ah h.:l I..|||L Ki L'l.na :aah iiKhi'iuia :i.l h.aah Irh.i ill 11:11 aani. I'll ai kill lIiiliil:': li.l 11:11 iia.il Lla/ .. .la.a I .. : lull Al.lIi'.i klb.la h : .. li.i I1/I1 la.la.iu. kill hai .a.'.i" iii.n. lul'ii' ha: I Ci 11 II :i .: lia'.i .::i ail .'Vl'I lllll k.a i.i a i.in 1/ .. . ah li.l .:‚Ä¢‚ñ† ili ‚ñ† p ll.ali' i.l milIi !./‚Ä¢‚ñ† r. 111..: n.. 1111: .1/.. :ini .. ua.a'il 

.' iki" l.il':" 1 11 I /.'‚ñ† II 1 . NT i.\ I M . : /N 111. hi .ihai.. :i I :h."/N 111 Xa :l ‚Ä¢ Iiai / I.: a a ‚ñ† 1. aa:l ‚Ä¢ aai.a im iia.a aia l.p.L 11 1'.' 1 M I \ illi /.Mil Bai 1 1.1:1 1 a.' iiai ilh.. lih .I.l... 11 .:. iii I ./alalia Ilii inn ml J:" ah . hai Inn " /1 .. Xl ha 11 1.' ll / ail.. ' ii.ikl .l 1 :i: ... ‚Ä¢/ h 1 11 (ili P ka: h .11 1 .. l h iaaii k.a .1. iihl .. 111.I. a 1 . :i / ‚ñ†‚ñ†‚ñ† ll ‚ñ†-. ll'.' .'ill. l.a K:l "ia: I Inpa.. ili i a a ill . n. 

ha 1 1 1 .1 zu In i 1 ll ail 1 1 1 L III : . I'. : 1 1. 1 1 L I ll nil. I l : 1 I ./ ll a ll. . III! I. a I : I '. . . k I " ll. I ‚ñ† ' I ‚ñ† ' ..\ l a 1 1 1 L'. . I 'VI ' 1 1 1 1 1 1 1 1 1 .l . I aa I; 1 1 a . I : ‚Ä¢: _i i ll a ._ . 1 1. I '._ l 1 1 : . . I /ai I Li /.'.'. I .l .1 . 1 1 Ll 1 1 1 A... hii kll'.laiiil:. ( 1 1.. I ail I :... ai .. . I :‚ñ†: h:ii ,:.'.M.L i V.i ii.nik ll. ha kaaa .‚ñ† ha" /: mli ah / ai ‚ñ† I ..lmi.. ...a I a: ll ll. h, ll: , : u I: i .a ml h. Ill l/N 111 I a.ip.i.li! I' ka.u. nana an.a .1/.. :| /:.aii i.. .| il ! B.aah :| :: 

alh. mil li. ..i.l. li.i. aail an/In (il Mi.|l.i 1 1. aa. i hla nil Mnuhh/i. i.M ah li.l ll llaill'i il a ‚Ä¢‚Ä¢ lll.l ll/iahi'. I: l|U!hm:i I NIT \ 11 hi /.Mil I mi I'aiall h.alal Ilia; all 111 I a|iilil. ESailli kill nil nil .ail I: i ill I I: :ia i.l. ‚ñ†‚ñ†‚ñ† ‚ñ† 1 1- I -ill 11 1 I I PI k/l I, il ,.h. ... I: 111 (i a P ! II... a i .. .. .n: ‚ñ†‚ñ†. .all/ I ‚ñ†‚ñ†. h .1 ‚ñ†‚ñ† li.l / . lin hi. I '.ai lain . I.l aia" ll.li" . ll .. M \ luki a M I '( ilihk/l 

I 'M lil. ail Main. Lll.l kaaa ah u:i hii ua: ail. R... in Mil nil i ll iaaii. a:h.a hai | : a." : ‚ñ†‚ñ† alia k ali' n/" I ia':.. l.il I aluuli la., iii lilauli.i ma : I V'i '( 11 II N .,na. : ‚ñ†: h.. .1/ '. ia I .ih im. M '. '( IN k/.i I hi .1/ /uhl/Li h! kalh 111 ll all a.: I i.aah .' Ill |" ill. apini" . I i.ai a.:l ia." an I : .. I :i I : I V'i.'l II 11 1 1 1: n / il .i/ia nil n/h.. I: I nil .. I k.ia n a Ham: I.l .:!‚ñ† ‚ñ† lin.:" haihi 



Llui.piiiaiuhill ilu/lll lliul im Vliiilini l^/h kail. C lil iili. Ili.nLi ilLaii/.ln Ll. I lla I liaalli I ':. i ill liak'a:.:. ai.. i zu ha ni ill! II I.l Ha I una in ':‚ñ†. ah :ui h.. /.: Whlii i.l 111: I I.i I iakih . V luh.. ilin: i ill lIi.iili .ill. ha. li.i ail.. I'aah kn'. a nn a.:p:i . kal ..a 1 1 :a|. IJ/ii p.. I.. I .mall I :a: Ii.Ii.l i ill: .1..1 ml I'lll hill Ma . li.i haa hill. iiIiiill lin. ia.izail unii in iaah.i ill a Q/h. lil all lliilllll. (al 

pallLli..Ji llu aiLLlliLi.a liLM h.aah C LLink. :ul hii hai Mil.. ..a:n C:'. u/'.hi all .. api. I :‚ñ†:. a.i l/i iii au haali Mali.ll .l .l ai: l|.i ilii Lilzaih. L'uil all MLII naai (J i ll I.I.. aLia.lil. ll an/.a ip.m.. i aal: l'aii:i. /:.':ni ilai ..ltm/.l mm Ii all., lilh :ilk. IVl'I'dl II ki liiia:IM a:pi ai mku I'an lim'. : am:' i m:u. X.ai.. i'k ^ inllLi.'il ail:. .' ia.i 11' .11:. il ll I.l an I'aall'.' (.1 h N Bli 1 IT I h'W C ajl. n/iali 

nil illlllliiLL i.iiaii nn l./naih h ii:l.a. li.l hai.: a.: nihil a: ilIiill li.. mil M:uhzl Bai I'iall iiillil ailala h.i I'iall illLIn lm .iivlii luh B.iall ilil'iia.L a i il ll m.i L pl ill: I apL aah .Liha:" . h.:l lla" lI'll .1 kaaa l.:ha. I ml :‚Ä¢: au h. I :il z.ih. ( I ;i I .. i : ..i naa- aan . aa il. a I Vl'I. '(II II Ram in I iiai Li liil'i.. . V iaailLI ll .ma n:. ah. k.a... I an hi I . .!/‚ñ† hi :i pa hai a " :.1| II hai kllida'.' 

I lav. ..li. kalh mill ILiz... illlill'i... a:, iia.il iihl.'.' Ihkl (Il 1LIML. k.a'a .imik.'.k hi III... ik aall iLll.'.'il ill ::ii. h.il api mi hill:.: Ill .inn. !:‚ñ†: lin ( ' lal . huilu .himih .nil kaiia ml i ii h.i ll ll hi I himap I'ul a.' h'l api lll.l iii:1:I'lii 1.. ik li.i aailL. I'm hai.' C .. h: : kl \ I ai .1 kill iiai I.l h.laa IV'I lllll Baail ii.lv." Ii.l'a in:ai il.nl hai lil. a I .. ll kli" ill. lla il .l .Im/ll In uu nupi. llgl 

If you tried to encrypt this by hand, working 12 hours a day and taking time off for weekends, it 
would take you about three weeks to encrypt. And you would probably make some mistakes. It 
would take another three weeks to decrypt the encrypted ciphertext. 

Your computer can encrypt or decrypt the entire play perfectly in less than two seconds. 

But you need to know how to program a computer to do the encryption. That's what this book is 
for. If you can program a computer, you can also hack ciphertext that other people have encrypted 
and tried to keep secret. Learn to program a computer, and you can learn to be a hacker. 



Let's begin! 



26 http://inventwithpython.com/hacking 




Chapter 3 



The Interactive Shell 



Topics Covered In This Chapter: 

‚Ä¢ Integers and floating point numbers 

‚Ä¢ Expressions 

‚Ä¢ Values 

‚Ä¢ Operators 

‚Ä¢ Evaluating expressions 

‚Ä¢ Storing values in variables 

‚Ä¢ Overwriting variables 

Before we start writing encryption programs we should first learn some basic programming 
concepts. These concepts are values, operators, expressions, and variables. If you've read the 
Invent Your Own Computer Games with Python book (which can be downloaded for free from 
http;//inyentw^ or already know Python, you can skip directly to chapter 5. 

Let's start by learning how to use Python's interactive shell. You should read this book while 
near your computer, so you can type in the short code examples and see for yourself what they 
do. 

Some Simple Math Stuff 

Start by opening IDLE. You will see the interactive shell and the cursor blinking next to the ¬ª&gt; 
(which is called the prompt). The interactive shell can work just like a calculator. Type 2 + 2 
into the shell and press the Enter key on your keyboard. (On some keyboards, this is the Return 
key.) As you can see in Figure 3-1, the computer should respond with the number 4. 



Email questions to the author: al@inventwithpython.com 



Chapter 3 - The Interactive Shell 27 



7&lt; Python Shell 



File Edit Shell Debug Options Windows Help 



Python 3.3.0 (v3.3.0:bdSafl=90ebf2, Sep 29 2012, 10:57:17) [MSC v. 1600 64 bit 
D64) ] on Win32 

Type "copyright", "credits" or "licer.se |l " for mere information. 
&gt;¬ª 2 + 2 



Figure 3-1. Type 2+2 into the shell. 

2 + 2 isn't a program by itself, it's just a single instruction (we're just learning the basics right 
now). The + sign tells the computer to add the numbers 2 and 2. To subtract numbers use the - 
sign. To multiply numbers use an asterisk (*) and to divide numbers use /. 



Table 3-1: The various math operators in Python. 



Operator Operation 



addition 
subtraction 
multiplication 
division 



When used in this way, +, -, *, and / are called operators because they tell the computer to 
perform an operation on the numbers surrounding them. The 2 s (or any other number) are called 
values. 

Integers and Floating Point Values 

In programming whole numbers like 4,0, and 99 are called integers. Numbers with fractions or 
decimal points (like 3 . 5 and 42.1 and 5 . 0) are floating point numbers. In Python, the 
number 5 is an integer, but if we wrote it as 5 . 0 it would be a floating point number 

Expressions 

Try typing some of these math problems into the shell, pressing Enter key after each one: 



2+2+2+2+2 
8*6 

10-5+6 

2 + 2 



2 8 http ://inventwithpy thon. com/hacking 



Figure 3-2 is what the interactive shell will look like after you type in the previous instructions. 



T&amp; Python Shell 



File Edit Shell Debug Options Windows Help 



Type "copyright", "credits" or "license ()" for rr.ore inf orrtation. 

&gt;¬ª 2 + 2 
4 

&gt;¬ª 2+2+2+2+2 
10 

&gt;¬ª 8*6 
43 

¬ª&gt; 10-5+6 
11 

&gt;¬ª 2 + 2 
4 

¬ª&gt; 



Ln: 13 Col: 4 



Figure 3-2. What the IDLE window looks like after entering instructions. 

These math problems are called expressions. Computers can solve millions of these problems in 
seconds. Expressions are made up of values (the numbers) connected by operators (the math 
signs). There can be any amount of spaces in between the integers and these operators. But be 
sure to always start at the very beginning of the line though, with no spaces in front. 



operator 



value 




value 



expression 



Figure 3-3. An expression is made up of values (like 2) and operators (like +). 

Order of Operations 

You might remember "order of operations" from your math class. For example, multiplication 
has a higher priority than addition. Python copies this for the * and + operators. If an expression 
has both * and + operators, the * operator is evaluated first. Type the following into the 
interactive shell: 



¬ª&gt; 2 + 4 * 3 + 1 
15 

¬ª&gt; 



Email questions to the author: al@inventwithpython.com 



Chapter 3 - The Interactive Shell 29 



Because the * operator is evaluated first, 2 + 4*3 + 1 evaluates to 2 + 1 2 + 1 and 
then evaluates to 1 5 . It does not evaluate to 6 * 3 + 1 , then to 1 8 + 1 , and then to 1 9. 
However, you can always use parentheses to change which should operations should happen first. 
Type the following into the interactive shell: 



¬ª&gt; (2 + 4) * (3 + 1) 
24 

¬ª&gt; 



Evaluating Expressions 

When a computer solves the expression 10 + 5 and gets the value 1 5, we say it has evaluated 
the expression. Evaluating an expression reduces the expression to a single value, just like solving 
a math problem reduces the problem to a single number: the answer. 

An expression will always evaluate (that is, shorten down to) a single value. 

The expressions 10 + 5 and 10 + 3 + 2 have the same value, because they both evaluate to 
15. Even single values are considered expressions: The expression 1 5 evaluates to the value 15. 

However, if you type only 5 + into the interactive shell, you will get an error message. 



¬ª&gt; 5 + 

SyntaxError: invalid syntax 

This error happened because 5 + is not an expression. Expressions have values connected by 
operators, but in the Python language the + operator expects to connect two values. We have only 
given it one in "5 + ". This is why the error message appeared. A syntax error means that the 
computer does not understand the instruction you gave it because you typed it incorrectly. This 
may not seem important, but a lot of computer programming is not just telling the computer what 
to do, but also knowing exactly how to tell the computer to do it. 

Errors are Okay! 

It's perfectly okay to make errors! You will not break your computer by typing in bad code that 
causes errors. If you type in code that causes an error, Python simply says there was an error and 
then displays the ¬ª&gt; prompt again. You can keep typing in new code into the interactive shell. 

Until you get more experience with programming, the error messages might not make a lot of 
sense to you. You can always Google the text of the error message to find web pages that talk 
about that specific error. You can also go to http://inypy.cpnVerrors to see a list of common 
Python error messages and their meanings. 



30 http://inventwithpython.com/hacking 



Practice Exercises, Chapter 3, Set A 

Practice exercises can be found at http://invpy.con^ 

Every Value has a Data Type 

"Integer" and "floating point" are known as data types. Every value has a data type. The value 
42 is a value of the integer data type. We will say 42 is an int for short. The value 7 . 5 is a value 
of the floating point data type. We will say 7 . 5 is a float for short. 

There are a few other data types that we will learn about (such as strings in the next chapter), but 
for now just remember that any time we say "value", that value is of a certain data type. It's 
usually easy to tell the data type just from looking at how the value is typed out. Ints are numbers 
without decimal points. Floats are numbers with decimal points. So 42 is an int, but 4 2 . 0 is a 
float. 

Storing Values in Variables with Assignment Statements 

Our programs will often want to save the values that our expressions evaluate to so we can use 
them later. We can store values in variables. 

Think of a variable as like a box that can hold values. You can store values inside variables with 
the = sign (called the assignment operator). For example, to store the value 15 in a variable 
named "spam", enter spam = 15 into the shell: 

¬ª&gt; spam = 15 

¬ª&gt; 




Figure 3-4. Variables are like boxes with names that can hold values in them. 



Email questions to the author: al@inventwithpython.com 



Chapter 3 - The Interactive Shell 3 1 



You can think of the variable like a box with the value 15 inside of it (as shown in Figure 3-4). 
The variable name "spam" is the label on the box (so we can tell one variable from another) and 
the value stored in it is like a small note inside the box. 

When you press Enter you won't see anything in response, other than a blank line. Unless you see 
an error message, you can assume that the instruction has been executed successfully. The next 
¬ª&gt; prompt will appear so that you can type in the next instruction. 

This instruction with the = assignment operator (called an assignment statement) creates the 
variable spam and stores the value 1 5 in it. Unlike expressions, statements are instructions that 
do not evaluate to any value, they just perform some action. This is why there is no value 
displayed on the next line in the shell. 

It might be confusing to know which instructions are expressions and which are statements. Just 
remember that if a Python instruction evaluates to a single value, it's an expression. If a 
Python instruction does not, then it's a statement. 

An assignment statement is written as a variable, followed by the = operator, followed by an 
expression. The value that the expression evaluates to is stored inside the variable. (The value 1 5 
by itself is an expression that evaluates to 15.) 



Remember, variables store single values, not expressions. For example, if we had the statement, 
spam = 10 + 5, then the expression 10 + 5 would first be evaluated to 1 5 and then the 
value 1 5 would be stored in the variable spam. A variable is created the first time you store a 
value in it by using an assignment statement. 



¬ª&gt; spam = 15 
¬ª&gt; spam 
15 



equal sign 



variable 




name 



Figure 3-5. The parts of an assignment statement. 



¬ª&gt; 



32 http : //in vent wi thp y thon . com/hacking 



And here's an interesting twist. If we now enter spam + 5 into the shell, we get the integer 2 0 : 



¬ª&gt; 


spam = 


15 


&gt;¬ª 


spam + 


5 


20 






¬ª&gt; 







That may seem odd but it makes sense when we remember that we set the value of spam to 1 5. 
Because we've set the value of the variable spam to 1 5, the expression spam + 5 evaluates to 
the expression 15 + 5, which then evaluates to 2 0. A variable name in an expression evaluates 
to the value stored in that variable. 



Overwriting Variables 

We can change the value stored in a variable by entering another assignment statement. For 
example, try the following: 



¬ª&gt; 


spam 




15 


¬ª&gt; 


spam 


+ 


5 


20 








¬ª&gt; 


spam 




3 


¬ª&gt; 


spam 


+ 


5 


8 








¬ª&gt; 









The first time we enter spam + 5, the expression evaluates to 2 0, because we stored the value 
1 5 inside the variable spam. But when we enter spam = 3, the value 1 5 is overwritten (that 
is, replaced) with the value 3. Now, when we enter spam + 5, the expression evaluates to 8 
because the spam + 5 now evaluates to 3 + 5. The old value in spam is forgotten. 



To find out what the current value is inside a variable, enter the variable name into the shell. 



¬ª&gt; spam = 15 
¬ª&gt; spam 
15 

This happens because a variable by itself is an expression that evaluates to the value stored in the 
variable. This is just like how a value by itself is also an expression that evaluates to itself: 



¬ª&gt; 15 
15 



Email questions to the author: al@inventwithpython.com 



Chapter 3 - The Interactive Shell 33 



We can even use the value in the spam variable to assign spam a new value: 



&gt;¬ª 


spam = 


15 


¬ª&gt; 


spam = 


spam + 5 


20 






¬ª&gt; 







The assignment statement spam = spam + 5 is like saying, "the new value of the spam 
variable will be the current value of spam plus five." Remember that the variable on the left side 
of the = sign will be assigned the value that the expression on the right side evaluates to. We can 
keep increasing the value in spam by 5 several times: 



¬ª&gt; 


spam = 


15 






¬ª&gt; 


spam = 


spam 


+ 


5 


¬ª&gt; 


spam = 


spam 


+ 


5 


¬ª&gt; 


spam = 


spam 


+ 


5 


¬ª&gt; 


spam 








30 










¬ª&gt; 











Using More Than One Variable 

Your programs can have as many variables as you need. For example, let's assign different values 
to two variables named eggs and fizz: 



¬ª&gt; fizz = 10 
¬ª&gt; eggs = 15 



Now the fizz variable has 10 inside it, and eggs has 15 inside it. 



34 http://inventwithpython.com/hacking 




Figure 3-6. The "fizz" and "eggs" variables have values stored in them. 

Let's try assigning a new value to the spam variable. Enter spam = fizz + eggs into the 
shell, then enter spam into the shell to see the new value of spam. Type the following into the 
interactive shell: 



&gt;¬ª 


fizz = 


10 


¬ª&gt; 


eggs = 


15 


¬ª&gt; 


spam = 


fizz + eggs 


¬ª&gt; 


spam 




25 






¬ª&gt; 







The value in spam is now 25 because when we add fizz and eggs we are adding the values 
stored inside fizz and eggs. 

Variable Names 

The computer doesn't care what you name your variables, but you should. Giving variables 
names that reflect what type of data they contain makes it easier to understand what a program 
does. Instead of name, we could have called this variable abrahamLincoln or monkey. The 
computer will run the program the same (as long as you consistently use abrahamLincoln or 
monkey). 

Variable names (as well as everything else in Python) are case-sensitive. Case-sensitive means 
the same variable name in a different case is considered to be an entirely separate variable. So 
spam, SPAM, Spam, and sPAM are considered to be four different variables in Python. They 
each can contain their own separate values. 



Email questions to the author: al@inventwithpython.com 



Chapter 3 - The Interactive Shell 35 



It's a bad idea to have differently-cased variables in your program. If you stored your first name 
in the variable name and your last name in the variable NAME, it would be very confusing when 
you read your code weeks after you first wrote it. Did name mean first and NAME mean last, or 
the other way around? 

If you accidentally switch the name and NAME variables, then your program will still run (that is, 
it won't have any "syntax" errors) but it will run incorrectly. This type of flaw in your code is 
called a bug. A lot of programming is not just writing code but also fixing bugs. 

Camel Case 

It also helps to capitalize variable names if they include more than one word. If you store a string 
of what you had for breakfast in a variable, the variable name whatlHadForBreakf ast is 
much easier to read than whatihadf orbreakf ast. This is called camel case, since the 
casing goes up and down like a camel's humps. This is a convention (that is, an optional but 
standard way of doing things) in Python programming. (Although even better would be 
something simple, like todaysBreakfast. Capitalizing the first letter of each word after the 
first word in variable names makes the program more readable. 

Practice Exercises, Chapter 3, Set B 

Practice exercises can be found at ht^://invpxAQr^^J^gpractice3B. 

Summary - But When Are We Going to Start Hacking? 

Soon. But before we can hack ciphers, we need to learn some more basic programming concepts. 
We won't need to learn a lot before we start writing encryption programs, but there's one more 
chapter on programming we need to cover. 

In this chapter you learned the basics about writing Python instructions in the interactive shell. 
Python needs you to tell it exactly what to do in a strict way, because computers don't have 
common sense and only understand very simple instructions. You have learned that Python can 
evaluate expressions (that is, reduce the expression to a single value), and that expressions are 
values (such as 2 or 5) combined with operators (such as + or -). You have also learned that you 
can store values inside of variables so that your program can remember them to use them later on. 

The interactive shell is a very useful tool for learning what Python instructions do because it lets 
you type them in one at a time and see the results. In the next chapter, we will be creating 
programs of many instructions that are executed in sequence rather than one at a time. We will go 
over some more basic concepts, and you will write your first program! 



3 6 http ://inventwithpy thon. com/hacking 




Chapter 4 



Strings and Writing 
Programs 

Topics Covered In This Chapter: 

‚Ä¢ Strings 

‚Ä¢ String concatenation and replication 

‚Ä¢ Using IDLE to write source code 

‚Ä¢ Saving and running programs in IDLE 

‚Ä¢ The print () function 

‚Ä¢ The input ( ) function 

‚Ä¢ Comments 



That's enough of integers and math for now. Python is more than just a calculator. In this chapter, 
we will learn how to store text in variables, combine text together, and display text on the screen. 
We will also make our first program, which greets the user with the text, "Hello World!" and lets 
the user type in a name. 

Strings 

In Python, we work with little chunks of text called string values (or simply strings). All of our 
cipher and hacking programs deal with string values to turn plaintext like ' One if by land, 
two if by space. ' into ciphertext like 'Tqe kg im npqv, j st kg im oapxe . '. 
The plaintext and ciphertext are represented in our program as string values, and there's a lot of 
ways that Python code can manipulate these values. 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 37 



We can store string values inside variables just like integer and floating point values. When we 
type strings, we put them in between two single quotes ( ' ) to show where the string starts and 
ends. Type this in to the interactive shell: 



¬ª&gt; spam = 'hello' 

¬ª&gt; 

The single quotes are not part of the string value. Python knows that 'hello ' is a string and 
spam is a variable because strings are surrounded by quotes and variable names are not. 

If you type spam into the shell, you should see the contents of the spam variable (the ' hello ' 
string.) This is because Python will evaluate a variable to the value stored inside it: in this case, 
the string 'hello ' . 



¬ª&gt; spam = 'hello' 
¬ª&gt; spam 
'hello' 

¬ª&gt; 



Strings can have almost any keyboard character in them. (We'll talk about special "escape 
characters" later.) These are all examples of strings: 



¬ª&gt; 'hello' 
'hello' 

¬ª&gt; 'Hi there! ' 
'Hi there! ' 
¬ª&gt; 'KITTENS' 
'KITTENS' 



¬ª&gt; '7 apples, 14 oranges, 3 lemons' 
'7 apples, 14 oranges, 3 lemons' 

¬ª&gt; 'Anything not pertaining to elephants is i rrelephant. 1 
'Anything not pertaining to elephants is i rrelephant. ' 

¬ª&gt; '0*MwY%*&amp;OcfsdYO*&amp;gfC%YO*&amp;%3yc8r2 ' 
' 0*&amp;#wY%*&amp;0cf sdY0*&amp;gf C%YO*&amp;%3yc8r2 ' 

Notice that the ' ' string has zero characters in it; there is nothing in between the single quotes. 
This is known as a blank string or empty string. 



38 http://inventwithpython.com/hacking 



String Concatenation with the + Operator 

You can add together two string values into one new string value by using the + operator. Doing 
this is called string concatenation. Try entering 'Hello ' + 'World! ' into the shell: 



¬ª&gt; 'Hello' + 'World! ' 
'HelloWorld! ' 

¬ª&gt; 



To put a space between "Hello" and "World!", put a space at the end of the ' Hello ' string and 
before the single quote, like this: 



¬ª&gt; 'Hello ' + 'World! ' 
'Hello World! ' 

¬ª&gt; 



Remember, Python will concatenate exactly the strings you tell it to concatenate. If you want a 
space in the resulting string, there must be a space in one of the two original strings. 

The + operator can concatenate two string values into a new string value ('Hello ' + 
'World! 'to 'Hello World!'),just like it could add two integer values into a new integer 
value (2 + 2 to 4). Python knows what the + operator should do because of the data types of the 
values. Every value is of a data type. The data type of the value 'Hello ' is a string. The data 
type of the value 5 is an integer. The data type of the data that tells us (and the computer) what 
kind of data the value is. 

The + operator can be used in an expression with two strings or two integers. If you try to use the 
+ operator with a string value and an integer value, you will get an error. Type this code into the 
interactive shell: 



¬ª&gt; 'Hello' + 42 

Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, "in &lt;module&gt; 
TypeError: Can't convert 'int' object to str implicitly 
¬ª&gt; 'Hello' + '42' 
'Hello42' 
¬ª&gt; 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 39 



String Replication with the * Operator 

You can also use the * operator on a string and an integer to do string replication. This will 
replicate (that is, repeat) a string by however many times the integer value is. Type the following 
into the interactive shell: 



¬ª&gt; 'Hello' * 3 
'HelloHelloHello' 
¬ª&gt; spam = 'Abcdef ' 
¬ª&gt; spam = spam * 3 
¬ª&gt; spam 

'Abcdef Abcdef Abcdef 
¬ª&gt; spam = spam * 2 
¬ª&gt; spam 

' Abcdef Abcdef Abcdef Abcdef Abcdef Abcdef ' 

¬ª&gt; 

The * operator can work with two integer values (it will multiply them). It can also work with a 
string value and an integer value (it will replicate the string). But it cannot work with two string 
values, which would cause an error: 



¬ª&gt; 'Hello' * 'world! ' 

Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: can't multiply sequence by non-int of type 'str' 

¬ª&gt; 

What string concatenation and string replication show is that operators in Python can do different 
things based on the data types of the values they operate on. The + operator can do addition or 
string concatenation. The * operator can do multiplication or string replication. 

Printing Values with the print ( ) Function 

There is another type of Python instruction called a print ( ) function call. Type the following 
into the interactive shell: 



¬ª&gt; print('Hello! ') 
Hello! 

¬ª&gt; print(42) 
42 

¬ª&gt; 



40 http://inventwithpython.com/hacking 

A function (like print ( ) in the above example) has code in that performs a task, such as 
printing values on the screen. There are many different functions that come with Python. To call 
a function means to execute the code that is inside the function. 

The instructions in the above example pass a value to the print ( ) function in between the 
parentheses, and the print ( ) function will print the value to the screen. The values that are 
passed when a function is called are called arguments. (Arguments are the same as values 
though. We just call values this when they are passed to function calls.) When we begin to write 
programs, the way we make text appear on the screen is with the print ( ) function. 



You can pass an expression to the print ( ) function instead of a single value. This is because 
the value that is actually passed to the print ( ) function is the evaluated value of that 
expression. Try this string concatenation expression in the interactive shell: 



¬ª&gt; spam = 'Al 1 




¬ª&gt; print('Hello, 


' + spam) 


Hello, Al 




¬ª&gt; 





The 'Hello, ' + spam expression evaluates to 'Hello, ' + spam, which then 
evaluates to the string value ' Hello , Al ' . This string value is what is passed to the print ( ) 
function call. 



Escape Characters 

Sometimes we might want to use a character that cannot easily be typed into a string value. For 
example, we might want to put a single quote character as part of a string. But we would get an 
error message because Python thinks that single quote is the quote ending the string value, and 
the text after it is bad Python code instead of just the rest of the string. Type the following into the 
interactive shell: 



¬ª&gt; print('Al's cat is named Zophie. 


') 


File "&lt;stdin&gt;", line 1 




printC'Al's cat is named Zophie. 

A 


') 


SyntaxError: invalid syntax 




¬ª&gt; 





To use a single quote in a string, we need to use escape characters. An escape character is a 
backslash character followed by another character. For example, \t, \n or \ ' . The slash tells 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 41 

Python that the character after the slash has a special meaning. Type the following into the 
interactive shell: 



¬ª&gt; pri nt( ' Al\ ' s cat is named Zophie.') 
Al's cat is named Zophie. 

¬ª&gt; 

An escape character helps us print out letters that are hard to type into the source code. Table 4-1 
shows some escape characters in Python: 



Table 4-1. Escape Characters 


Escape Character 


What Is Actually Printed 


\\ 


Backslash (\) 


V 


Single quote (') 


\" 


Double quote (") 


\n 


Newline 


\t 


Tab 



The backslash always precedes an escape character, even if you just want a backslash in your 
string. This line of code would not work: 



&gt;¬ª print('He flew away "in a green\teal helicopter.') 
He flew away in a green eal helicopter. 

This is because the "t" in "teal" was seen as an escape character since it came after a backslash. 
The escape character \ t simulates pushing the Tab key on your keyboard. Escape characters are 
there so that strings can have characters that cannot be typed in. 

Instead, try this code: 



¬ª&gt; printC'He flew away in a green\\teal helicopter.') 
He flew away in a green\teal helicopter. 



Quotes and Double Quotes 

Strings don't always have to be in between two single quotes in Python. You can use double 
quotes instead. These two lines print the same thing: 



¬ª&gt; printC'Hello world') 
Hello world 

¬ª&gt; printC'Hello world") 



42 http://inventwithpython.com/hacking 



Hello world 



But you cannot mix single and double quotes. This line will give you an error: 



¬ª&gt; print('Hello world") 

SyntaxError: EOL while scanning single-quoted string 

¬ª&gt; 



I like to use single quotes so I don't have to hold down the shift key on the keyboard to type 
them. It's easier to type, and the computer doesn't care either way. 

But remember, just like you have to use the escape character \ ' to have a single quote in a string 
surrounded by single quotes, you need the escape character \ " to have a double quote in a string 
surrounded by double quotes. For example, look at these two lines: 



¬ª&gt; printC'I asked to borrow Alice\'s car for a week. She said, "Sure."') 
I asked to borrow Alice's car for a week. She said, "Sure." 
&gt;¬ª print("She said, \"I can't believe you let him borrow your car.\"") 
She said, "I can't believe you let him borrow your car." 

You do not need to escape double quotes in single -quote strings, and you do not need to escape 
single quotes in the double -quote strings. The Python interpreter is smart enough to know that if a 
string starts with one kind of quote, the other kind of quote doesn't mean the string is ending. 

Practice Exercises, Chapter 4, Set A 

Practice exercises can be found at http://inypy.con^^ 

Indexing 

Your encryption programs will often need to get a single character from a string. Indexing is the 
adding of square brackets [ and ] to the end of a string value (or a variable containing a string) 
with a number between them. This number is called the index, and tells Python which position in 
the string has the character you want. The index of the first character in a string is 0. The index 1 
is for the second character, the index 2 is for the third character, and so on. 

Type the following into the interactive shell: 



¬ª&gt; 


spam = 


¬ª&gt; 


spam[0] 


'H' 




¬ª&gt; 


spam[l] 


'e' 





Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 43 



&gt;¬ª spam[2] 
' 1 ' 

Notice that the expression spam [ 0 ] evaluates to the string value ' H ' , since H is the first 
character in the string 'Hello ' . Remember that indexes start at 0, not 1. This is why the H's 

index is 0, not 1. 



string: 1 



H 


e 


1 


1 


0 



indexes: 0 12 3 4 

Figure 4-1. The string 'Hello' and its indexes. 

Indexing can be used with a variable containing a string value or a string value by itself such as 
' Zophie ' . Type this into the interactive shell: 



¬ª&gt; 'Zophie' [2] 
V 

The expression ' Zophie ' [ 2 ] evaluates to the string value ' p ' . This ' p ' string is just like 
any other string value, and can be stored in a variable. Type the following into the interactive 
shell: 



&gt;¬ª eggs = ' Zopie'[2] 
¬ª&gt; eggs 

V 

¬ª&gt; 

If you enter an index that is too large for the string, Python will display an "index out of range" 
error message. There are only 5 characters in the string ' Hello ' . If we try to use the index 10, 
then Python will display an error saying that our index is "out of range": 



¬ª&gt; 'Hello' [10] 

Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
IndexError: string index out of range 

¬ª&gt; 



44 http://inventwithpython.com/hacking 



Negative Indexes 

Negative indexes start at the end of a string and go backwards. The negative index - 1 is the index 
of the last character in a string. The index -2 is the index of the second to last character, and so 
on. 



Type the following into the interactive shell: 



¬ª&gt; 


'Hello 


[-1] 


'0' 






¬ª&gt; 


'Hello 


[-2] 


'T 






¬ª&gt; 


'Hello 


[-3] 


'T 






¬ª&gt; 


'Hello 


[-4] 


'e' 






¬ª&gt; 


'Hello 


[-5] 


'H' 






¬ª&gt; 


'Hello 


[0] 


'H' 






¬ª&gt; 







Notice that - 5 and 0 are the indexes for the same character. Most of the time your code will use 
positive indexes, but sometimes it will be easier to use negative indexes. 



Slicing 

If you want to get more than one character from a string, you can use slicing instead of indexing. 
A slice also uses the [ and ] square brackets but has two integer indexes instead of one. The two 
indexes are separate by a : colon. Type the following into the interactive shell: 

¬ª&gt; 'Howdy' [0:3] 
'How' 

¬ª&gt; 

The string that the slice evaluates to begins at the first index and goes up to, but not including, 
the second index. The 0 index of the string value ' Howdy ' is the H and the 3 index is the d. 
Since a slice goes up to but not including the second index, the slice ' Howdy ' [0:3] evaluates 
to the string value ' How ' . 

Try typing the following into the interactive shell: 



¬ª&gt; 'Hello world! ' [0:5] 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 45 



'Hello' 

¬ª&gt; 'Hello world! ' [6:12] 
'world! ' 

¬ª&gt; 'Hello world! ' [-6:-l] 
'world' 

¬ª&gt; 'Hello world! ' [6:12] [2] 
'r' 

¬ª&gt; 

Notice that the expression 'Hello world! ' [6:12] [2] first evaluates to 'world! ' [2] 
which is an indexing that further evaluates to ' r ' . 

Unlike indexes, slicing will never give you an error if you give it too large of an index for the 
string. It will just return the widest matching slice it can: 



&gt;¬ª 'Hello' [0:999] 
'Hello' 

¬ª&gt; 'Hello' [2:999] 
'llo' 

¬ª&gt; 'Hello' [1000:2000] 

¬ª&gt; 

The expression 'Hello' [1000:2000] returns a blank string because the index 10 00 is after 
the end of the string, so there are no possible characters this slice could include. 

Blank Slice Indexes 

If you leave out the first index of a slice, Python will automatically think you want to specify 
index 0 for the first index. The expressions ' Howdy ' [0:3] and ' Howdy ' [ : 3 ] evaluate the 
same string: 



¬ª&gt; 'Howdy' [:3] 
'How' 

¬ª&gt; 'Howdy' [0:3] 
'How' 

¬ª&gt; 

If you leave out the second index, Python will automatically think you want to specify the rest of 
the string: 



¬ª&gt; 'Howdy' [2:] 
'wdy' 



46 http://inventwithpython.com/hacking 



¬ª&gt; 



Slicing is a simple way to get a "substring" from a larger string. (But really, a "substring" is still 
just a string value like any other string.) Try typing the following into the shell: 



¬ª&gt; myName = 'Zophie the Fat Cat' 

¬ª&gt; myName [-7 : ] 

'Fat Cat' 

¬ª&gt; myName [: 10] 

'Zophie the' 

¬ª&gt; myName [7:] 

'the Fat Cat' 

¬ª&gt; 



Practice Exercises, Chapter 4, Set B 

Practice exercises can be found at ht^://invpxcpr^^J^^ra(^ce4B. 

Writing Programs in IDLE's File Editor 

Until now we have been typing instructions one at a time into the interactive shell. When we 
write programs though, we type in several instructions and have them run without waiting on us 
for the next one. Let's write our first program! 

The name of the software program that provides the interactive shell is called IDLE, the 
Interactive DeveLopement Environment. IDLE also has another part besides the interactive shell 
called the file editor. 

At the top of the Python shell window, click on the File ‚ñ∫ New Window. A new blank window 
will appear for us to type our program in. This window is the file editor. The bottom right of the 
file editor window will show you line and column that the cursor currently is in the file. 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 47 



7i Untitled 






File Edit Format Run Options Windows Help 








|Lrcl[Col:0 



Figure 4-2. The file editor window. The cursor is at line 1, column 0. 

You can always tell the difference between the file editor window and the interactive shell 
window because the interactive shell will always have the &gt;¬ª prompt in it. 

Hello World! 

A tradition for programmers learning a new language is to make their first program display the 
text "Hello world!" on the screen. We'll create our own Hello World program now. 

Enter the following text into the new file editor window. We call this text the program's source 
code because it contains the instructions that Python will follow to determine exactly how the 
program should behave. 

Source Code of Hello World 

This code can be downloaded from http;//inypy.coirVhello,py. If you get errors after typing this 
code in, compare it to the book's code with the online diff tool at h^_^/mvpy.corr^acldng^ff (or 



email me at al@inventwithpython.com if you are still stuck.) 




hello. py 


1. # This program says hello and asks for my name. 




2. print ('Hello world! ') 




3. print('What is your name?') 




4. myName = input() 




5. print('It is good to meet you, ' + myName) 





The IDLE program will give different types of instructions different colors. After you are done 
typing this code in, the window should look like this: 



48 http://inventwithpython.com/hacking 



7i¬ª hello.py - C:/hello.py 



File Edit Format Run Option:- Windows Help 



# This program says hello and asks for my name, 
print ('Hello world! 1 ) 
print ('What is your name?') 
myName = input ( ) 

print (' It is good to meet yc:, " + ir.yName)| 



Ln:5 Col: 42 



Figure 4-3. The file editor window will look like this after you type in the code. 

Saving Your Program 

Once you've entered your source code, save it so that you won't have to retype it each time we 
start IDLE. To do so, from the menu at the top of the File Editor window, choose File ‚ñ∫ Save 
As. The Save As window should open. Enter hello.py in the File Name field, then click Save. 
(See Figure 4-4.) 

You should save your programs every once in a while as you type them. That way, if the 
computer crashes or you accidentally exit from IDLE you won't lose everything you've typed. As 
a shortcut, you can press Ctrl-S on Windows and Linux or S¬ß -S on OS X to save your file. 



Save in: | | Python 32 



9 

Recent Places 



Desktop 

23 

Libraries 

K 

Computer 

ft 

Netw :irk 



3 



IS df Hh 



Name 


Type 


Size [ 


DLL: 


File folder 


e 


Doc 


File folder 


e 


include 


File folder 


e 


Lib 


File folder 






File folder 


t 


Scripts 


File folder 




tcl 


File folder 


t 


Tools 


File folder 


e 


hello.py 


Python File 


1KB 7 



File name: 

Save as type : I Python files (".py ,*.pyw) 



Save 



Cancel 



Figure 4-4. Saving the program. 

Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 49 



A video tutorial of how to use the file editor is available from this book's website at 
http://inypy,con^ 

Running Your Program 

Now it's time to run our program. Click on Run ‚ñ∫ Run Module or just press the F5 key on your 
keyboard. Your program should run in the shell window that appeared when you first started 
IDLE. Remember, you have to press F5 from the file editor's window, not the interactive shell's 
window. 

When your program asks for your name, go ahead and enter it as shown in Figure 4-5: 




File E 



* Thi 
print 
print 
myNam 
prir.t 



File Edit Shell Debug Options Windows 

Python 3.2 (r32: 88445, Feb 20 201 
00 32 bit (Intel) ] on Win32 
Type "copyright", "credits" or "J 
ormation. 

¬ª&gt; 

Hello world! 

What is your nair.e? 

Albert 

It is good to meet you, Albert 
¬ª&gt; 



Figure 4-5. What the interactive shell looks like when running the "Hello World" program. 

Now when you push Enter, the program should greet you (the user, that is, the one using the 
program) by name. Congratulations! You've written your first program. You are now a beginning 
computer programmer. (You can run this program again if you like by pressing F5 again.) 

If you get an error that looks like this: 



Hello world! 

What is your name? 

Albert 

Traceback (most recent call last): 

File "C:/Python27/hello.py" , line 4, in &lt;module&gt; 
myName = input() 

File "&lt;string&gt;", line 1, in &lt;module&gt; 
NameError: name 'Albert' is not defined 



50 http : //in vent wi thp y thon . com/hacking 



...this means you are running the program with Python 2, instead of Python 3. This makes the 
penguin in the first chapter sad. (The error is caused by the input ( ) function call, which does 
different things in Python 2 and 3.) Please install Python 3 from ht^j//python.prg/getit before 
continuing. 

Opening The Programs You've Saved 

Close the file editor by clicking on the X in the top corner. To reload a saved program, choose 
File ‚ñ∫ Open from the menu. Do that now, and in the window that appears choose hello.py and 
press the Open button. Your saved hello.py program should open in the File Editor window. 

How the "Hello World" Program Works 

Each line that we entered is an instruction that tells Python exactly what to do. A computer 
program is a lot like a recipe. Do the first step first, then the second, and so on until you reach the 
end. Each instruction is followed in sequence, beginning from the very top of the program and 
working down the list of instructions. After the program executes the first line of instructions, it 
moves on and executes the second line, then the third, and so on. 

We call the program's following of instructions step-by-step the program execution, or just the 
execution for short. The execution starts at the first line of code and then moves downward. The 
execution can skip around instead of just going from top to bottom, and we'll find out how to do 
this in the next chapter. 

Let's look at our program one line at a time to see what it's doing, beginning with line number 1. 

Comments 

hello.py 

1. # This program says hello and asks for my name. 

This line is called a comment. Comments are not for the computer, but for you, the programmer. 
The computer ignores them. They're used to remind you of what the program does or to tell 
others who might look at your code what it is that your code is trying to do. Any text following a 
# sign (called the pound sign) is a comment. (To make it easier to read the source code, this 
book prints out comments in a light gray-colored text.) 

Programmers usually put a comment at the top of their code to give the program a title. The IDLE 
program displays comments in red text to help them stand out. 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 5 1 



Functions 

A function is kind of like a mini-program inside your program. It contains lines of code that are 
executed from top to bottom. Python provides some built-in functions that we can use (you've 
already used the print ( ) function). The great thing about functions is that we only need to 
know what the function does, but not how it does it. (You need to know that the print ( ) 
function displays text on the screen, but you don't need to know how it does this.) 

A function call is a piece of code that tells our program to run the code inside a function. For 
example, your program can call the print ( ) function whenever you want to display a string on 
the screen. The print ( ) function takes the value you type in between the parentheses as input 
and displays the text on the screen. Because we want to display Hello world ! on the screen, 
we type the print function name, followed by an opening parenthesis, followed by the ' Hello 
world! ' string and a closing parenthesis. 



The print () function 





hello.py 


2. pr-int('Hel"lo world! ') 




3. print('What is your name?') 





This line is a call to the print ( ) function (with the string to be printed going inside the 
parentheses). We add parentheses to the end of function names to make it clear that we're 
referring to a function named print () , not a variable named print. The parentheses at the 
end of the function let us know we are talking about a function, much like the quotes around the 
number '42' tell us that we are talking about the string '42' and not the integer 4 2 . 



Line 3 is another print ( ) function call. This time, the program displays "What is your name?" 



The input ( ) function 





hello.py 


4. myName = inputO 





Line 4 has an assignment statement with a variable (myName) and a function call (input ( ) ). 
When input ( ) is called, the program waits for the user to type in some text and press Enter. 
The text string that the user types in (their name) becomes the string value that is stored in 

myName. 



Like expressions, function calls evaluate to a single value. The value that the function call 
evaluates to is called the return value. (In fact, we can also use the word "returns" to mean the 



52 http : //in vent wi thp y thon . com/hacking 

same thing for function calls as "evaluates".) In this case, the return value of the input ( ) 
function is the string that the user typed in-their name. If the user typed in Albert, the input ( ) 
function call evaluates (that is, returns) to the string ' Albert ' . 

The function named input ( ) does not need any arguments (unlike the print ( ) function), 
which is why there is nothing in between the parentheses. 



hello. py 

5. print ('It is good to meet you, ' + myName) 

For line 5's print ( ) call, we use the plus operator (+) to concatenate the string 'It is 
good to meet you, ' and the string stored in the myName variable, which is the name that 
our user input into the program. This is how we get the program to greet us by name. 

Ending the Program 

Once the program executes the last line, it stops. At this point it has terminated or exited and 

all of the variables are forgotten by the computer, including the string we stored in myName. If 
you try running the program again and typing a different name it will print that name. 

Hello world! 

What is your name? 

Al an 

It is good to meet you, Alan 

Remember, the computer only does exactly what you program it to do. In this program it is 
programmed to ask you for your name, let you type in a string, and then say hello and display the 
string you typed. 

But computers are dumb. The program doesn't care if you type in your name, someone else's 
name, or just something silly. You can type in anything you want and the computer will treat it 
the same way: 



Hello world! 

What is your name? 

poop 

It is good to meet you, poop 



Practice Exercises, Chapter 4, Set C 

Practice exercises can be found at ht^://mvpxcprrj^^togpractice4C. 



Email questions to the author: al@inventwithpython.com 



Chapter 4 - Strings and Writing Programs 53 



Summary 

Writing programs is just about knowing how to speak the computer's language. While you 
learned a little bit of this in the last chapter, in this chapter you've put together several Python 
instructions to make a complete program that asks for the user's name and then greets them. 

All of our programs later in this book will be more complex and sophisticated, but don't worry. 
The programs will all be explained line by line. And you can always enter instructions into the 
interactive shell to see what they do before they are all put into a complete program. 

Now let's start with our first encryption program: the reverse cipher. 



54 http://inventwithpython.com/hacking 




Chapter 5 



The Reverse Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The len ( ) function 

‚Ä¢ while loops 

‚Ä¢ The Boolean data type 

‚Ä¢ Comparison operators 

‚Ä¢ Conditions 

‚Ä¢ Blocks 



"Every man is surrounded by a neighborhood of 
voluntary spies." 

Jane Austen 



The Reverse Cipher 

The reverse cipher encrypts a message by printing it in reverse order. So "Hello world!" encrypts 
to "Idlrow olleH". To decrypt, you simply reverse the reversed message to get the original 
message. The encryption and decryption steps are the same. 

The reverse cipher is a very weak cipher. Just by looking at its ciphertext you can figure out it is 
just in reverse order, .syas ti tahw tuo erugif Hits ylbaborp nac uoy ,detpyrcne si siht hguoht neve 
,elpmaxe roF 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 55 



But the code for the reverse cipher program is easy to explain, so we'll use it as our first 
encryption program. 

Source Code of the Reverse Cipher Program 

In IDLE, click on File ‚ñ∫ New Window to create a new file editor window. Type in the following 
code, save it as reverseCipher.py, and press F5 to run it: (Remember, don't type in the line 
numbers at the beginning of each line.) 



Source code for reverseCipher.py 

1. # Reverse Cipher 

2. # http://inventwithpython.com/hacknng (BSD Licensed) 
3. 

4. message = 'Three can keep a secret, if two of them are dead.' 

5 . translated = ' ' 
6. 

7. i = 1 en (message) - 1 

8. while i &gt;= 0: 

9. translated = translated + message[i] 
10. i=i-l 

11. 

12. print(translated) 



Sample Run of the Reverse Cipher Program 

When you run this program the output will look like this: 



.daed era meht fo owt fi ,terces a peek nac eerhT 

To decrypt this message, copy the ".daed era meht fo owt fi ,terces a peek nac eerhT" text to the 
clipboard (see http://inypy.cpnVcopypaste for instructions on how to copy and paste text) and 
paste it as the string value stored in me s sage on line 4. Be sure to have the single quotes at the 
beginning and end of the string. The new line 4 will look like this (with the change in bold): 



reverseCi pher . py 

4. message = '.daed era meht fo owt fi .terces a peek nac eerhT' 

Now when you run the reverseCipher.py program, the output will decrypt to the original 
message: 



Three can keep a secret, if two of them are dead. 



5 6 http ://inventwithpy thon. com/hacking 



Checking Your Source Code with the Online Diff Tool 

Even though you could copy and paste or download this code from this book's website, it is very 
helpful to type in this program yourself. This will give you a better idea of what code is in this 
program. However, you might make some mistakes while typing it in yourself. 

To compare the code you typed to the code that is in this book, you can use the book's website's 
online diff tool. Copy the text of your code and open http://inypyvCpnVhackingdiff in your web 
browser. Paste your code into the text field on this web page, and then click the Compare button. 
The diff tool will show any differences between your code and the code in this book. This is an 
easy way to find typos that are causing errors. 



Q O ‚Ä¢‚Ä¢ ft * 0 



Source Code 
Resources 
Traces 
Diff Tool 
Videos 
Extra Content 

About the Author 
Author's Blog 



Step 1 

Select the program you 
Program; 



e typing in from this dropdown menu: 



affineCipher py 
affineHacker py 


1 


affirieKeyTest py 
buggy py 








Step 2 

Copy and paste your code here to see how it is different from the code in the book: 



= Z zr.t er.cryn ted/ de ;rvj cti stnr.e ‚ñ† 
print (translated) 



# ccpy the er.crypced ‚ñ† decrypted . 
pyper clip . ccpy i tr-ar.sla^ed.' 



i 



Step 3 

Click the 'Compare ' button: 
Compare | 





The Book's Program 


Your Program 


2 


# Caesar Cipher 

# http : //inventwithpython. com/hacking 
(BSD Licensed) 


1 # Caesar Cipher 

2 # http://inventwithpython.com/hacking 
(BSD Licensed) 


3 




3 1 


4 


import pyperclip 


4 import pyerclip 


5 




5 



Figure 5-1. The online diff tool at http;//jnypy/hackjngdjff 

How the Program Works 



1. # Reverse Cipher 

2. # http://inventwithpython.com/hacking (BSD Licensed) 



reverseCi pher. py 



The first two lines are comments explaining what the program is, and also the website where you 
can find it. The "BSD Licensed" part means that this program is free to copy and modify by 
anyone as long as the program retains the credits to the original author (in this case, the book's 
website at http;//inwntw^ (The full text of the Berkeley Software 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 57 



Distribution license can be seen at http;//inypy.con^sd) I like to have this info in the file so if it 
gets copied around the Internet, a person who downloads it will always know where to look for 
the original source. They'll also know this program is open source software and free to distribute 
to others. 



reverseCi pher . py 

message = 'Three can keep a secret, if two of them are dead. 1 

Line 4 stores the string we want to encrypt in a variable named message. Whenever we want to 
encrypt or decrypt a new string we will just type the string directly into the code on line 4. (The 
programs in this book don't call input ( ) , instead the user will type in the message into the 
source code. You can just change the source directly before running the program again to encrypt 
different strings.) 





reverseCi pher . py 


5. translated = ' ' 





The translated variable is where our program will store the reversed string. At the start of the 
program, it will contain the blank string. (Remember that the blank string is two single quote 
characters, not one double quote character.) 



The len () Function 





reverseCi pher . py 


7. i = len (message) - 1 





Line 6 is just a blank line, and Python will simply skip it. The next line of code is on line 7. This 
code is just an assignment statement that stores a value in a variable named i. The expression that 
is evaluated and stored in the variable is len (message) - 1. 



The first part of this expression is len (message) . This is a function call to the len ( ) 
function. The len ( ) function accepts a string value argument (just like the print ( ) function 
does) and returns an integer value of how many characters are in the string (that is, the length of 
the string). In this case, we pass the message variable to len ( ) , so len (message) will tell 
us how many characters are in the string value stored in message. 

Let's experiment in the interactive shell with the len ( ) function. Type the following into the 
interactive shell: 



¬ª&gt; lenC'Hello') 
5 



58 http://inventwithpython.com/hacking 



¬ª&gt; 


lenC ') 




0 






&gt;&gt;&gt; 


cnam ‚Äî 1 Al 1 

_} l_/ 1 1 1 / \ I 




¬ª&gt; 


1 en (spam) 




2 






¬ª&gt; 


1 en ('Hello' + ' 


' + 'world! ') 


12 






&gt;¬ª 







From the return value of len ( ) , we know the string 'Hello ' has five characters in it and the 
blank string has zero characters in it. If we store the string ' Al ' in a variable and then pass the 
variable to len (), the function will return 2. If we pass the expression ' Hello ' + ' ' + 
'world! ' to the len () function, it returns 1 2 . This is because 'Hello' + ' ' + 
'world! ' will evaluate to the string value 'Hello world! ', which has twelve characters in 
it. (The space and the exclamation point count as characters.) 

Line 7 finds the number of characters in message, subtracts one, and then stores this number in 
the i variable. This will be the index of the last character in the message string. 

Introducing the while Loop 



reverseCi pher. py 

while i &gt;= 0: 



This is a new type of Python instruction called a while loop or while statement. A while 
loop is made up of four parts: 

1 . The wh i 1 e keyword. 

2. An expression (also called a condition) that evaluates to the Boolean values True or 
False. (Booleans are explained next in this chapter.) 

3. A : colon. 

4. A block (explained later) of indented code that comes after it, which is what lines 9 and 
10 are. (Blocks are explained later in this chapter.) 

1. The while keyword 

A 2. A condition 



n - ^ A colon 

translated = translated + ir.es3ace[i; 
i = i - 1 



4. A block of code 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 59 



Figure 5-2. The parts of a while loop statement. 

To understand while loops, we will first need to learn about Booleans, comparison operators, 
and blocks. 

The Boolean Data Type 

The Boolean data type has only two values: True or False. These values are case-sensitive 
(you always need to capitalize the T and F, and leave the rest in lowercase). They are not string 
values. You do not put a ' quote character around True or False. We will use Boolean values 
(also called bools) with comparison operators to form conditions. (Explained later after 
Comparison Operators.) 



Like a value of any other data type, bools can be stored in variables. Type this into the interactive 
shell: 



¬ª&gt; spam = True 




¬ª&gt; spam 




True 




¬ª&gt; spam = False 




¬ª&gt; spam 




False 




¬ª&gt; 




Comparison Operators 




In line 8 of our program, look at the expression after the while keyword: 






reversed' pher.py 


8. while i &gt;= 0: 





The expression that follows the while keyword (the i &gt;= 0 part) contains two values (the 
value in the variable i, and the integer value 0) connected by an operator (the &gt;= sign, called the 
"greater than or equal" operator). The &gt;= operator is called a comparison operator. 



The comparison operator is used to compare two values and evaluate to a True or False 
Boolean value. Table 5-1 lists the comparison operators. 



60 http://inventwithpython.com/hacking 



Table 5-1. Comparison operators. 



Operator Sign Operator Name 



&lt; 


Less than 


&gt; 


Greater than 


&lt;= 


Less than or equal to 


&gt;= 


Greater than or equal to 




Equal to 


1 = 


Not equal to 



Enter the following expressions in the interactive shell to see the Boolean value they evaluate to: 



¬ª&gt; 0 &lt; 6 
True 

¬ª&gt; 6 &lt; 0 
Fal se 

&gt;¬ª 50 &lt; 10.5 
Fal se 

¬ª&gt; 10.5 &lt; 11.3 
True 

¬ª&gt; 10 &lt; 10 
False 

The expression 0 &lt; 6 returns the Boolean value True because the number 0 is less than the 
number 6. But because 6 is not less than 0, the expression 6 &lt; 0 evaluates to False. 5 0 is not 
less than 10 . 5, so 5 0 &lt; 10 . 5 is False. 10 . 5 is less than 11 . 3, so 10 &lt; 1 1 . 3 evaluates 
to True. 

Look again at 10 &lt; 10. It is False because the number 1 0 is not smaller than the number 1 0 . 
They are exactly the same size. If Alice was the same height as Bob, you wouldn't say that Alice 
is shorter than Bob. That statement would be false. 



Try typing in some expressions using the other comparison operators: 



¬ª&gt; 10 


&lt;= 


20 


True 






¬ª&gt; 10 


&lt;= 


10 


True 






¬ª&gt; 10 


&gt;= 


20 


False 






¬ª&gt; 20 


&gt;= 


20 


True 







Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 61 



¬ª&gt; 



Remember that for the "less than or equal to" and "greater than or equal to" operators, the &lt; or &gt; 
sign always comes before the = sign. 



Type in some expressions that use the == (equal to) and ! = (not equal to) operators into the shell 
to see how they work: 



¬ª&gt; 10 == 10 




True 




¬ª&gt; 10 == 11 




rd 1 be 




¬ª&gt; 11 == 10 




False 




¬ª&gt; 10 != 10 




False 




¬ª&gt; 10 != 11 




True 




¬ª&gt; 'Hello' == 


'Hello' 


True 




¬ª&gt; 'Hello' == 


'Good bye' 


False 




¬ª&gt; 'Hello' == 


'HELLO' 


False 




¬ª&gt; 'Good bye' 


!= 'Hello' 


True 





Notice the difference between the assignment operator (=) and the "equal to" comparison 
operator (==). The equal (=) sign is used to assign a value to a variable, and the equal to (==) 
sign is used in expressions to see whether two values are the same. If you're asking Python if two 
things are equal, use ==. If you are telling Python to set a variable to a value, use =. 



String and integer values will always be not-equal to each other. For example, try entering the 
following into the interactive shell: 



¬ª&gt; 42 == 


'Hello' 


False 




¬ª&gt; 42 == 


'42' 


Fal se 




¬ª&gt; 10 == 


10.0 


True 





62 http://inventwithpython.com/hacking 



Just remember that every expression with comparison operators always evaluates to the value 
True or the value False. 

Conditions 

A condition is another name for an expression when it is used in a while or if statement, (if 
statements aren't used in the reverse cipher program, but will be covered in the next chapter.) 
Conditions usually have comparison operators, but conditions are still just expressions. 

Blocks 

A block is one or more lines of code grouped together with the same minimum amount of 
indentation (that is, the number of spaces in front of the line). You can tell where a block begins 
and ends by looking at the line's indentation. 

A block begins when a line is indented by four spaces. Any following line that is also indented by 
at least four spaces is part of the block. When a line is indented with another four spaces (for a 
total of eight spaces in front of the line), a new block begins inside the block. A block ends when 
there is a line of code with the same indentation before the block started. 

Let's look at some imaginary code (it doesn't matter what the code is, we are only paying 
attention to the indentation of each line). We will replace the indenting spaces with black squares 
to make them easier to count: 



1. codecodecodecodecodecodecode # zero spaces of indentation 

2. ‚ñ† ‚ñ† ‚ñ† -codecodecodecodecodecodecodecodecode # four spaces of indentation 

3. ‚ñ†‚ñ†‚ñ†‚ñ†codecodecodecodecodecodecode # four spaces of indentation 

4. codecodecodecodecodecodecodecodecode # eight spaces of indentation 

5. ‚ñ† ‚ñ† ‚ñ† -codecodecodecodecode # four spaces of indentation 
6. 

7. ‚ñ† ‚ñ† ‚ñ† -codecodecodecodecodecode # four spaces of indentation 

8. codecodecodecodecodecodecodecodecodecodecode # zero spaces of indentation 

You can see that line 1 has no indentation, that is, there are zero spaces in front of the line of 
code. But line 2 has four spaces of indentation. Because this is a larger amount of indentation 
than the previous line, we know a new block has begun. Line 3 also has four spaces of 
indentation, so we know the block continues on line 3. 

Line 4 has even more indentation (8 spaces), so a new block has begun. This block is inside the 
other blocks. In Python, you can have blocks -within-blocks. 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 63 



On line 5, the amount of indentation has decreased to 4, so we know that the block on the 
previous line has ended. Line 4 is the only line in that block. Since line 5 has the same amount of 
indentation as the block from line 3, we know that the block has continue on to line 5. 

Line 6 is a blank line, so we just skip it. 

Line 7 has four spaces on indentation, so we know that the block that started on line 2 has 
continued to line 7. 

Line 8 has zero spaces of indentation, which is less indentation than the previous line. This 
decrease in indentation tells us that the previous block has ended. 

There are two blocks in the above make Relieve code. The first block goes from line 2 to line 7. 
The second block is just made up of line 4 (and is inside the other block). 

(As a side note, it doesn't always have to be four spaces. The blocks can use any number of 
spaces, but the convention is to use four spaces.) 



The while Loop Statement 







reverseCi pher. py 


8. 


while i &gt;= 0: 




9. 


translated = translated + message [i] 




10. 


i=i-l 




11. 






12. 


pri nt(translated) 





Let's look at the while statement on line 8 again. What a while statement tells Python to do is 
first check to see what the condition (which on line 8 is i &gt;= 0) evaluates to. If the condition 
evaluates to True, then the program execution enters the block following the while statement. 
From looking at the indentation, this block is made up of lines 9 and 10. 



If the while statement's condition evaluates to False, then the program execution will skip the 
code inside the following block and jump down to the first line after the block (which is line 12). 

If the condition was True, the program execution starts at the top of the block and executes each 
line in turn going down. When it reaches the bottom of the block, the program execution jumps 
back to the while statement on line 8 and checks the condition again. If it is still True, the 
execution jumps into the block again. If it is False, the program execution will skip past it. 

You can think of the while statement while i &gt;= 0 : as meaning, "while the variable i is 
greater than or equal to zero, keep executing the code in the following block". 



64 http://inventwithpython.com/hacking 



"Growing" a String 

Remember on line 7 that the i variable is first set to the length of the mes sage minus one, and 
the while loop on line 8 will keep executing the lines inside the following block until the 
condition i &gt;= 0 is False. 







reverseCi pher. py 


7. 


i = Ten (message) - 1 




8. 


while i &gt;= 0: 




9. 


translated = translated + message [i] 




10. 


i=i-l 




11. 






12. 


pri nt(translated) 





There are two lines inside the while statement's block, line 9 and line 10. 



Line 9 is an assignment statement that stores a value in the translated variable. The value 
that is stored is the current value of translated concatenated with the character at the index i 
in message. In this way, the string value stored in translated "grows" until it becomes the 
fully encrypted string. 

Line 10 is an assignment statement also. It takes the current integer value in i and subtracts one 
from it (this is called decrementing the variable), and then stores this value as the new value of 
i. 

The next line is line 12, but since this line has less indentation, Python knows that the while 
statement's block has ended. So rather than go on to line 12, the program execution jumps back to 
line 8 where the while loop's condition is checked again. If the condition is True, then the 
lines inside the block (lines 9 and 10) are executed again. This keeps happening until the 
condition is False (that is, when i is less than 0), in which case the program execution goes to 
the first line after the block (line 12). 

Let's think about the behavior of this loop. The variable i starts off with the value of the last 
index of message and the translated variable starts off as the blank string. Then inside the 
loop, the value of message [i] (which is the last character in the message string, since i will 
have the value of the last index) is added to the end of the translated string. 

Then the value in i is decremented (that is, reduced) by 1. This means that mes sage [ i ] will 
be the second to last character. So while i as an index keeps moving from the back of the string 
in message to the front, the string message [i] is added to the end of translated. This is 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 65 



what causes translated to hold the reverse of the string in the message. When i is finally 
set to -1, then the while loop's condition will be False and the execution jumps to line 12. 





reversed' pher.py 


12. print(translated) 





At the end of our program on line 12, we print out the contents of the translated variable 
(that is, the string '.daed era meht fo owt fi , terces a peek nac eerhT')to 
the screen. This will show the user what the reversed string looks like. 



If you are still having trouble understanding how the code in the while loop reverses the string, 
try adding this new line inside the while loop: 







reverseCi pher . py 


8. 


while i &gt;= 0: 




9. 


translated = translated + message [i] 




10. 


print(i, message[i] , translated) 




11. 


i=i-l 




12. 






13. 


print(translated) 





This will print out the three expressions i, message [i ] , and translated each time the 
execution goes through the loop (that is, on each iteration of the loop). The commas tell the 
print ( ) function that we are printing three separate things, so the function will add a space in 
between them. Now when you run the program, you can see how the translated variable 
"grows". The output will look like this: 



48 












47 


d 


.d 








46 


a 


.da 








45 


e 


.dae 








44 


d 


.daed 








43 




.daed 








42 


e 


.daed 


e 






41 


r 


.daed 


er 






40 


a 


.daed 


era 






39 




.daed 


era 






38 


m 


.daed 


era 


m 




37 


e 


. daed 


era 


me 




36 


h 


.daed 


era 


meh 




35 


t 


.daed 


era 


meht 




34 




.daed 


era 


meht 




33 


f 


.daed 


era 


meht 


f 


32 


0 


.daed 


era 


meht 


fo 


31 




.daed 


era 


meht 


fo 



66 http://inventwithpython.com/hacking 



30 


o 


. daed 


e ra 


meht 


fo 


o 








29 


w 


. daed 


e ra 


meht 


fo 


ow 








28 


t 


. daed 


e ra 


meht 


fo 


owt 








27 




. daed 


e ra 


meht 


fo 


owt 








26 


f 


. daed 


e ra 


meht 


fo 


owt 


f 






25 


i 


. daed 


e ra 


meht 


fo 


owt 


fi 






24 




. daed 


e ra 


meht 


fo 


owt 


fi 






23 




. daed 


e ra 


tneht 


fo 


owt 


fi 






22 


t 


. daed 


e ra 


tneht 


fo 


owt 


fi 


t 




21 




. daed 


e ra 


tneht 


fo 


owt 


fi 


te 




20 


r 


. daed 


e ra 


tneht 


fo 


owt 


fi 


ter 




19 


c 


. daed 


e ra 


tneht 


fo 


owt 


fi 


, te rc 




18 




. daed 


e ra 


tneht 


fo 


owt 


fi 


, te rce 




17 


s 


. daed 


e ra 


tneht 


fo 


owt 


fi 


, terces 




16 




.daed 


era 


tneht 


fo 


owt 


fi 


,terces 




15 


a 


.daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 


14 




.daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 


13 


P 


. daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 


12 


e 


.daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 


11 


e 


.daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 


10 


k 


.daed 


era 


tneht 


fo 


owt 


fi 


, terces 


a 



9 .daed era tneht fo owt fi , terces a peek 
8 n .daed era meht fo owt fi , terces a peek n 
7 a .daed era meht fo owt fi , terces a peek na 
6 c .daed era meht fo owt fi , terces a peek nac 
5 .daed era meht fo owt fi , terces a peek nac 
4 e .daed era meht fo owt fi , terces a peek nac e 
3 e .daed era meht fo owt fi , terces a peek nac ee 
2 r .daed era meht fo owt fi , terces a peek nac eer 
1 h .daed era meht fo owt fi , terces a peek nac eerh 
0 T .daed era meht fo owt fi , terces a peek nac eerhT 
.daed era meht fo owt fi , terces a peek nac eerhT 

The first line, which shows "4 8 . . ", is showing what the expressions i, me s sage [ i ] , and 
translated evaluate to after the string message [i ] has been added to the end of 
translated but before i is decremented. You can see that the first time the program execution 
goes through the loop, i is set to 4 8, and so message [ i] (that is, message [ 48 ] ) is the string 
' . ' . The translated variable started as a blank string, but when message [ i ] was added to 
the end of it on line 9, it became the string value ' . ' . 

On the next iteration of the loop, the print ( ) call displays "4 7 . . d". You can see that i has 
been decremented from 4 8 to 4 7, and so now message[i] is me s s age [ 4 7 ] , which is the 
' d ' string. (That's the second "d" in "dead".) This ' d ' gets added to the end of translated 
so that translated is now set to ' . d ' . 

Now you can see how the translated variable's string is slowly "grown" from a blank string 
to the reverse of the string stored in me s sage. 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 67 



Tracing Through the Program, Step by Step 

The previous explanations have gone through what each line does, but let's go step by step 
through the program the same way the Python interpreter does. The interpreter starts at the very 
top, executes the first line, then moves down a line to execute the next instruction. The blank lines 
and comments are skipped. The while loop will cause the program execution will loop back to 
the start of the loop after it finishes. 



Here is a brief explanation of each line of code in the same order that the Python interpreter 
executes it. Follow along with to see how the execution moves down the lines of the program, but 
sometimes jumps back to a previous line. 









reverseCi pher. py 


1. 


# Reverse Cipher 






2. 
3. 


# http://inventwithpython.com/hacknng (BSD 


Li censed) 




4. 


message = 'Three can keep a secret, if two 


of them are dead. ' 




5. 
6. 


translated = 1 ' 






7. 


i = len(message) - 1 






8. 


while i &gt;= 0: 






9. 


translated = translated + message [i] 






10. 


i = i - 1 






11. 








12. 


print(translated) 







Step 1 Line 1 This is a comment, so the Python interpreter skips it. 



Step 2 


Line 2 


This is a comment, and skipped. 


Step 3 


Line 4 


The string value 'Three can keep a secret, if two of 
them are dead .' is stored in the message variable. 


Step 4 


Line 5 


The blank string ' ' is stored in the translated variable. 


Step 5 


Line 7 


len (message) - 1 evaluates to 4 8 . The integer 4 8 is stored in the i 
variable. 


Step 6 


Line 8 


The while loop's condition i &gt;= 0 evaluates to True. Since the 
condition is True, the program execution moves inside the following 
block. 


Step 7 


Line 9 


translated + message [i] to ' . '. The string value ' . ' is stored 
in the translated variable. 


Step 8 


Line 10 


i - 1 evaluates to 4 7 . The integer 4 7 is stored in the i variable. 


Step 9 


Line 8 


When the program execution reaches the end of the block, the execution 
moves back to the while statement and rechecks the condition, i &gt;= 0 



68 http : //in vent wi thp y thon . com/hacking 



evaluates to True, the program execution moves inside the block again. 


Step 10 


Line 9 


translated + message [i] evaluates ' . d '. The string value ' .d' 
is stored in the translated variable. 


Step 1 1 


Line 10 


i ‚Äî 1 evaluates to 4 6 The integer 4 6 is stored in the i variable 


Step 12 


Line 8 


The while statement rechecks the condition. Since i &gt;= 0 evaluates to 
True, the program execution will move inside the block again. 


Step 13 




The lines of the code continue to loon We fast-forward to when i is set to 

‚Ä¢ ‚Ä¢ ‚Ä¢ A L J.W 1111^..? V/ 1 LI. J.W vUvlv vUllllllUw IV/ 1 V/V/ 1/ ‚Ä¢ T ¬• w A CI ..7 L A Y / 1 VV Ul V_4 IV/ VV llwll _1_ X l? ljv L IV/ 


to 




0 and translated is set to ' . daed era meht fo owt fi 


Step 149 




f Lti-LL^tio CL jytit^JV llCLO i_ J. 1 ... 


Step 150 


Line 8 


The while loop's condition is checked, and 0 &gt;= 0 evaluates to True. 


Step 151 


Line 9 


translated + message[i] evaluates to '.daed era meht fo 
owt f i , terces a peek nac eerhT ' . This string is stored in the 
translated variable. 


Step 152 


Line 10 


i - 1 evaluates to 0 - 1 , which evaluates to - 1 . - 1 is stored in the i 
variable. 


Step 153 


Line 8 


The while loop's condition is i &gt;= 0 , which evaluates to - 1 &gt;= 0, 
which evaluates to False. Because the condition is now False, the 
program execution skips the following block of code and goes to line 12. 


Step 154 


Line 12 


translated evaluates to the string value '. daed era meht fo 
owt fi , terces a peek nac eerhT '. The print ( ) function is 
called and this string is passed, making it appear on the screen. 



There are no more lines after line 12, so the program terminates. 



Using input ( ) In Our Programs 

The programs in this book are all designed so that the strings that are being encrypted or 
decrypted are typed directly into the source code. You could also modify the assignment 
statements so that they call the input ( ) function. You can pass a string to the input ( ) 
function to appear as a prompt for the user to type in the string to encrypt. For example, if you 
change line 4 in reverseCipher.py to this: 



reverseCi pher . py 

4. message = i nput( ' Enter message: ') 

Then when you run the program, it will print the prompt to the screen and wait for the user to 
type in the message and press Enter. The message that the user types in will be the string value 
that is stored in the message variable: 



Enter message: Hello world! 
! dl row ol 1 eH 



Email questions to the author: al@inventwithpython.com 



Chapter 5 - The Reverse Cipher 69 



Practice Exercises, Chapter 5, Section A 

Practice exercises can be found at http://inypy.com/hacMngp 

Summary 

Now that we have learned how to deal with text, we can start making programs that the user can 
run and interact with. This is important because text is the main way the user and the computer 
will communicate with each other. 

Strings are just a different data type that we can use in our programs. We can use the + operator 
to concatenate strings together. We can use indexing and slicing to create a new string from part 
of a different string. The len ( ) function takes a string argument and returns an integer of how 
many characters are in the string. 

The Boolean data type has only two values: True and False. Comparison operators ==, ! =, &lt;, 
&gt;, &lt;=, and &gt;= can compare two values and evaluate to a Boolean value. 

Conditions are expression that are used in several different kinds of statements. A while loop 
statement keeps executing the lines inside the block that follows it as long as its condition 
evaluates to True. A block is made up of lines with the same level of indentation, including any 
blocks inside of them. 

A common practice in programs is to start a variable with a blank string, and then concatenate 
characters to it until it "grows" into the final desired string. 



70 http://inventwithpython.com/hacking 




Chapter 6 



The Caesar Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The import statement 

‚Ä¢ Constants 

‚Ä¢ The upper () string method 

‚Ä¢ for loops 

‚Ä¢ if , elif, and else statements 

‚Ä¢ The in and not in operators 

‚Ä¢ The f ind ( ) string method 



"BIG BROTHER IS WATCHING YOU." 



"1984" by George Orwell 



Implementing a Program 

In Chapter 1, we used a cipher wheel, a St. Cyr slide, and a chart of letters and numbers to 
implement the Caesar cipher. In this chapter, we will use a computer program to implement the 
Caesar cipher. 

The reverse cipher always encrypts the same way. But the Caesar cipher uses keys, which encrypt 
the message in a different way depending on which key is used. The keys for the Caesar cipher 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 7 1 



are the integers from 0 to 2 5. Even if a cryptanalyst knows that the Caesar cipher was used, that 
alone does not give her enough information to break the cipher. She must also know the key. 

Source Code of the Caesar Cipher Program 

Type in the following code into the file editor, and then save it as caesarCipher.py. Press F5 to 
run the program. Note that first you will need to download the pyperclip.py module and place this 
file in the same directory (that is, folder) as the caesarCipher.py file. You can download this file 
from h^;//uiypy..cori^pypercjy^..py 



Source code for caesarCipher.py 

1. # Caesar Cipher 

2. # http://inventwithpython.com/hack-ing (BSD Licensed) 
3. 

4. import pyperclip 
5. 

6. # the string to be encrypted/decrypted 

7. message = 'This is my secret message.' 
8. 

9. # the encryption/decryption key 

10. key = 13 
11. 

12. # tells the program to encrypt or decrypt 

13. mode = 'encrypt' # set to 'encrypt' or 'decrypt' 
14. 

15. # every possible symbol that can be encrypted 

16. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 
17. 

18. # stores the encrypted/decrypted form of the message 

19. translated = ' ' 
20. 

21. # capitalize the string in message 

22. message = message . upper() 
23. 

24. # run the encryption/decryption code on each symbol in the message string 

25. for symbol in message: 



26. if symbol in LETTERS: 

27. # get the encrypted (or decrypted) number for this symbol 

28. num = LETTERS. find (symbol) # get the number of the symbol 

29. if mode == 'encrypt': 

30. num = num + key 

31. elif mode == 'decrypt': 

32. num = num - key 
33. 

34. # handle the wrap-around if num is larger than the length of 



72 http://inventwithpython.com/hacking 



35. # LETTERS or less than 0 

36. if num &gt;= 1 en (LETTERS) : 

37. num = num - 1 en (LETTERS) 

38. elif num &lt; 0: 

39. num = num + 1 en(LETTERS) 
40. 

41. # add encrypted/decrypted number's symbol at the end of translated 

42. translated = translated + LETTERS [num] 
43. 

44. else: 

45. # just add the symbol without encrypting/decrypting 

46. translated = translated + symbol 
47. 



48. # print the encrypted/decrypted string to the screen 

49. print(translated) 
50. 

51. # copy the encrypted/decrypted string to the clipboard 

52. pypercli p. copy (translated) 



Sample Run of the Caesar Cipher Program 

When you run this program, the output will look like this: 



GUVF VF ZL FRPERC ZRFFNTR. 

The above text is the string ' This is my secret message .' encrypted with the Caesar 
cipher with key 1 3. The Caesar cipher program you just ran will automatically copy this 
encrypted string to the clipboard so you can paste it in an email or text file. This way you can 
easily take the encrypted output from the program and send it to another person. 

To decrypt, just paste this text as the new value stored in the message variable on line 7. Then 
change the assignment statement on line 13 to store the string 'decrypt ' in the variable mode: 



caesarCipher.py 

6. # the string to be encrypted/decrypted 

7. message = 'GUVF VF ZL FRPERG ZRFFNTR.' 
8. 

9. # the encryption/decryption key 

10. key = 13 
11. 

12. # tells the program to encrypt or decrypt 

13. mode = 'decrypt' # set to 'encrypt' or 'decrypt' 

When you run the program now, the output will look like this: 
Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 73 



THIS IS MY SECRET MESSAGE. 

If you see this error message when running the program: 



Traceback (most recent call last): 

File "C:\Python32\caesarCipher.py" , line 4, in &lt;module&gt; 
import pyperclip 
ImportError: No module named pyperclip 

. . .then you have not downloaded the pyperclip module into the right folder. If you still 
cannot get the module working, just delete lines 4 and 52 (which have the text "pyperclip" in 
them) from the program. This will get rid of the code that depends on the pyperclip module. 

Checking Your Source Code with the Online Diff Tool 

To compare the code you typed to the code that is in this book, you can use the online diff tool on 
this book's website. Open ht^://invpxcpm^ac^^diff in your web browser. Copy and paste 
your code into the text field on this web page, and then click the Compare button. The diff tool 
will show any differences between your code and the code in this book. This can help you find 
any typos you made when typing out the program. 

Practice Exercises, Chapter 6, Set A 

Practice exercises can be found at http://iny¬£^ 

How the Program Works 

Let's go over exactly what each of the lines of code in this program does. 



Importing Modules with the import Statement 







caesarCipher.py 


1. 


# Caesar Cipher 




2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 


import pyperclip 





Line 4 is a new kind of statement called an import statement. While Python includes many 
built-in functions, some functions exist in separate programs called modules. Modules are 
Python programs that contain additional functions that can be used by your program. In this case, 
we're importing a module named pyperclip so that we can call the pyperclip . copy ( ) 
function later in this program. 



74 http://inventwithpython.com/hacking 



The import statement is made up of the import keyword followed by the module name. Line 
4 is an import statement that imports the pyper cl ip module, which contains several 
functions related to copying and pasting text to the clipboard. 



caesarCipher.py 

6. # the string to be encrypted/decrypted 

7. message = 'This is my secret message.' 
8. 

9. # the encryption/decryption key 
10. key = 13 
11. 

12. # tells the program to encrypt or decrypt 

13. mode = 'encrypt' # set to 'encrypt' or 'decrypt' 

The next few lines set three variables: message will store the string to be encrypted or 
decrypted, key will store the integer of the encryption key, and mode will store either the string 
' encrypt ' (which will cause code later in the program to encrypt the string in mes sage) or 
' decrypt ' (which will tell the program to decrypt rather than encrypting). 

Constants 

caesarCipher.py 

15. # every possible symbol that can be encrypted 

16. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 

We also need a string that contains all the capital letters of the alphabet in order. It would be 
tiring to type the full ' ABCDEFGHI JKLMNOPQRSTUVWXYZ ' string value each time we use it in 
the program (and we might make typos when typing it, which would cause errors in our 
program). So instead we will type the code for the string value once and place it in a variable 
named LETTERS. This string contains all the letters that our cipher program can possibly 
encrypt. This set of letters (which don't have to be just letters but can also be numbers, 
punctuation, or any other symbol) is called the cipher's symbol set. The end of this chapter will 
tell you how to expand this program's symbol set to include other characters besides letters. 

The LETTERS variable name is in all capitals. This is the programming convention for constant 
variables. Constants are variables whose values are not meant to be changed when the program 
runs. Although we can change LETTERS just like any other variable, the all-caps reminds the 
programmer to not write code that does so. 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 75 



Like all conventions, we don't have to follow it. But doing it this way makes it easier for other 
programmers to understand how these variables are used. (It even can help you if you are looking 
at code you wrote yourself a long time ago.) 



The upper ( ) and lower ( ) String Methods 







caesarCipher.py 


18. 


# stores the encrypted/decrypted form of the message 




19. 


translated = ' ' 




20. 






21. 


# capitalize the string in message 




22. 


message = message . upper 0 





On line 19, the program stores a blank string in a variable named translated. Just like in the 
reverse cipher from last chapter, by the end of the program the translated variable will 
contain the completely encrypted (or decrypted) message. But for now it starts as a blank string. 



Line 22 is an assignment statement that stores a value in a variable named me s sage, but the 
expression on the right side of the = operator is something we haven't seen before: 
message . upper ( ) . 

This is a method call. Methods are just like functions, except they are attached to a non-module 
value (or in the case of line 22, a variable containing a value) with a period. The name of this 
method is upper ( ) , and it is being called on the string value stored in the me s sage variable. 

A function is not a method just because it is in a module. You will see on line 52 that we call 
pyperclip . copy ( ) , but pyperclip is a module that was imported on line 4, so copy ( ) is 
not a method. It is just a function that is inside the pyperclip module. If this is confusing, then 
you can always call methods and functions a "function" and people will know what you're 
talking about. 



Most data types (such as strings) have methods. Strings have a method called upper ( ) and 
lower ( ) which will evaluate to an uppercase or lowercase version of that string, respectively. 
Try typing the following into the interactive shell: 



¬ª&gt; 'Hello world! ' 


‚ñ† upperO 


'HELLO WORLD! ' 




¬ª&gt; 'Hello world! ' 


. lower () 


'hello world! ' 




¬ª&gt; 





76 http : //in vent wi thp y thon . com/hacking 



Because the upper ( ) method returns a string value, you can call a method on that string as 
well. Try typing 'Hello world! ' . upper () . lower () into the shell: 



¬ª&gt; 'Hello world! ' .upperO ."lowerO 
'hello world! ' 

¬ª&gt; 

' Hello world ! ' . upper ( ) evaluates to the string ' HELLO WORLD ! ' , and then we call 
the lower ( ) method on that string. This returns the string ' hello world ! ' , which is the 
final value in the evaluation. The order is important. 'Hello world ! ' . lower ( ) . upper ( ) 
is not the same as ' Hello world ! ' . upper ( ) . lower ( ) : 



¬ª&gt; 'Hello world' .lower() .upperC) 
'HELLO WORLD! ' 

¬ª&gt; 

If a string is stored in a variable, you can call any string method (such as upper ( ) or 
lower ( ) ) on that variable. Look at this example: 



&gt;¬ª fizz = 'Hello world!' 
¬ª&gt; fizz.upperO 
'HELLO WORLD! ' 
¬ª&gt; fizz 
'Hello world! ' 

Calling the upper ( ) or lower ( ) method on a string value in a variable does not change the 
value inside a variable. Methods are just part of expressions that evaluate to a value. (Think about 
it like this: the expression fizz + ' ABC ' would not change the string stored in fizz to have 
' ABC ' concatenated to the end of it, unless we used it in an assignment statement like fizz = 
fizz + 'ABC'.) 

Different data types have different methods. You will learn about other methods as you read this 
book. A list of common string methods is at http://inypy.con^ 



The for Loop Statement 







caesarCipher.py 


24. 


# run the encryption/decryption code on each symbol 


in the message string 


25. 


for symbol in message: 





Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 77 



The for loop is very good at looping over a string or list of values (we will learn about lists 
later). This is different from the while loop, which loops as long as a certain condition is True. 
A for statement has six parts: 



1. The for keyword 

1. The for keyword. 

2. A variable name. 

3. The in keyword. 

for symbol in message: 

4. A string value (or a variable 
containing a string value). 

5. A colon. 

6. A block of code. 



5 for keyword 

I 3. The in 

I 2. A variable name V keyword 

‚ñº 4- kT 

"~ Dr symbol in message: 
some code here A 

f~ T \ 

4. A string or variableX 
containing a string \ 
5. A colon 

6. A block of code 



Figure 6-1. The parts of a for loop statement. 

Each time the program execution goes through the loop (that is, on each iteration through the 
loop) the variable in the for statement takes on the value of the next character in the string. 

For example, type the following into the interactive shell. Note that after you type the first line, 
the ¬ª&gt; prompt will turn into . . . (although in IDLE, it will just print three spaces) because the 
shell is expecting a block of code after the for statement's colon. In the interactive shell, the 
block will end when you enter a blank line: 



&gt;¬ª 


for letter in 'Howdy': 






print('The letter "is 


+ letter) 


The 


letter is H 




The 


letter is o 




The 


letter is w 




The 


letter is d 




The 


letter is y 




¬ª&gt; 







A while Loop Equivalent of a for Loop 

The for loop is very similar to the while loop, but when you only need to iterate over 
characters in a string, using a for loop is much less code to type. You can make a while loop 
that acts the same way as a for loop by adding a little extra code: 



¬ª&gt; i = 0 

¬ª&gt; while i &lt; len( 1 Howdy') : 
letter = 'Howdy' [i] 



78 http://inventwithpython.com/hacking 





print('The letter is 


+ letter) 




i = i + 1 




Thp 

1 1 1 c 


ICLLCI 1 J n 




The 


letter is o 




The 


letter is w 




The 


letter is d 




The 


letter is y 




¬ª&gt; 







Notice that this while loop does the exact same thing that the for loop does, but is not as short 
and simple as the for loop. 



Before we can understand lines 26 to 32 of the Caesar cipher program, we need to first learn 
about the if, elif , and else statements, the in and not in operators, and the find ( ) 
string method. 

Practice Exercises, Chapter 6, Set B 

Practice exercises can be found at ht^://invpx^Qn^^J^^ra(^ce6B. 

The if Statement 

An i f statement can be read as "If this condition is True, execute the code in the following 
block. Otherwise if it is False, skip the block." Open the file editor and type in the following 
small program. Then save the file as password.py and press F5 to run it. 







Source code for password.py 


1. 


printC'What is the password?') 




2. 


password = inputO 




3. 


if password == 'rosebud': 




4. 


pri nt( 'Access granted.') 




5. 


if password != 'rosebud': 




6. 


printC'Access denied.') 




7. 


print('Done. ') 





When the password = input ( ) line is executed, the user can type in anything she wants and 
it will be stored as a string in the variable pas sword. If she typed in "rosebud" (in all lowercase 
letters), then the expression password == 'rosebud' will evaluate to True and the 
program execution will enter the following block to print the 'Access granted. ' string. 



If password == 'rosebud' is False, then this block of code is skipped. Next, the second 
if statement will have its condition also evaluated. If this condition, password ! = 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 79 



' rosebud ' is True, then the execution jumps inside of the following block to print out 
' Acces s denied . ' . If the condition is Fal se, then this block of code is skipped. 

The else Statement 

Often we want to test a condition and execute one block of code if it is True and another block 
of code if it is Fal se. The previous password.py example is like this, but it used two i f 
statements. 

An else statement can be used after an if statement's block, and its block of code will be 
executed if the if statement's condition is False. You can read the code as "if this condition is 
true, execute this block, or else execute this block. 



Type in the following program and save it as password2.py. Notice that it does the same thing as 
the previous password.py program, except it uses an i f and else statement instead of two i f 
statements: 







Source code for password2 . py 


1. 


print('What is the password?') 




2. 


password = inputO 




3. 


if password == 'rosebud': 




4. 


printC'Access granted.') 




5. 


el se : 




6. 


printC'Access denied.') 




7. 


print('Done. ') 





The elif Statement 

There is also an "else if statement called the eli f statement. Like an i f statement, it has a 
condition. Like an else statement, it follows an if (or another elif) statement and executes if 
the previous if (or elif) statement's condition was False. You can read if, elif and else 
statements as, "If this condition is true, run this block. Or else, check if this next condition is true. 
Or else, just run this last block." Type in this example program into the file editor and save it as 
elifeggs.py: 







Source code for elifeggs.py 


1. 


numberOf Eggs = 12 




2. 


if numberOf Eggs &lt; 4: 




3. 


printC'That is not that 


many eggs. ') 


4. 


elif numberOf Eggs &lt; 20: 




5. 


printC'You have quite a 


few eggs . ' ) 


6. 


elif numberOf Eggs == 144: 





80 http : //in vent wi thp y thon . com/hacking 



7. pn'ntC'You have a lot of eggs. Cross!') 

8. else: 

9. print('Eat ALL the eggs!') 

When you run this program, the integer 12 is stored in the variable numberOf Eggs. Then the 
condition numberOf Eggs &lt; 4 is checked to see if it is True. If it isn't, the execution skips 
the block and checks numberOf Eggs &lt; 2 0. If it isn't True, execution skips that block and 
checks if numberOf Eggs == 14 4. If all of these conditions have been False, then the 
else block is executed. 

Notice that one and only one of these blocks will be executed. You can have zero or more 

el if statements following an if statement. You can have zero or one else statements, and the 

else statement always comes last. 

The in and not in Operators 

An expression of two strings connected by the in operator will evaluate to True if the first 
string is inside the second string. Otherwise the expression evaluates to False. Notice that the 
in and not in operators are case-sensitive. Try typing the following in the interactive shell: 



¬ª&gt; 'hello' 


in 'hello 


world ! ' 


True 






¬ª&gt; 'ello' 


in 'hello world! 1 


True 






¬ª&gt; 'HELLO' 


"in 'hello 


world! ' 


False 






¬ª&gt; 'HELLO' 


-in 'HELLO 


world ! ' 


True 






¬ª&gt; " in 'Hello' 




True 






¬ª&gt; " in ' 


1 




True 






¬ª&gt; 'D' in 


'ABCDEF' 




True 






¬ª&gt; 







The not in operator will evaluate to the opposite of in. Try typing the following into the 
interactive shell: 



¬ª&gt; 'hello' not "in 'hello world!' 
Fal se 

¬ª&gt; 'ello' not in 'hello world!' 
False 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 8 1 



¬ª&gt; 'HELLO' not in 'hello 


worl d ! ' 


True 






¬ª&gt; 'HELLO' not in 'HELLO 


worl d ! ' 


False 






¬ª&gt; ' ' 


not in 'Hello' 




False 






¬ª&gt; ' ' 


not in 11 




Fal se 






¬ª&gt; 'D 


not in 'ABCDEF' 




False 






¬ª&gt; 







Expressions using the in and not in operators are handy for conditions of if statements so that 
we can execute some code if a string exists inside of another string. 



Also, the in keyword used in for statements is not the same as the in operator used here. They 
are just typed the same. 

The find ( ) String Method 

Just like the upper ( ) method can be called on a string values, the f ind ( ) method is a string 
method. The f ind ( ) method takes one string argument and returns the integer index of where 
that string appears in the method's string. Try typing the following into the interactive shell: 



¬ª&gt; 'hello' .find('e') 
1 

¬ª&gt; 'hello' .find('o') 
4 

¬ª&gt; fizz = 'hello' 
¬ª&gt; fizz.find('h') 
0 

¬ª&gt; 



If the string argument cannot be found, the f ind ( ) method returns the integer -1. Notice that 
the f ind ( ) method is case-sensitive. Try typing the following into the interactive shell: 



¬ª&gt; 


'hello' 


.find('x') 


-1 






¬ª&gt; 


'hello' 


.find('H') 


-1 






¬ª&gt; 







82 http://inventwithpython.com/hacking 



The string you pass as an argument to f ind ( ) can be more than one character. The integer that 
f ind ( ) returns will be the index of the first character where the argument is found. Try typing 
the following into the interactive shell: 



¬ª&gt; 


'hello 


.find('ello') 


1 






¬ª&gt; 


'hello 


.f-ind('lo') 


3 






¬ª&gt; 


'hello 


hello' .find('e') 


1 






¬ª&gt; 







The f ind ( ) string method is like a more specific version of using the in operator. It not only 
tells you if a string exists in another string, but also tells you where. 



Practice Exercises, Chapter 6, Set C 

Practice exercises can be found at ht^://invpxAQr^^J^^ra(^ce6C. 

Back to the Code 

Now that we understand how if, elif, else statements, the in operator, and the f ind ( ) 
string method works, it will be easier to understand how the rest of the Caesar cipher program 
works. 







caesarCipher.py 


26. 


if symbol in LETTERS: 




27. 


# get the encrypted (or decrypted) number for this 


symbol 


28. 


num = LETTERS. find (symbol) # get the number of the 


symbol 



If the string in symbol (which the for statement has set to be only a single character) is a 
capital letter, then the condition symbol in LETTERS will be True. (Remember that on line 
22 we converted message to an uppercase version with message = message . upper ( ) , so 
symbol cannot possibly be a lowercase letter.) The only time the condition is False is if 
symbol is something like a punctuation mark or number string value, such as ' ? ' or ' 4 ' . 



We want to check if symbol is an uppercase letter because our program will only encrypt (or 
decrypt) uppercase letters. Any other character will be added to the translated string without 
being encrypted (or decrypted). 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 83 



There is a new block that starts after the i f statement on line 26. If you look down the program, 
you will notice that this block stretches all the way to line 42. The else statement on line 44 is 
paired to the i f statement on line 26. 









caesarCipher.py 


29. 


if mode == 


= 'encrypt' : 




30. 


num = 


num + key 




31. 


el "if mode 


== 'decrypt' : 




32. 


num = 


num - key 





Now that we have the current symbol's number stored in num, we can do the encryption or 
decryption math on it. The Caesar cipher adds the key number to the letter's number to encrypt it, 
or subtracts the key number from the letter's number to decrypt it. 



The mode variable contains a string that tells the program whether or not it should be encrypting 
or decrypting. If this string is 'encrypt ' , then the condition for line 29 's if statement will be 
True and line 30 will be executed (and the block after the eli f statement will be skipped). If 
this string is any other value besides 'encrypt ' , then the condition for line 29 's i f statement 
is False and the program execution moves on to check the el if statement's condition. 

This is how our program knows when to encrypt (where it is adding the key) or decrypt (where it 
is subtracting the key). If the programmer made an error and stored 'pineapples ' in the 
mode variable on line 13, then both of the conditions on lines 29 and 31 would be False and 
nothing would happen to the value stored in num. (You can try this yourself by changing line 13 
and re-running the program.) 







caesarCipher.py 


34. 


# handle the wrap-around "if num "is 


larger than the length of 


35. 


# LETTERS or less than 0 




36. 


"if num &gt;= 1 en (LETTERS) : 




37. 


num = num - len(LETTERS) 




38. 


el if num &lt; 0: 




39. 


num = num + len(LETTERS) 





Remember that when we were implementing the Caesar cipher with paper and pencil, sometimes 
the number after adding or subtracting the key would be greater than or equal to 26 or less than 0. 
In those cases, we had to add or subtract 26 to the number to "wrap-around" the number. This 
"wrap-around" is what lines 36 to 39 do for our program. 



84 http : //in vent wi thp y thon . com/hacking 

If num is greater than or equal to 2 6, then the condition on line 36 is True and line 37 is 
executed (and the el if statement on line 38 is skipped). Otherwise, Python will check if num is 
less than 0. If that condition is True, then line 39 is executed. 

The Caesar cipher adds or subtracts 26 because that is the number of letters in the alphabet. If 
English only had 25 letters, then the "wrap-around" would be done by adding or subtracting 25. 

Notice that instead of using the integer value 2 6 directly, we use len (LETTERS ) . The function 
call len ( LETTERS ) will return the integer value 2 6, so this code works just as well. But the 
reason that we use len ( LETTERS ) instead of 2 6 is that the code will work no matter what 
characters we have in LETTERS. 



We can modify the value stored in LETTERS so that we encrypt and decrypt more than just the 
uppercase letters. How this is done will be explained at the end of this chapter. 







caesarCipher.py 


41. 


# add encrypted/decrypted number's symbol 


at the end of translated 


42. 


translated = translated + LETTERS [num] 





Now that the integer in num has been modified, it will be the index of the encrypted (or 
decrypted) letter in LETTERS. We want to add this encrypted/decrypted letter to the end of the 
translated string, so line 42 uses string concatenation to add it to the end of the current value 

of translated. 







caesarCipher.py 


44. 


el se : 




45. 


# just add the symbol without encrypting/decrypting 






translated = translated + symbol 





Line 44 has four spaces of indentation. If you look at the indentation of the lines above, you'll see 
that this means it comes after the i f statement on line 26. There's a lot of code in between this 
if and else statement, but it all belongs in the block of code that follows the if statement on 
line 26. If that if statement's condition was False, then the block would have been skipped and 
the program execution would enter the else statement's block starting at line 46. (Line 45 is 
skipped because it is a comment.) 

This block has just one line in it. It adds the symbol string as it is to the end of translated. 
This is how non-letter strings like ' ' or ' . ' are added to the translated string without being 
encrypted or decrypted. 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 85 



Displaying and Copying the Encrypted/Decrypted String 







caesarCipher.py 


48. 


# print the encrypted/decrypted string to the screen 




49. 


pri nt(translated) 




50. 






51. 


# copy the encrypted/decrypted string to the clipboard 




52. 


pypercl i p . copy(transl ated) 





Line 49 has no indentation, which means it is the first line after the block that started on line 26 
(the for loop's block). By the time the program execution reaches line 49, it has looped through 
each character in the message string, encrypted (or decrypted) the characters, and added them to 

translated. 



Line 49 will call the print ( ) function to display the translated string on the screen. Notice 
that this is the only print ( ) call in the entire program. The computer does a lot of work 
encrypting every letter in message, handling wrap-around, and handling non-letter characters. 
But the user doesn't need to see this. The user just needs to see the final string in translated. 

Line 52 calls a function that is inside the pyperclip module. The function's name is copy ( ) 
and it takes one string argument. Because copy ( ) is a function in the pyperclip module, we 
have to tell Python this by putting pyperclip . in front of the function name. If we type 

copy (translated) instead of pyperclip . copy (translated) , Python will give us an 
error message. 



You can see this error message for yourself by typing this code in the interactive shell: 



¬ª&gt; copy ('Hello') 




Traceback (most recent 


call last): 


File "&lt;stdin&gt;", line 


1, in &lt;module&gt; 


NameError: name 'copy' 


is not defined 


¬ª&gt; 





Also, if you forget the import pyperclip line before trying to call pyperclip . copy ( ) , 
Python will give an error message. Try typing this into the interactive shell: 



¬ª&gt; pyperclip. copy('Hello') 
Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
NameError: name 'pyperclip' is not defined 

¬ª&gt; 



86 http://inventwithpython.com/hacking 



That's the entire Caesar cipher program. When you run it, notice how your computer can execute 
the entire program and encrypt the string in less than a second. Even if you type in a very, very 
long string for the value to store in the me s sage variable, your computer can encrypt or decrypt 
a message within a second or two. Compare this to the several minutes it would take to do this 
with a cipher wheel or St. Cyr slide. The program even copies the encrypted text to the clipboard 
so the user can simply paste it into an email to send to someone. 

Encrypt Non-Letter Characters 

One problem with the Caesar cipher that we've implemented is that it cannot encrypt non-letters. 
For example, if you encrypt the string 'The pa s s wo rd is 31337.' with the key 20, it will 
encrypt to ' Dro zkccgybn sc 31337 .' This encrypted message doesn't keep the 
password in the message very secret. However, we can modify the program to encrypt other 
characters besides letters. 

If you change the string that is stored in LETTERS to include more than just the uppercase letters, 
then the program will encrypt them as well. This is because on line 26, the condition symbol 
in LETTERS will be True. The value of num will be the index of symbol in this new, larger 
LETTERS constant variable. The "wrap-around" will need to add or subtract the number of 
characters in this new string, but that's already handled because we use len ( LETTERS ) instead 
of typing in 2 6 directly into the code. (This is why we programmed it this way.) 

The only changes you have to make are to the LETTERS assignment statement on line 16 and 
commenting out line 22 which capitalizes all the letters in message. 



caesarCipher.py 

15. # every possible symbol that can be encrypted 

16. LETTERS = ' ! "#$%&amp;\ '()*+,-. /012 34 56789 :; &lt;=&gt;?@ABCDEFGHI J KLMNOPQRSTUVWXYZ [\\] 
A_'a bcdefghi jklmnopqrstuvwxyz{ | }~' 

17. 

18. # stores the encrypted/decrypted form of the message 

19. translated = ' ' 
20. 

21. # capitalize the string in message 

22. #message = message . upperO 

Notice that this new string has the escape characters \ ' and \ \ in it. You can download this new 
version of the program from http://iny^ 

This modification to our program is like if we had a cipher wheel or St. Cyr slide that had not 
only uppercase letters but numbers, punctuation, and lowercase letters on it as well. 



Email questions to the author: al@inventwithpython.com 



Chapter 6 - The Caesar Cipher 87 



Even though the value for LETTERS has to be the same when running the program for decryption 
as when it encrypted the message, this value doesn't have to be secret. Only the key needs to be 
kept secret, while the rest of program (including the code for the Caesar cipher program) can be 
shared with the world. 

Summary 

You've had to learn several programming concepts and read through quite a few chapters to get 
to this point, but now you have a program that implements a secret cipher. And more importantly, 
you can understand how this code works. 

Modules are Python programs that contain useful functions we can use. To use these functions, 
you must first import them with an import statement. To call functions in an imported module, 
put the module name and a period before the function name, like: module.function(). 

Constant variables are by convention written in UPPERCASE. These variables are not meant to 
have their value changed (although nothing prevents the programmer from writing code that does 
this). Constants are helpful because they give a "name" to specific values in your program. 

Methods are functions that are attached to a value of a certain data type. The upper ( ) and 
lower ( ) string methods return an uppercase or lowercase version of the string they are called 
on. The f ind ( ) string method returns an integer of where the string argument passed to it can 
be found in the string it is called on. 

A for loop will iterate over all the characters in string value, setting a variable to each character 
on each iteration. The if, el if , and else statements can execute blocks of code based on 
whether a condition is True or False. 

The in and not in operators can check if one string is or isn't in another string, and evaluates 
to True or False accordingly. 

Knowing how to program gives you the power to take a process like the Caesar cipher and put it 
down in a language that a computer can understand. And once the computer understands how to 
do it, it can do it much faster than any human can and with no mistakes (unless there are mistakes 
in your programming.) This is an incredibly useful skill, but it turns out the Caesar cipher can 
easily be broken by someone who knows computer programming. In the next chapter we will use 
our skills to write a Caesar cipher "hacker" so we can read ciphertext that other people encrypted. 
So let's move on to the next chapter, and learn how to hack encryption. 



88 http://inventwithpython.com/hacking 




Chapter 7 



Hacking the Caesar Cipher 
with the Brute-Force 
Technique 

Topics Covered In This Chapter: 

‚Ä¢ Kerckhoffs's Principle and Shannon's Maxim 

‚Ä¢ The brute-force technique 

‚Ä¢ The range ( ) function 

‚Ä¢ String formatting (string interpolation) 

Hacking Ciphers 

We can hack the Caesar cipher by using a cryptanalytic technique called "brute-force". Because 
our code breaking program is so effective against the Caesar cipher, you shouldn't use it to 
encrypt your secret information. 

Ideally, the ciphertext would never fall into anyone's hands. But Kerckhoffs's Principle (named 
after the 19th-century cryptographer Auguste Kerckhoffs) says that a cipher should still be secure 
even if everyone else knows how the cipher works and has the ciphertext (that is, everything 
except the key). This was restated by the 20 th century mathematician Claude Shannon as 
Shannon's Maxim: "The enemy knows the system." 



Email questions to the author: al@inventwithpython.com 



Chapter 7 - Hacking the Caesar Cipher with the Brute Force Technique 89 




Figure 7-1. Auguste Kerckhoffs Figure 7-2. Claude Shannon 

January 19, 1835 - August 9, 1903 April 30, 1916 - February 24, 2001 

"A cryptosystem should be secure even if "The enemy knows the system." 

everything about the system, except the key, is 
public knowledge." 

The Brute-Force Attack 

Nothing stops a cryptanalyst from guessing one key, decrypting the ciphertext with that key, 
looking at the output, and if it was not the correct key then moving on to the next key. The 
technique of trying every possible decryption key is called a brute-force attack. It isn't a very 
sophisticated hack, but through sheer effort (which the computer will do for us) the Caesar cipher 
can be broken. 

Source Code of the Caesar Cipher Hacker Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as caesarHacker.py. Press F5 to run the program. Note that 
first you will need to download the pyperclip.py module and place this file in the same directory 
as the caesarHacker.py file. You can download this file from http://inypy.co 



Source code for caesarHacker.py 

1. # Caesar Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. message = 'GUVF VF ZL FRPERC ZRFFNTR. ' 



90 http://inventwithpython.com/hacking 



5. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 
6. 

7. # loop through every possible key 

8. for key in range(l en(LETTERS)) : 



9. 

10. # It is important to set translated to the blank string so that the 

11. # previous iteration's value for translated is cleared. 

12. translated = ' ' 
13. 

14. # The rest of the program is the same as the original Caesar program: 
15. 

16. # run the encryption/decryption code on each symbol in the message 

17. for symbol in message: 

18. if symbol in LETTERS: 

19. num = LETTERS. find (symbol) # get the number of the symbol 

20. num = num - key 
21. 

22. # handle the wrap-around if num is 26 or larger or less than 0 

23. if num &lt; 0: 

24. num = num + 1 en (LETTERS) 
25. 

26. # add number's symbol at the end of translated 

27. translated = translated + LETTERS [num] 
28. 

else: 

30. # just add the symbol without encrypting/decrypting 

31. translated = translated + symbol 
32. 

33. # display the current key being tested, along with its decryption 

34. print('Key #%s: %s' % (key, translated)) 



You will see that much of this code is the same as the code in the original Caesar cipher program. 
This is because the Caesar cipher hacker program does the same steps to decrypt the key. 

Sample Run of the Caesar Cipher Hacker Program 

Here is what the Caesar cipher program looks like when you run it. It is trying to break the 
ciphertext, "GUVF VF ZL FRPERG ZRFFNTR." Notice that the decrypted output for key 13 is 
plain English, so the original encryption key must have been 13. 



Key #0 


GUVF VF ZL 


FRPERG ZRFFNTR. 


Key #1 


FTUE UE YK 


EQ0DQF YQEEMSQ. 


Key #2 


ESTD TD XJ 


DPNCPE XPDDLRP. 


Key #3 


DRSC SC wT 


C0MB0D W0CCKQ0. 


Key #4 


CQRB RB VH 


BNLANC VNBB1PN. 



Email questions to the author: al@inventwithpython.com 



Chapter 7 - Hacking the Caesar Cipher with the Brute Force Technique 91 



Key #5 




BPQA QA UC AMKZMB UMAAIOM . 


Key #6 




AOPZ PZ TF ZUYLA TLZZHNL. 


Key #7 




ZNOY 0Y SE YKIXKZ SKYYGMK. 


Key #8 




YMNX NX RD XHHWJY RJXXFLJ . 


Key #9 




XLMW MW QC WIGVIX QIWWEKI. 




Wkl \/ 

W l\l_ V 


L V 


PR 
r D 


yupi iuy 
vnrunw 


pn\/\/n 1 H 

rnvvL/jn . 


Kpv #1 1 


V1KII 

V J l\U 


Kl 1 

l\U 


DA 


lir.FTflV 

\J\J L. 1 VJ V 


OCA II \CJC, 


i\ty it A.L. 


IIT1T 


"IT 
J 1 


N7 


i rujru 


NFTTRHF 
in r i i Dnr ‚ñ† 


Ixcy Tr _L J 


i nij 


TC 
J. J 


MY 


JtLIXt 1 


I I C Jjnu C &gt; 


Key #14 


SGHR 


HR 


LX 


RDBQDS 


LDRRZFD. 


Key #15 


RFGQ 


CQ 


KW 


QCAPCR 


KCQQYEC . 


Key #16 


QEFP 


FP 


JV 


PBZOBQ 


JBPPXDB. 


Key #17 


PDEO 


EO 


IU 


OAYNAP 


IA00WCA. 


Key #18 


OCDN 


DN 


HT 


NZXMZO 


HZNNVBZ. 


Key #19 


NBCM 


CM 


GS 


MYWLYN 


GYMMUAY . 


Key #20 


MABL 


BL 


FR 


LXVKXM 


FXLLTZX. 


Key #21 


LZAK 


AK 


EQ 


KWUJWL 


EWKKSYW . 


Key #22 


kyz: 


ZJ 


DP 


HVTIVK 


dv::rxv. 


Key #23 


JXYI 


YI 


CO 


IUSHUJ 


CUIIQWU. 


Key #24 


IWXH 


XH 


BN 


HTRGTI 


BTHHPVT. 


Key #25 


HVWG 


WG 


AM 


GSQFSH 


ASGGOUS. 



How the Program Works 







caesarHacker.py 


1. 


# Caesar Cipher Hacker 




2. 
3. 


# http://inventwithpython.com/hacknng (BSD Licensed) 




4. 


message = 'GUVF VF ZL FRPERG ZRFFNTR. ' 




5. 


LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 





The hacker program will create a message variable that stores the ciphertext string the program 
tries to decrypt. The LETTERS constant variable contains every character that can be encrypted 
with the cipher. The value for LETTERS needs to be exactly the same as the value for LETTERS 
used in the Caesar cipher program that encrypted the ciphertext we are trying to hack, otherwise 
the hacker program won't work. 



The range ( ) Function 



caesarHacker.py 



7. # loop through every possible key 

8. for key in range(l en(LETTERS)) : 



92 http://inventwithpython.com/hacking 

Line 8 is a for loop that does not iterate over a string value, but instead iterates over the return 
value from a call to a function named range ( ) . The range ( ) function takes one integer 
argument and returns a value of the range data type. These range values can be used in for loops 
to loop a specific number of times. Try typing the following into the interactive shell: 



¬ª&gt; for i in range(4) : 
print('HeTlo') 

Hello 
Hello 
Hello 
Hello 

¬ª&gt; 

More specifically, the range value returned from the range ( ) function call will set the for 
loop's variable to the integers 0 up to, but not including, the argument passed to range ( ) . Try 
typing the following into the interactive shell: 



¬ª&gt; for i in range(6): 
pri nt(i ) 

0 
1 
2 
3 
4 
5 

¬ª&gt; 

Line 8 is a for loop that will set the key variable with the values 0 up to (but not including) 2 6. 
Instead of hard-coding the value 2 6 directly into our program, we use the return value from 
len ( LETTERS ) so that if we modify LETTERS the program will still work. See the "Encrypt 
Non-Letter Characters" section in the last chapter to read why. 

So the first time the program execution goes through this loop, key will be set to 0 and the 
ciphertext in message will be decrypted with key 0. (The code inside the for loop does the 
decrypting.) On the next iteration of line 8's for loop, key will be set to 1 for the decryption. 

You can also pass two integer arguments to the range ( ) function instead of just one. The first 
argument is where the range should start and the second argument is where the range should stop 
(up to but not including the second argument). The arguments are separated by a comma: 



Email questions to the author: al@inventwithpython.com 



Chapter 7 - Hacking the Caesar Cipher with the Brute Force Technique 93 



¬ª&gt; for i in range(2, 6): 
print(i) 

2 
3 
4 
5 

¬ª&gt; 



The range ( ) call evaluates to a value of the "range object" data type. 

Back to the Code 



caesarHacker.py 

7. # loop through every possible key 

8. for key in range(len(LETTERS)) : 
9. 

10. # It is important to set translated to the blank string so that the 

11. # previous iteration's value for translated is cleared. 

12. translated = ' ' 



On line 12, translated is set to the blank string. The decryption code on the next few lines 
adds the decrypted text to the end of the string in translated. It is important that we reset 
translated to the blank string at the beginning of this for loop, otherwise the decrypted text will 
be added to the decrypted text in translated from the last iteration in the loop. 





caesarHacker.py 


14. 


# The rest of the program is the same as the original Caesar program: 


15. 




16. 


# run the encryption/decryption code on each symbol in the message 


17. 


for symbol in message: 


18. 


if symbol in LETTERS: 


19. 


num = LETTERS. find (symbol) # get the number of the symbol 



Lines 17 to 31 are almost exactly the same as the code in the Caesar cipher program from the last 
chapter. It is slightly simpler, because this code only has to decrypt instead of decrypt or encrypt. 



First we loop through every symbol in the ciphertext string stored in mes sage on line 17. On 
each iteration of this loop, line 18 checks if symbol is an uppercase letter (that is, it exists in the 
LETTERS constant variable which only has uppercase letters) and, if so, decrypts it. Line 19 



94 http://inventwithpython.com/hacking 



locates where symbol is in LETTERS with the f ind ( ) method and stores it in a variable called 
num. 





caesarHacker.py 


20. 


num = num - key 


21. 




22. 


# handle the wrap-around if num is 26 or larger or less than 0 


23. 


if num &lt; 0: 


24. 


num = num + 1 en (LETTERS) 



Then we subtract the key from num on line 20. (Remember, in the Caesar cipher, subtracting the 
key decrypts and adding the key encrypts.) This may cause num to be less than zero and require 
"wrap-around". Line 23 checks for this case and adds 26 (which is what len (LETTERS) 
returns) if it was less than 0. 









caesarHacker.py 


26. 


# add number 


s symbol at the end of translated 




27. 


translated = 


translated + LETTERS [num] 





Now that num has been modified, LETTERS [num] will evaluate to the decrypted symbol. Line 
27 adds this symbol to the end of the string stored in translated. 



caesarHacker.py 

else: 

30. # just add the symbol without encrypting/decrypting 

31. translated = translated + symbol 

Of course, if the condition for line 18's condition was False and symbol was not in 
LETTERS, we don't decrypt the symbol at all. If you look at the indentation of line 29's else 
statement, you can see that this else statement matches the if statement on line 18. 

Line 31 just adds symbol to the end of translated unmodified. 



String Formatting 







caesarHacker.py 


33. 


# display the current key being tested, along with 


its decryption 


34. 


print('Key #%s: %s' % (key, translated)) 





Although line 34 is the only print ( ) function call in our Caesar cipher hacker program, it will 
print out several lines because it gets called once per iteration of line 8's for loop. 



Email questions to the author: al@inventwithpython.com 



Chapter 7 - Hacking the Caesar Cipher with the Brute Force Technique 95 



The argument for the print ( ) function call is something we haven't used before. It is a string 
value that makes use of string formatting (also called string interpolation). String formatting 
with the % s text is a way of placing one string inside another one. The first % s text in the string 
gets replaced by the first value in the parentheses after the % at the end of the string. 



Type the following into the interactive shell: 



¬ª&gt; 'Hello %s\ ' % ('world') 








'Hello world! ' 








¬ª&gt; 'Hello ' + 'world' + ' ! ' 








'Hello world! ' 








¬ª&gt; 'The %s ate the %s that ate the %s.' 


% ('dog' , 


'cat' , 


'rat') 


'The dog ate the cat that ate the rat.' 








¬ª&gt; 









String formatting is often easier to type than string concatenation with the + operator, especially 
for larger strings. And one benefit of string formatting is that, unlike string concatenation, you 
can insert non-string values such as integers into the string. Try typing the following into the 
interactive shell: 



¬ª&gt; '%s had %s pies.' % ('Alice', 42) 
'Alice had 42 pies. ' 
¬ª&gt; 'Alice' + ' had ' + 42 + ' pies.' 
Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: Can't convert 'int' object to str implicitly 
¬ª&gt; 

Line 34 uses string formatting to create a string that has the values in both the key and 
translated variables. Because key stores an integer value, we'll use string formatting to put 
it in a string value that is passed to print () . 

Practice Exercises, Chapter 7, Set A 

Practice exercises can be found at ht^://invpxAQr^^J^gpra(^ce7A. 

Summary 

The critical failure of the Caesar cipher is that there aren't that many different possible keys that 
can be used to encrypt a message. Any computer can easily decrypt with all 26 possible keys, and 
it only takes the cryptanalyst a few seconds to look through them to find the one that is in 
English. To make our messages more secure, we will need a cipher that has more possible keys. 
That transposition cipher in the next chapter can provide this for us. 



96 http://inventwithpython.com/hacking 




Chapter 8 



Encrypting with the 
Transposition Cipher 

Topics Covered In This Chapter: 

‚Ä¢ Creating functions with def statements. 

‚Ä¢ main () functions 

‚Ä¢ Parameters 

‚Ä¢ The global and local scope, and global and local variables 

‚Ä¢ The global statement 

‚Ä¢ The list data type, and how lists and strings are similar 

‚Ä¢ The list () function 

‚Ä¢ Lists of lists 

‚Ä¢ Augmented assignment operators (+=, -=, *=, /=) 

‚Ä¢ The join ( ) string method 

‚Ä¢ Return values and the return statement 

‚Ä¢ The special name variable 

The Caesar cipher isn't secure. It doesn't take much for a computer to brute -force through all 
twenty-six possible keys. The transposition cipher has many more possible keys to make a brute- 
force attack more difficult. 

Encrypting with the Transposition Cipher 

Instead of replacing characters with other characters, the transposition cipher jumbles up the 
message's symbols into an order that makes the original message unreadable. Before we start 
writing code, let's encrypt the message "Common sense is not so common." with pencil and 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 97 



paper. Including the spaces and punctuation, this message has 30 characters. We will use the 
number 8 for the key. 

The first step is to draw out a number of boxes equal to the key. We will draw 8 boxes since our 
key for this example is 8: 



The second step is to start writing the message you want to encrypt into the boxes, with one 
character for each box. Remember that spaces are a character (this book marks the boxes with (s) 
to indicate a space so it doesn't look like an empty box). 



c 


o 


m 


m 


o 


n 


(s) 


s 



We only have 8 boxes but there are 30 characters in the message. When you run out of boxes, 
draw another row of 8 boxes under the first row. Keep creating new rows until you have written 
out the full message: 



1 st 


2 nd 


3 rd 


4 th 


5 th 


6 th 


‚ñ†yth 


gth 


c 


o 


m 


m 


o 


n 


(s) 


s 


e 


n 


s 


e 


(s) 


i 


s 


(s) 


n 


o 


t 


(s) 


s 


o 


(s) 


c 


o 


m 


m 


o 


n 









We shade in the two boxes in the last row to remind us to ignore them. The ciphertext is the 
letters read from the top left box going down the column. "C", "e", "n", and "o" are from the 1 st 
column. When you get to the last row of a column, move to the top row of the next column to the 
right. The next characters are "o", "n", "o", "m". Ignore the shaded boxes. 

The ciphertext is "Cenoonommstmme oo snnio. s s c", which is sufficiently scrambled to keep 
someone from figuring out the original message by looking at it. 

The steps for encrypting are: 

1 . Count the number of characters in the message and the key. 

2. Draw a number of boxes equal to the key in a single row. (For example, 12 boxes for a 
key of 12.) 

3. Start filling in the boxes from left to right, with one character per box. 

4. When you run out of boxes and still have characters left, add another row of boxes. 



98 http://inventwithpython.com/hacking 



5. Shade in the unused boxes in the last row. 

6. Starting from the top left and going down, write out the characters. When you get to the 
bottom of the column, move to the next column to the right. Skip any shaded boxes. This 
will be the ciphertext. 

Practice Exercises, Chapter 8, Set A 

Practice exercises can be found at ht^://invpxAQr^^J^^ra(^ce8A. 

A Transposition Cipher Encryption Program 

Encrypting with paper and pencil involves a lot of work and it's easy to make mistakes. Let's 
look at a program that can implement transposition cipher encryption (a decryption program will 
be demonstrated later in this chapter). 

Using the computer program has a slight problem, however. If the ciphertext has space characters 
at the end, then it is impossible to see them since a space is just empty. . . well, space. To fix this, 
the program adds a | character at the end of the ciphertext. (The | character is called the "pipe" 
character and is above the Enter key on your keyboard.) For example: 



Hellol 


# 


There 


are no spaces at the end of the message. 


Hello | 


# 


There 


is one space at the end of the message. 


Hello 


1 # 


There 


are two spaces at the end of the message. 



Source Code of the Transposition Cipher Encryption Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as transpositionEncrypt.py. Press F5 to run the program. Note 
that first you will need to download the pyperclip.py module and place this file in the same 
directory as the transpositionEncrypt.py file. You can download this file from 
http://inypy,cor^pyperclip.py. 



Source code for transpositionEncrypt.py 

1. # Transposition Cipher Encryption 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip 
5. 

6. def mainO : 

7. myMessage = 'Common sense is not so common. 1 

8. myKey = 8 
9. 

10. ciphertext = encryptMessage(myKey , myMessage) 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 99 



11. 








12. 




# Print the encrypted string in ciphertext to the screen, with 




13. 




# a | (called "pipe" character) after it in case there are spaces 


at 


14. 




# the end of the encrypted message. 




15. 




print(ciphertext + ' | ') 




16. 








17. 




# Copy the encrypted string in ciphertext to the clipboard. 




18. 




pypercl i p . copy (ci phertext) 




19. 








20. 








21. 


def 


encryptMessage(key , message): 




22. 




# Each string in ciphertext represents a column in the grid. 




23. 




ciphertext = [''] * key 




24. 








25. 




# Loop through each column in ciphertext. 




26. 




for col in range(key) : 




27. 




pointer = col 




28. 








29. 




# Keep looping until pointer goes past the length of the message. 


30. 




while pointer &lt; 1 en(message) : 




31. 




# Place the character at pointer in message at the end of 


the 


32. 




# current column in the ciphertext list. 




33. 




ci phertext[col ] += message [poi nter] 




34. 








35. 




# move pointer over 




36. 




pointer += key 




37. 








38. 




# Convert the ciphertext list into a single string value and return it. 


39. 




return ' ' . join(ciphertext) 




40. 








41. 








42. 


# If transpositionEncrypt.py is run (instead of imported as a module) 


call 


43. 


# tl 


le main() function. 




44. 


if . 


name == ' main ': 




45. 




mainQ 





Sample Run of the Transposition Cipher Encryption Program 

When you run the above program, it produces this output: 



Cenoonommstmme oo snnio. s s c| 



This ciphertext (without the pipe character at the end) is also copied to the clipboard, so you can 
paste it into an email to someone. If you want to encrypt a different message or use a different 



100 http://inventwithpython.com/hacking 



key, change the value assigned to the myMessage and my Key variables on lines 7 and 8. Then 
run the program again. 



How the Program Works 







transposi ti onEncrypt . py 


1. 


# Transposition Cipher Encryption 




2. 
3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 


import pyperclip 





The transposition cipher program, like the Caesar cipher program, will copy the encrypted text to 
the clipboard. So first we will import the pyperclip module so it can call 

pyperclip . copy ( ) . 



Creating Your Own Functions with def Statements 







transposi ti onEnc rypt . py 


6. 


def main() : 




7. 


myMessage = 'Common sense is not so common. 1 




8. 


myKey = 8 





A function (like print ( ) ) is a sort of mini -program in your program. When the function is 
called, the execution moves to the code inside that function and then returns to the line after the 
function call. You can create your own functions with a de f statement like the one on line 6. 



The def statement on line 6 isn't a call to a function named main ( ) . Instead, the def statement 
means we are creating, or defining, a new function named main ( ) that we can call later in our 
program. When the execution reaches the de f statement Python will define this function. We can 
then call it the same way we call other functions. When we call this function, the execution 
moves inside of the block of code following the de f statement. 



Open a new file editor window and type the following code into it: 







Source code for helloFunction.py 


1. 


def helloO: 




2. 


printC'Hello! ') 




3. 


total =42+1 




4. 


print('42 plus 1 is %s' 5 


{, (total)) 


5. 


print('Start! ') 




6. 


helloO 




7. 


print ('Call it again.') 




8. 


helloO 





Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 101 



print('Done. ') 



Save this program with the name helloFunction.py and run it by pressing F5. The output looks 
like this: 



Start! 




Hello! 




42 plus 


1 is 43 


Call it 


agai n . 


Hello! 




42 plus 


1 is 43 


Done . 





When the helloFunction.py program runs, the execution starts at the top. The first line is a def 
statement that defines the hello ( ) function. The execution skips the block after the def 
statement and executes the print ( ' Start ! ' ) line. This is why ' Start ! ' is the first string 
printed when we run the program. 



The next line after print ( ' Start ! ' ) is a function call to our hello ( ) function. The 
program execution jumps to the first line in the hello ( ) function's block on line 2. This 
function will cause the strings 'Hello ! ' and '42 plus 1 is 43' to be printed to the 
screen. 

When the program execution reaches the bottom of the def statement, the execution will jump 
back to the line after the line that originally called the function (line 7). In helloFunction.py, this 
is the print (' Call it again . ') line. Line 8 is another call to the hello ( ) function. The 
program execution will jump back into the hello ( ) function and execute the code there again. 
This is why ' Hello ! ' and ' 42 plus 1 is 43 ' are displayed on the screen two times. 

After that function returns to line 9, the print (' Done . ' ) line executes. This is the last line in 
our program, so the program exits. 



The Program's main ( ) Function 







transposi ti onEncrypt . py 


6. 


def main() : 




7. 


myMessage = 'Common sense is not so common.' 




8. 


myKey = 8 





102 http://inventwithpython.com/hacking 

The rest of the programs in this book have a function named main ( ) which is called at the start 
of program. The reason is explained at the end of this chapter, but for now just know that the 
main ( ) function in the programs in this book are always called soon after the programs are run. 



On lines 7 and 8, the variables myMessage and my Key will store the plaintext message to 
encrypt and the key used to do the encryption. 







transposi ti onEncrypt . py 


10. 


ciphertext = encryptMessage(myKey , myMessage) 





The code that does the actual encrypting will be put into a function we define on line 21 named 
encryptMes sage ( ) . This function will take two arguments: an integer value for the key and a 
string value for the message to encrypt. When passing multiple arguments to a function call, 
separate the arguments with a comma. 



The return value of encryptMes sage ( ) will be a string value of the encrypted ciphertext. 
(The code in this function is explained next.) This string will be stored in a variable named 

ciphertext. 





transposi ti onEncrypt . py 


12. 


# Print the encrypted string in ciphertext to the screen, with 


13. 


# a | (called "pipe" character) after it in case there are spaces at 


14. 


# the end of the encrypted message. 


15. 


pri nt(ci phertext + 1 | ') 


16. 




17. 


# Copy the encrypted string in ciphertext to the clipboard. 


18. 


pypercl i p . copy (ci phertext) 



The ciphertext message is printed to the screen on line 15 and copied to the clipboard on line 18. 
The program prints a I character (called the "pipe" character) at the end of the message so that the 
user can see any empty space characters at the end of the ciphertext. 



Line 18 is the last line of the main ( ) function. After it executes, the program execution will 
return to the line after the line that called it. The call to main ( ) is on line 45 and is the last line 
in the program, so after execution returns from main ( ) the program will exit. 

Parameters 

transposi ti onEncrypt . py 

21. def encryptMessage(key, message): 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 103 



The code in the encryptMessage ( ) function does the actual encryption. The key and 
message text in between the parentheses next to encryptMessage ( ) 's def statement 
shows that the encryptMessage ( ) function takes two parameters. 

Parameters are the variables that contain the arguments passed when a function is called. 
Parameters are automatically deleted when the function returns. (This is just like how variables 
are forgotten when a program exits.) 

When the encryptMes sage ( ) function gets called from line 10, two argument values are 
passed (on line 10, they are the values in myKey and myMessage). These values get assigned to 
the parameters key and mes sage (which you can see on line 21) when the execution moves to 
the top of the function. 

A parameter is a variable name in between the parentheses in the de f statement. An 
argument is a value that is passed in between the parentheses for a function call. 

Python will raise an error message if you try to call a function with too many or too few 
arguments for the number of parameters the function has. Try typing the following into the 
interactive shell: 



&gt;¬ª lenC'hello' , 


'world') 




Traceback (most 


recent call last): 




File "&lt;stdin&gt;" 


, line 1, in &lt;module&gt; 




TypeError: len() 


takes exactly one argument 


(2 given) 


¬ª&gt; len() 






Traceback (most 


recent cal 1 1 ast) : 




File "&lt;stdin&gt;" 


, line 1, in &lt;module&gt; 




TypeError: len() 


takes exactly one argument 


(0 given) 


¬ª&gt; 







Changes to Parameters Only Exist Inside the Function 

Look at the following program, which defines and then calls a function named f unc ( ) : 



def f unc(param) : 

param = 42 
spam = 'Hello' 
f unc(spam) 
print(spam) 

When you run this program, the print ( ) call on the last line will print out 'Hello ' , not 4 2. 
When tunc ( ) is called with spam as the argument, the spam variable is not being sent into the 



104 http://inventwithpython.com/hacking 

func ( ) function and having 4 2 assigned to it. Instead, the value inside spam is being copied 
and assigned to param. Any changes made to param inside the function will not change the 
value in the spam variable. 

(There is an exception to this rule when you are passing something called a list or dictionary 
value, but this will be explained in chapter 10 in the "List References" section.) 

This is an important idea to understand. The argument value that is "passed" in a function call is 
copied to the parameter. So if the parameter is changed, the variable that provided the argument 
value is not changed. 

Variables in the Global and Local Scope 

You might wonder why we even have the key and message parameters to begin with, since we 
already have the variables myKey and myMes sage from the main ( ) function. The reason is 
because myKey and myMes sage are in the main ( ) function's local scope and can't be used 
outside of the main ( ) function. 

Every time a function is called, a local scope is created. Variables created during a function call 
exist in this local scope. Parameters always exist in a local scope. When the function returns, the 
local scope is destroyed and the local variables are forgotten. A variable in the local scope is still 
a separate variable from a global scope variable even if the two variables have the same name. 

Variables created outside of every function exist in the global scope. When the program exits, 
the global scope is destroyed and all the variables in the program are forgotten. (All the variables 
in the reverse cipher and Caesar cipher programs were global.) 

The global Statement 

If you want a variable that is assigned inside a function to be a global variable instead of a local 
variable, put a global statement with the variable's name as the first line after the def 
statement. 

Here are the rules for whether a variable is a global variable (that is, a variable that exists in the 
global scope) or local variable (that is, a variable that exists in a function call's local scope): 

1. Variables outside of all functions are always global variables. 

2. If a variable in a function is never used in an assignment statement, it is a global variable. 

3. If a variable in a function is not used in a global statement and but is used in an 
assignment statement, it is a local variable. 

4. If a variable in a function is used in a global statement, it is a global variable when 
used in that function. 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 105 
For example, type in the following short program, save it as scope.py, and press F5 to run it: 







Source code for scope.py 


1. 


spam = 42 




2. 






3. 


def eggs() : 




4. 


spam = 99 # spam ir 


this function is local 


5. 
6. 


printC'In eggs() : ' , 


spam) 


7. 


def ham() : 




8. 
9. 


printC'In ham() : ' , 


spam) # spam in this function is global 


10. 


def bacon () : 




11. 


global spam # spam 


in this function is global 


12. 


printC'In bacon() : ' 


, spam) 


13. 


spam = 0 




14. 






15. 


def CRASH (): 




16. 


print(spam) # spam 


in this function is local 


17 . 


cnam ‚Äî f) 

J CLI II ‚Äî W 




18. 






19. 


pri nt(spam) 




20. 


eggs() 




21. 


pri nt(spam) 




22. 


ham() 




23. 


pri nt(spam) 




24. 


bacon() 




25. 


pri nt(spam) 




26. 


CRASH () 





The program will crash when Python executes line 16, and the output will look like this: 



42 




In eggs() : 99 




42 




In ham(): 42 




42 




In bacon() : 42 




0 




Traceback (most recent call last) 




File "C:\scope.py", line 27, in 


&lt;modul e&gt; 


CRASH () 




File "C:\scope.py", line 16, in 


CRASH 



106 http://inventwithpython.com/hacking 



pri nt(spam) 

UnboundLocal Error: local variable 'spam' referenced before assignment 

When the spam variable is used on lines 1, 19, 21, 23, 25 it is outside of all functions, so this is 
the global variable named spam. In the eggs ( ) function, the spam variable is assigned the 
integer 99 on line 4, so Python regards this spam variable as a local variable named spam. 
Python considers this local variable to be completely different from the global variable that is also 
named spam. Being assigned 99 on line 4 has no effect on the value stored in the global spam 
variable since they are different variables (they just happen to have the same name). 

The spam variable in the ham ( ) function on line 8 is never used in an assignment statement in 
that function, so it is the global variable spam. 

The spam variable in the bacon ( ) function is used in a global statement, so we know it is 
the global variable named spam. The spam = 0 assignment statement on line 13 will change the 
value of the global spam variable. 

The spam variable in the CRASH ( ) function is used in an assignment statement (and not in a 
global statement) so the spam variable in that function is a local variable. However, notice that 
it is used in the print ( ) function call on line 16 before it is assigned a value on line 17. This is 
why calling the CRASH ( ) function causes our program to crash with the error, 

UnboundLocalError : local variable 'spam' referenced before 
assignment. 

It can be confusing to have global and local variables with the same name, so even if you 
remember the rules for how to tell global and local variables apart, you would be better off using 
different names. 

Practice Exercises, Chapter 8, Set B 

Practice exercises can be found at http://inypy.co^ 



The List Data Type 







transposi ti onEncrypt . py 


22. 


# Each strinc 


] "in ciphertext represents a column in the grid. 


23. 


ciphertext = 


["] * key 



Line 23 uses a new data type called the list data type. A list value can contain other values. Just 
like how strings begin and end with quotes, a list value begins with a [ open bracket and ends 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 



with ] close bracket. The values stored inside the list are typed within the brackets. If there 
more than one value in the list, the values are separated by commas. 



108 http://inventwithpython.com/hacking 



Type the following into the interactive shell: 



¬ª&gt; animals = 


['aardvark', 'anteater' 


, 'antelope' , 


'albert'] 


¬ª&gt; animals 








[ ' aardvark' , 


anteater', 'antelope', 


'albert'] 




¬ª&gt; 









The animal s variable stores a list value, and in this list value are four string values. The 
individual values inside of a list are also called items. Lists are very good when we have to store 
lots and lots of values, but we don't want variables for each one. Otherwise we would have 
something like this: 



¬ª&gt; 


animal si = 


' aardvark' 


&gt;¬ª 


animal s2 = 


'anteater' 


¬ª&gt; 


animal s3 = 


' antelope' 


¬ª&gt; 


animal s4 = 


' al bert ' 


¬ª&gt; 







This makes working with all the strings as a group very hard, especially if you have hundreds, 
thousands, or millions of different values that you want stored in a list. 



Many of the things you can do with strings will also work with lists. For example, indexing 
and slicing work on list values the same way they work on string values. Instead of individual 
characters in a string, the index refers to an item in a list. Try typing the following into the 
interactive shell: 



¬ª&gt; animals = ['aardvark', 'anteater', 


'antelope', 'albert'] 


¬ª&gt; animal s[0] 




'aardvark' 




¬ª&gt; animal s[l] 




' anteater 1 




¬ª&gt; animals [2] 




'antelope' 




¬ª&gt; animals [3] 




'albert' 




¬ª&gt; animals[l:3] 




['anteater', 'antelope'] 




¬ª&gt; 





Remember, the first index is 0 and not 1 . While using slices with a string value will give you a 
string value of part of the original string, using slices with a list value will give you a list value of 
part of the original list. 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 109 



A for loop can also iterate over the values in a list, just like it iterates over the characters in a 
string. The value that is stored in the for loop's variable is a single value from the list. Try 
typing the following into the interactive shell: 



¬ª&gt; for spam in [ ' aardvark' , 'anteater', 'antelope', 'albert']: 
printC'For dinner we are cooking ' + spam) 

For dinner we are cooking aardvark 

For dinner we are cooking anteater 

For dinner we are cooking antelope 

For dinner we are cooking albert 

¬ª&gt; 



Using the list ( ) Function to Convert Range Objects to Lists 

If you need a list value that has increasing integer amounts, you could have code like this to build 
up a list value using a for loop: 



¬ª&gt; 


myList = 


[] 


¬ª&gt; 


for i in 


range(lO) : 




myList 


= myList + [i] 


¬ª&gt; 


myLi st 




[0, 


1, 2, 3, 


4, 5, 6, 7, 8, 9] 


¬ª&gt; 







However, it is simpler to directly make a list from a range object that the range ( ) function 
returned by using the list ( ) function: 



¬ª&gt; 


myList = 


list(range(10)) 


¬ª&gt; 


myLi st 




[0, 


1, 2, 3, 


4, 5, 6, 7, 8, 9] 


¬ª&gt; 







The list () function can also convert strings into a list value. The list will have several single- 
character strings that were in the original string: 



¬ª&gt; myList 


= listC'Hello world! ') 








¬ª&gt; myList 










[ 1 H ' , 'e', 


'1 ' , 'V , 'o' , ' ' , 'w' , 


'o', 


'r' , '1 ' , 'd' , 


'!'] 


¬ª&gt; 











1 10 http://inventwithpython.com/hacking 



We won't be using the li st ( ) function on strings or range objects in this program, but it will 
come up in later in this book. 



Reassigning the Items in Lists 

The items inside a list can also be modified. Use the index with a normal assignment statement. 
Try typing the following into the interactive shell: 



¬ª&gt; animals = ['aardvark' 


, 'anteater', 'antelope', 'albert'] 


¬ª&gt; animals 




['aardvark', 'anteater', 


'antelope', 'albert'] 


¬ª&gt; animals [2] = 9999 




¬ª&gt; animals 




['aardvark', 'anteater', 


9999, 'albert'] 


¬ª&gt; 





Reassigning Characters in Strings 

While you can reassign items in a list, you cannot reassign a character in a string value. Try 
typing the following code into the interactive shell to cause this error: 



¬ª&gt; 'Hello world! ' [6] = 'x' 
Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: 'str' object does not support item assignment 

¬ª&gt; 



To change a character in a string, use slicing instead. Try typing the following into the interactive 
shell: 



¬ª&gt; spam = 'Hello world!' 

¬ª&gt; spam = spam[:6] + 'x' + spam[7:] 

¬ª&gt; spam 

'Hello xorld! ' 

¬ª&gt; 



Lists of Lists 

List values can even contain other list values. Try typing the following into the interactive shell: 

¬ª&gt; spam = [['dog' , 'cat'], [1, 2, 3]] 
¬ª&gt; spam[0] 
['dog', 'cat'] 
¬ª&gt; spam[0] [0] 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 111 



'dog' 

¬ª&gt; spam[0] [1] 
'cat' 

&gt;¬ª spam[l] [0] 
1 

&gt;¬ª spam[l] [1] 
2 

¬ª&gt; 

The double index brackets used for spam [ 0 ] [ 0 ] work because spam [ 0 ] evaluates to 
[ ' dog ' , ' cat ' ] and [ ' dog ' , ' cat ' ] [ 0 ] evaluates to ' dog ' . You could even use 
another set of index brackets, since string values also use them: 

¬ª&gt; spam = [['dog', 'cat'], [1, 2, 3]] 

¬ª&gt; spam[0] [1] [1] 

'a' 

¬ª&gt; 

Say we had a list of lists stored in a variable named x. Here are the indexes for each of the items 
in x. Notice that x[0],x[l],x[2], and x [ 3 ] refer to list values: 




Figure 8-1. A list of lists with every item's index labeled. 

Practice Exercises, Chapter 8, Set C 

Practice exercises can be found at http://inypy.co_^ 

Using len ( ) and the in Operator with Lists 

We've used the len ( ) function to tell us how many characters are in a string (that is, the length 
of the string). The len ( ) function also works on list values and returns an integer of how many 
items are in the list. 



1 12 http://inventwithpython.com/hacking 



Try typing the following into the interactive shell: 



¬ª&gt; 


animals = [ ' aardvark' , 


'anteater ' , 


' antelope' , 


'albert'] 


¬ª&gt; 


1 en (animals) 








4 










¬ª&gt; 











We've used the in operator to tell us if a string exists inside another string value. The in 
operator also works for checking if a value exists in a list. Try typing the following into the 
interactive shell: 



¬ª&gt; animals = ['aardvark', 'anteater', 


'antelope', 'albert'] 


¬ª&gt; 'anteater' in animals 




True 




¬ª&gt; 'anteater' not in animals 




False 




¬ª&gt; 'anteat' in animals 




False 




¬ª&gt; 'delicious spam' in animals 




False 




¬ª&gt; 





Just like how a set of quotes next to each other represents the blank string value, a set of brackets 
next to each other represents a blank list. Try typing the following into the interactive shell: 



¬ª&gt; animals = [] 
¬ª&gt; 1 en (animals) 
0 

¬ª&gt; 



List Concatenation and Replication with the + and * Operators 

Just like how the + and * operators can concatenate and replicate strings, the same operators can 
concatenate and replicate lists. Try typing the following into the interactive shell: 



¬ª&gt; ['hello'] + ['world'] 




['hello', 'world'] 




¬ª&gt; ['hello'] * 5 




['hello', 'hello', 'hello', 'hello', 


'hello'] 


¬ª&gt; 





That's enough about the similarities between strings and lists. Just remember that most things you 
can do with string values will also work with list values. 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 113 



Practice Exercises, Chapter 8, Set D 

Practice exercises can be found at ht^://invpxAQr^^J^^ra^ce8p. 

The Transposition Encryption Algorithm 

We need to translate these paper-and-pencil steps into Python code. Let's take a look at 
encrypting the string ' Common sense is not so common .' with the key 8. If we wrote 
out the boxes with pencil and paper, it would look like this: 



c 


o 


m 


m 


o 


n 


(s) 


s 


e 


n 


s 


e 


(s) 


1 


s 


(s) 


n 


o 


t 


(s) 


s 


o 


(s) 


c 


o 


m 


m 


o 


n 









Add the index of each letter in the string to the boxes. (Remember, indexes begin with 0, not 1.) 



c 


o 


m 


m 


o 


n 


(s) 


s 


0 


1 


2 


3 


4 


5 


6 


7 


e 


n 


s 


e 


(s) 


i 


s 


(s) 


8 


9 


10 


11 


12 


13 


14 


15 


n 


o 


t 


(s) 


s 


o 


(s) 


c 


16 


17 


18 


19 


20 


21 


22 


23 


o 


m 


m 


o 


n 








24 


25 


26 


27 


28 


29 







We can see from these boxes that the first column has the characters at indexes 0, 8, 16, and 2 4 
(which are ' C ' , ' e ' , ' n ' , and ' o ' ). The next column has the characters at indexes 1, 9, 17, 
and 2 5 (which are ' o ' , ' n ' , ' o ' and ' m ' ). We can see a pattern emerging: The n th column 
will have all the characters in the string at indexes 0 + n, 8 + n, 16 + n, and 24 + n: 



c 

0+0=0 


o 

1+0=1 


m 
2+0=2 


m 
3+0=3 


o 

4+0=4 


n 

5+0=5 


(s) 
6+0=6 


s 

7+0=7 


e 

0+8=8 


n 

1+8=9 


s 

2+8=10 


e 

3+8=11 


(s) 
4+8=12 


i 

5+8=13 


s 

6+8=14 


(s) 
7+8=15 


n 

0+16=16 


o 

1+16=17 


t 

2+16=18 


(s) 
3+16=19 


s 

4+16=20 


o 

5+16=21 


(s) 
6+16=22 


c 

7+16=23 


o 

0+24=24 


m 

1+24=25 


m 

2+24=26 


o 

3+24=27 


n 

4+24=28 


5+24=29 







There is an exception for the 6 and 7 columns, since 24 + 6 and 24 + 7 are greater than 29, 
which is the largest index in our string. In those cases, we only use 0, 8, and 16 to add to n (and 
skip 24). 



1 14 http://inventwithpython.com/hacking 

What's so special about the numbers 0, 8, 16, and 24? These are the numbers we get when, 
starting from 0, we add the key (which in this example is 8). 0 + 8 is 8, 8 + 8 is 16, 16 + 8 is 24. 
24 + 8 would be 32, but since 32 is larger than the length of the message, we stop at 24. 

So, for the n th column's string we start at index n, and then keep adding 8 (which is the key) to get 
the next index. We keep adding 8 as long as the index is less than 30 (the message length), at 
which point we move to the next column. 

If we imagine a list of 8 strings where each string is made up of the characters in each column, 
then the list value would look like this: 



['Ceno', 'onom', 'mstm', 'me o', 'o sn', 'nio.', ' s ', 's c'] 

This is how we can simulate the boxes in Python code. First, we will make a list of blank strings. 
This list will have a number of blank strings equal to the key because each string will represent a 
column of our paper-and-pencil boxes. (Our list will have 8 blank strings since we are using the 
key 8 in our example.) Let's look at the code. 







transposi ti onEncrypt . py 


22. 


# Each string "in ciphertext represents a column 


"in the grid. 


23. 


ciphertext = [''] * key 





The ciphertext variable will be a list of string values. Each string in the ciphertext 
variable will represent a column of the grid. So ciphertext [ 0 ] is the leftmost column, 
ciphertext [ 1 ] is the column to the right of that, and so on. 



The string values will have all the characters that go into one column of the grid. Let's look again 
at the grid from the "Common sense is not so common." example earlier in this chapter (with 
column numbers added to the top): 



0 1 2 3 4 5 6 7 



c 


o 


m 


m 


o 


n 


(s) 


s 


e 


n 


s 


e 


(s) 


i 


s 


(s) 


n 


o 


t 


(s) 


s 


o 


(s) 


c 


o 


m 


m 


o 


n 









The ciphertext variable for this grid would look like this: 



¬ª&gt; ciphertext = ['Ceno', 


'onom' , 


'mstm' , 


'me o' , 


'o sn' , 


'nio. ' , 


' s ' 


's c'] 


¬ª&gt; ciphertext[0] 
















'Ceno' 

















Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 115 



The first step to making this list is to create as many blank strings in the ciphertext list as 
there are columns. Since the number of columns is equal to the key, we can use list replication to 
multiply a list with one blank string value in it by the value in key. This is how line 23 evaluates 
to a list with the correct number of blank strings. 







transposi ti onEncrypt . py 


25. 


# Loop through each column in ciphertext. 




26. 


for col in range(key) : 




27. 


pointer = col 





The next step is to add text to each string in ciphertext. The for loop on line 26 will iterate 
once for each column, and the col variable will have the correct integer value to use for the 
index to ciphertext. The col variable will be set to 0 for the first iteration through the for 
loop, then 1 on the second iteration, then 2 and so on. This way the expression 
ciphertext [ col ] will be the string for the col 111 column of the grid. 



Meanwhile, the pointer variable will be used as the index for the string value in the message 
variable. On each iteration through the loop, pointer will start at the same value as col (which 
is what line 27 does.) 

Augmented Assignment Operators 

Often when you are assigning a new value to a variable, you want it to be based off of the 
variable's current value. To do this you use the variable as the part of the expression that is 
evaluated and assigned to the variable, like this example in the interactive shell: 



¬ª&gt; spam = 40 
¬ª&gt; spam = spam + 2 
¬ª&gt; print(spam) 
42 

¬ª&gt; 



But you can instead use the += augmented assignment operator as a shortcut. Try typing the 
following into the interactive shell: 



¬ª&gt; spam = 40 
¬ª&gt; spam += 2 
¬ª&gt; print(spam) 
42 

¬ª&gt; spam = 'Hello' 
¬ª&gt; spam += ' world!' 
¬ª&gt; print(spam) 



116 http://inventwithpython.com/hacking 



Hello world! 

¬ª&gt; spam = ['dog'] 

¬ª&gt; spam += ['cat'] 

¬ª&gt; print(spam) 

['dog', 'cat'] 

¬ª&gt; 



The statement spam += 2 does the exact same thing as spam = spam + 2. It's just a little 
shorter to type. The += operator works with integers to do addition, strings to do string 
concatenation, and lists to do list concatenation. Table 8-1 shows the augmented assignment 
operators and what they are equivalent to: 



Table 8-1. Augmented Assignment Operators 



Augmented Assignment 


Equivalent Normal 




Assignment 


spam += 42 


spam = spam + 4 2 


spam -= 42 


spam = spam - 4 2 


spam *= 42 


spam = spam * 4 2 


spam /= 42 


spam = spam / 4 2 



Back to the Code 





transposi ti onEncrypt . py 


29. 


# Keep looping until pointer goes past the length of the message. 


30. 


while pointer &lt; 1 en(message) : 


31. 


# Place the character at pointer in message at the end of the 


32. 


# current column in the ciphertext list. 


33. 


ci phertext[col ] += message [pointer] 


34. 




35. 


# move pointer over 


36. 


pointer += key 



Inside the for loop that started on line 26 is a while loop that starts on line 30. For each 
column, we want to loop through the original message variable and pick out every key th 
character. (In the example we've been using, we want every 8 th character since we are using a key 
of 8.) On line 27 for the first iteration of the for loop, pointer was set to 0. 



While the value in pointer is less than the length of the message string, we want to add the 
character at message [pointer] to the end of the col* string in ciphertext. We add 8 
(that is, the value in key) to pointer each time through the loop on line 36. The first time it is 
message [ 0 ] , the second time message [ 8 ] , the third time message [16], and the fourth 
time message [ 24 ] . Each of these single character strings are concatenated to the end of 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 117 



ciphertext [col ] (and since col is 0 on the first time through the loop, this is 

ciphertext [ 0 ] ). 



-jst 2 nd 3 rd 4 th 

I I I I 



c 


0 


m 


m 


0 


n 




s 


e 


n 


s 


e 




i 


s 




n 


0 


t 




s 


0 




c 


0 


m 


m 


0 


n 




0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


1 


1 


1 


1 


1 


1 


1 


1 


1 


1 


2 


2 


2 


2 


2 


2 


2 


2 


2 


2 






















0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


0 


1 


2 


3 


4 


5 


6 


7 


8 


9 



Figure 8-2. Arrows pointing to what message [pointer] refers to during the first iteration of 

the for loop when col is set to 0. 

Figure 8-2 shows the characters at these indexes, they will be concatenated together to form the 
string ' Ceno ' . Remember that we want the value in ciphertext to eventually look like this: 



¬ª&gt; ciphertext = ['Ceno', 


'onom' , 


'mstm' , 


'me o' , 


'o sn' , 


'nio. ' , 


' s ' 


's c'] 


&gt;¬ª ciphertext[0] 
















'Ceno' 
















&gt;¬ª 

















Storing ' Ceno ' as the first string in the ciphertext list is our first step. 



On the next iteration of the for loop, col will be set to 1 (instead of 0) and pointer will start 
at the same value as col. Now when we add 8 to pointer on each iteration of line 30's 
while loop, the indexes will be 1, 9, 17, and 25. 

-jst 2 nd 3 r 3 rd 4 th 



n u u n 



c 


0 


m 


m 


0 


n 




s 


e 


n 


s 


e 




i 


s 




n 


0 


t 




s 


0 




c 


0 


m 


m 


0 


n 




0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


1 


1 


1 


1 


1 


1 


1 


1 


1 


1 


2 


2 


2 


2 


2 


2 


2 


2 


2 


2 






















0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


0 


1 


2 


3 


4 


5 


6 


7 


8 


9 



Figure 8-3. Arrows pointing to to what message [pointer] refers to during the second 
iteration of the for loop when col is set to 1. 

As message [ 1 ] , message [ 9 ] , message [17], and message [ 25 ] are concatenated to the 
end of ciphertext [ 1 ] , they form the string ' onom ' . This is the second column of our grid. 



118 http://inventwithpython.com/hacking 



Once the for loop has finished looping for the rest of the columns, the value in ciphertext 
will be [ ' Ceno ' , ' onom ' , ' mstm ' , ' me o ' , ' o sn ' , ' nio s ' , ' s c ' ] . 

We will use the j oin ( ) string method to convert this list of strings into a single string. 

The join () String Method 

The join ( ) method is used later on line 39. The j oin ( ) method takes a list of strings and 
returns a single string. This single string has all of the strings in the list concatenated (that is, 
joined) together. The string that the join ( ) method gets called on will be placed in between the 
strings in the list. (Most of the time, we will just use a blank string for this.) Try typing the 
following into the interactive shell: 



&gt;¬ª eggs = ['dogs', 'cats', 'moose'] 

¬ª&gt; 1 ' . joi n(eggs) 

'dogscatsmoose' 

&gt;¬ª ' 1 .join (eggs) 

'dogs cats moose' 

&gt;¬ª 'XYZ' . join(eggs) 

' dogsXYZcatsXYZmoose ' 

¬ª&gt; ' ' . join(eggs) .upperO . join(eggs) 

' dogsDOGSCATSMOOSEcatsDOCSCATSMOOSEmoose ' 

¬ª&gt; 



That last expression, ' ' .join(eggs) .upper() . j oin (eggs ), looks a little tricky, but if 
you go through the evaluation one step at a time, it will look like this: 

' ' . join (eggs) .upperO .join (eggs) 
' ' .join (['dogs' , 'cats', 'moose']) .upperO .joi n(eggs) 

'dogscatsmoose' .upper() . join(eggs) 
'dogscatsmoose' . join(eggs) 
'dogscatsmoose' .join (['dogs' , 'cats', 'moose']) 

' dogsDOGSCATSMOOSEcatSDOGSCATSMOOSEmoose ' 
Figure 8-4. The steps of evaluation for ' ' . join (eggs ) . upper ( ) . join (eggs) 

Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 119 



This is why ' ' . j oin (eggs ) .upper () . j oin (eggs ) returns the string, 

' dogsDOGSCATSMOOSEcatsDOGSCATSMOOSEmoose ' . 

Whew! 

Remember, no matter how complicated an expression looks, you can just evaluate it step by step 
to get the single value the expression evaluates to. 

Return Values and return Statements 

transposi ti onEncrypt . py 

38. # Convert the ciphertext list "into a single string value and return it. 

39. return 1 ' . join(ciphertext) 

Our use of the j oin ( ) method isn't nearly as complicated as the previous example. We just 
want to call j oin ( ) on the blank string and pass ciphertext as the argument so that the 
strings in the ciphertext list are joined together (with nothing in between them). 

Remember that a function (or method) call always evaluates to a value. We say that this is the 
value returned by the function or method call, or that it is the return value of the function. When 
we create our own functions with a def statement, we use a return statement to tell what the 
return value for our function is. 

A return statement is the return keyword followed by the value to be returned. We can also 
use an expression instead of a value. In that case the return value will be whatever value that 
expression evaluates to. Open a new file editor window and type the following program in and 
save it as addNumbers.py, then press F5 to run it: 







Source code for addNumbers.py 


1. 


def addNumbers(a, b) : 




2. 
3. 


return a + b 




4. 


spam = addNumbers(2 , 40) 




5. 


print (spam) 





When you run this program, the output will be: 



42 

That's because the function call addNumbers (2 , 40 ) will evaluate to 42. The return 
statement in addNumbers ( ) will evaluate the expression a + b and then return the evaluated 



120 http://inventwithpython.com/hacking 

value. That is why addNumbers ( 2 , 4 0) evaluates to 4 2, which is the value stored in spam 
on line 4 and next printed to the screen on line 5. 

Practice Exercises, Chapter 8, Set E 

Practice exercises can be found at ht^://inypxAQn^^J^^ra^ce.8E. 

Back to the Code 

transposi ti onEncrypt . py 

38. # Convert the ciphertext list "into a single string value and return it. 

39. return ' ' . joi n(ci phertext) 

The encryptMessage ( ) function's return statement returns a string value that is created 
by joining all of the strings in the ciphertext list. This final string is the result of our 
encryption code. 

The great thing about functions is that a programmer only has to know what the function does, 
but not how the function's code does it. A programmer can understand that if she calls the 
encryptMessage ( ) function and pass it an integer and a string for the key and message 
parameters, the function call will evaluate to an encrypted string. She doesn't need to know 
anything about how the code in encryptMessage ( ) actually does this. 

The Special name Variable 

transposi ti onEncrypt . py 

42. # If transposi tionEncrypt . py is run (instead of imported as a module) call 

43. # the main() function. 

44. if name == ' main ': 

45. main() 

We can turn our transposition encryption program into a module with a special trick involving the 
main ( ) function and a variable named name . 

When a Python program is run, there is a special variable with the name name (that's two 

underscores before "name" and two underscores after) that is assigned the string value 

' main ' (again, two underscores before and after "main") even before the first line of your 

program is run. 

At the end of our script file (and, more importantly, after all of our def statements), we want to 

have some code that checks if the name variable has the ' main ' string assigned to 

it. If so, we want to call the main ( ) function. 



Email questions to the author: al@inventwithpython.com 



Chapter 8 - The Transposition Cipher, Encrypting 121 



This i f statement on line 44 ends up actually being one of the first lines of code executed when 
we press F5 to run our transposition cipher encryption program (after the import statement on 
line 4 and the def statements on lines 6 and 21). 

The reason we set up our code this way is although Python sets name to ' main ' 

when the program is run, it sets it to the string ' transpositionEncrypt ' if our program is 
imported by a different Python program. This is how our program can know if it is being run as a 
program or imported by a different program as a module. 

Just like how our program imports the pyperclip module to call the functions in it, other 
programs might want to import transpositionEncrypt.py to call its encryptMessage ( ) 
function. When an import statement is executed, Python will look for a file for the module by 
adding ".py" to the end of the name. (This is why import pyperclip will import the 
pyperclip.py file.) 

When a Python program is imported, the name variable is set to the filename part before 

".py" and then runs the program. When our transpositionEncrypt.py program is imported, we 
want all the def statements to be run (to define the encryptMessage () function that the 
importing program wants to use), but we don't want it to call the main ( ) function because that 
will execute the encryption code for ' Common sense is not so common . ' with key 8. 

That is why we put that part of the code inside a function (which by convention is named 
main () ) and then add code at the end of the program to call main (). If we do this, then our 
program can both be run as a program on its own and also imported as a module by 
another program. 



Key Size and Message Length 

Notice what happens when the message length is less than twice the key size: 



c 


o 


m 


m 


o 


n 


(s) 


s 


e 


n 


s 


e 


(s) 


i 


s 


(s) 


n 


o 


t 


(s) 


s 


o 


(s) 


c 


o 


m 


m 


o 


n 













































When using a key of 25, the "Common sense is not so common." message encrypts to 
"Cmommomno.n sense is not so co". Part of the message isn't encrypted! This happens whenever 
key size becomes more than twice the message length, because that causes there to only be one 
character per column and no characters get scrambled for that part of the message. 

Because of this, the transposition cipher's key is limited to half the length of the message it is 
used to encrypt. The longer a message is, the more possible keys that can be used to encrypt it. 



122 http://inventwithpython.com/hacking 



Summary 

Whew! There were a lot of new programming concepts introduced in this chapter. The 
transposition cipher program is much more complicated (but much more secure) than the Caesar 
cipher program in the last chapter. The new concepts, functions, data types, and operators we've 
learned in this chapter let us manipulate data in much more sophisticated ways. Just remember 
that much of understanding a line of code is just evaluating it step by step the way Python will. 

We can organize our code into groups called functions, which we create with def statements. 
Argument values can be passed to functions for the function's parameters. Parameters are local 
variables. Variables outside of all functions are global variables. Local variables are different 
from global variables, even if they have the same name as the global variable. 

List values can store multiple other values, including other list values. Many of the things you can 
do with strings (such as indexing, slicing, and the len ( ) function) can be used on lists. And 
augmented assignment operators provide a nice shortcut to regular assignment operators. The 
j oin ( ) method can join a list that contains multiple strings to return a single string. 

Feel free to go over this chapter again if you are not comfortable with these programming 
concepts. In the next chapter, we will cover decrypting with the transposition cipher. 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 123 



Chapter 9 

Decrypting with the 
Transposition Cipher 

Topics Covered In This Chapter: 

‚Ä¢ Decrypting with the transposition cipher 

‚Ä¢ The math . ceil (), math . floor ( ) and round () functions 

‚Ä¢ The and and or boolean operators 

‚Ä¢ Truth tables 



"When stopping a terrorist attack or seeking to 
recover a kidnapped child, encountering 
encryption may mean the difference between 
success and catastrophic failures." 

Attorney General Janet Reno, September 1999 

"Even the Four Horsemen of Kid Porn, Dope 
Dealers, Mafia and Terrorists don't worry me 
as much as totalitarian governments. It's been a 
long century, and we've had enough of them." 

Bruce Sterling, 1994 Computers, Freedom, and Privacy 

conference 




124 http://inventwithpython.com/hacking 



Unlike the Caesar cipher, the decryption process for the transposition cipher is very different 
from the encryption process. In this chapter we will create a separate program, 
transpositionDecrypt.py, to handle decryption. 

Decrypting with the Transposition Cipher on Paper 

Let's pretend we send the ciphertext "Cenoonommstmme oo snnio. s s c" to a friend (and she 
already knows that the secret key is 8). The first step for her to decrypt the ciphertext is to 
calculate how many boxes she needs to draw. To find this amount, divide the length of the 
ciphertext message by the key and round up. The length of our ciphertext is 30 characters (exactly 
the same as the plaintext) and the key is 8. So calculate 30 divided by 8 to get 3.75. 

3.75 rounds up to 4. This means we want to draw a grid of boxes with 4 columns (the number we 
just calculated) and 8 rows (the key). It will look like this: 



(Note that if the length divided by the key was a whole number, like in 30 / 5 = 6.0, then 6.0 
would not "round up" to 7.) 

The second thing we need to calculate is how many boxes on the rightmost column to shade in. 
Take the total number of boxes (32) and subtract the length of the ciphertext (30). 32 - 30 = 2, so 
shade in the bottom 2 boxes on the rightmost column: 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 125 

Then start filling in the boxes with one character of the ciphertext per box. Start at the top left and 
go right, just like we did when we were encrypting. The ciphertext is "Cenoonommstmme oo 
snnio. s s c", and so "Ceno" goes in the first row, then "onom" in the second row, and so on. 
After we are done, the boxes will look like this (where the (s) represents a space): 



c 


e 


n 


o 


o 


n 


o 


m 


m 


s 


t 


m 


m 


e 


(s) 


o 


o 


(s) 


s 


n 


n 


i 


o 




(s) 


s 


(s) 




s 


(s) 


c 





Our friend who received the ciphertext will see that if she reads the text going down the columns, 
the original plaintext has been restored: "Common sense is not so common." 

The steps for decrypting are: 

1 . Calculate the number of columns you will have by taking the length of the message and 
dividing by the key, then rounding up. 

2. Draw out a number of boxes. The number of columns was calculated in step 1. The 
number of rows is the same as the key. 

3. Calculate the number of boxes to shade in by taking the number of boxes (this is the 
number of rows and columns multiplied) and subtracting the length of the ciphertext 
message. 

4. Shade in the number of boxes you calculated in step 3 at the bottom of the rightmost 
column. 

5. Fill in the characters of the ciphertext starting at the top row and going from left to right. 
Skip any of the shaded boxes. 

6. Get the plaintext by reading from the leftmost column going from top to bottom, and 
moving over to the top of the next column. 

Note that if you use a different key, you will be drawing out the wrong number of rows. Even if 
you follow the other steps in the decryption process correctly, the plaintext will come out looking 
like random garbage (just like when you use the wrong key with the Caesar cipher). 

Practice Exercises, Chapter 9, Set A 

Practice exercises can be found at ht^://inypxAQn^^J^^ra(^ce9A. 



126 http://inventwithpython.com/hacking 



A Transposition Cipher Decryption Program 

Open a new file editor window and type out the following code in it. Save this program as 
transpositionDecrypt.py . 

Source Code of the Transposition Cipher Decryption Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as transpositionDecrypt.py. Press F5 to run the program. Note 
that first you will need to download the pyperclip.py module and place this file in the same 
directory as the transpositionDecrypt.py file. You can download this file from 
http;//inypy.cpnVpypercnp..py. 







Source code for transpositionDecrypt.py 


1. 


# Transposition Cipher Decryption 


2 . 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 


4. 

5. 


import math, pyperclip 


6. 


net 


mai n O '‚Ä¢ 


7. 




myMessage = ' Cenoonommstmme oo snnio. s s c 1 


8. 
9. 




myKey = 8 


10. 




plaintext = decryptMessage(myKey , myMessage) 


11. 






12. 




# Print with a | (called "pipe" character) after it in case 


13. 




# there are spaces at the end of the decrypted message. 


14. 




print(plaintext + ' | ') 


15. 






16. 




pype rcl i p . copy (pi ai ntext) 


17. 






18. 






19. 


def 


decryptMessage(key, message): 


20. 




# The transposition decrypt function will simulate the "columns" and 


21. 




# "rows" of the grid that the plaintext is written on by using a list 


22. 




# of strings. First, we need to calculate a few values. 


23. 






24. 




# The number of "columns" in our transposition grid: 


25. 




numOfColumns = math . cei 1 (1 en(message) / key) 


26. 




# The number of "rows" in our grid will need: 


27. 




numOfRows = key 


28. 




# The number of "shaded boxes" in the last "column" of the grid: 


29. 




numOfShadedBoxes = (numOfColumns * numOfRows) - len(message) 


30. 






31. 




# Each string in plaintext represents a column in the grid. 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 127 



32. plaintext = [''] * numOfCol umns 
33. 

34. # The col and row variables point to where in the grid the next 

35. # character in the encrypted message will go. 

36. col = 0 

37. row = 0 
38. 

39. for symbol in message: 

40. plaintext [col] += symbol 

41. col += 1 # point to next column 
42. 

43. # If there are no more columns OR we're at a shaded box, go back to 

44. # the first column and the next row. 

45. if (col == numOf Col umns) or (col == numOfColumns - 1 and row &gt;= 
numOf Rows - numOf ShadedBoxes) : 

46. col = 0 

47. row += 1 
48. 

49. return 1 ' .join (plaintext) 

50. 

51. 



52. # If transpositionDecrypt.py is run (instead of imported as a module) call 

53. # the main() function. 

54. if name == ' main ': 

55. main() 

When you run the above program, it produces this output: 



Common sense is not so common. | 

If you want to decrypt a different message, or use a different key, change the value assigned to 
the myMessage and myKey variables on lines 5 and 6. 



How the Program Works 







t ransposi ti onDecrypt . py 


1. 


# Transposition Cipher Decryption 




2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 
5. 


import math, pyperclip 




6. 


def main() : 




7. 


myMessage = ' Cenoonommstmme oo snnio. s s c' 




8. 

n 


myKey = 8 





128 http://inventwithpython.com/hacking 



10. 


plaintext = decryptMessage(myKey , myMessage) 


11. 




12. 


# Print with a | (called "pipe" character) after it in case 


13. 


# there are spaces at the end of the decrypted message. 


14. 


print(plaintext + ' | ') 


15. 




16. 


pype rcl i p . copy (pi ai ntext) 



The first part of the program is very similar to the first part of transpositionEncrypt.py. The 
pyperclip module is imported along with a different module named math. If you separate the 
module names with commas, you can import multiple modules with one import statement. 



The main ( ) function creates variables named myMes sage and myKey, and then calls the 
decryption function decryptMessage ( ) . The return value of this function is the decrypted 
plaintext of the ciphertext and key that we passed it. This is stored in a variable named 
plaintext, which is then printed to the screen (with a pipe character at the end in case there 
are spaces at the end of the message) and copied to the clipboard. 



t ransposi ti onDec rypt . py 

19. def decryptMessage(key , message): 

Look at the six steps to decrypting from earlier in this chapter. For example, if we are decrypting 
"Cenoonommstmme oo snnio. s s c" (which has 30 characters) with the key 8, then the final set of 
boxes will look like this: 



c 


e 


n 


o 


o 


n 


o 


m 


m 


s 


t 


m 


m 


e 


(s) 


o 


o 


(s) 


s 


n 


n 


i 


o 




(s) 


s 


(s) 




s 


(s) 


c 





The decryptMessage ( ) function implements each of the decryption steps as Python code. 

The math . ceil ( ) , math . floor ( ) and round ( ) Functions 

When you divide numbers using the / operator, the expression returns a floating point number 
(that is, a number with a decimal point). This happens even if the number divides evenly. For 
example, 21/7 will evaluate to 3 . 0, not 3. 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 129 



¬ª&gt; 21/7 
3.0 

¬ª&gt; 

This is useful because if a number does not divide evenly, the numbers after the decimal point 
will be needed. For example, 2 2/5 evaluates to 4 . 4 : 



¬ª&gt; 22 / 5 
4.4 

¬ª&gt; 

(If the expression 2 2/5 evaluates to 4 instead of 4 . 4 , then you are using version 2 of Python 
instead of version 3. Please go to the http;//pythpn,org website and download and install Python 
3.) 

If you want to round this number to the nearest integer, you can use the round ( ) function. Type 
the following into the interactive shell: 



¬ª&gt; round(4.2) 
4 

¬ª&gt; round(4.5) 
4 

¬ª&gt; round(4.9) 
5 

¬ª&gt; round(5.0) 
5 

¬ª&gt; round(22 / 5) 
4 

¬ª&gt; 

If you only want to round up then use the math .ceil ( ) function, which stands for "ceiling". If 
you only want to round down then use the math . floor ( ) function. These functions exist in 
the math module, so you will need to import the math module before calling them. Type the 
following into the interactive shell: 



¬ª&gt; "import math 
¬ª&gt; math. floor (4.0) 
4 

¬ª&gt; math.floor(4.2) 
4 

¬ª&gt; math. floor (4. 9) 
4 

¬ª&gt; math. ceil (4.0) 



1 30 http://inventwithpython.com/hacking 



4 






¬ª&gt; 


math 


ceil (4.2) 


5 






¬ª&gt; 


math 


ceil (4.9) 


5 






¬ª&gt; 







The math . ceil ( ) function will implement step 1 of the transposition decryption. 



t ransposi ti onDec rypt . py 

19. def decryptMessage(key , message): 

20. # The transposition decrypt function will simulate the "columns" and 

21. # "rows" of the grid that the plaintext is written on by using a list 

22. # of strings. First, we need to calculate a few values. 
23. 

24. # The number of "columns" in our transposition grid: 

25. numOfCol umns = math . cei 1 (1 en (message) / key) 

26. # The number of "rows" in our grid will need: 

27. numOfRows = key 

28. # The number of "shaded boxes" in the last "column" of the grid: 

29. numOf ShadedBoxes = (numOfCol umns * numOfRows) - len(message) 

Line 25 calculates the number of columns (step 1 of decrypting) by dividing len (mes sage ) by 
the integer in key. This value is passed to the math . ceil ( ) function, and that return value is 
stored in numOf Columns. 

Line 27 calculates the number of rows (step 2 of decrypting), which is the integer stored in key. 
This value gets stored in the variable numOfRows. 

Line 29 calculates the number of shaded boxes in the grid (step 3 of decrypting), which will be 
the number of columns times rows, minus the length of the message. 



If we are decrypting "Cenoonommstmme oo snnio. s s c" with key 8, numOf Columns will be 
set to 4, numOfRows will be set to 8, and numOf ShadedBoxes will be set to 2. 







t ransposi ti onDec rypt . py 


31. 


# Each string in 


plaintext represents a column in the grid. 


32. 


plaintext = ["] 


* numOf Col umns 



Just like the encryption program had a variable named ciphertext that was a list of strings to 
represent the grid of ciphertext, the decryptMessage ( ) function will have a variable named 
plaintext that is a list of strings. These strings start off as blank strings, and we will need one 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 131 



string for each column of the grid. Using list replication, we can multiply a list of one blank string 
by numOf Columns to make a list of several blank strings. 

(Remember that each function call has its own local scope. The plaintext in 
decryptMessage ( ) exists in a different local scope than the plaintext variable in 
main (), so they are two different variables that just happen to have the same name.) 

Remember that the grid for our ' Cenoonommstmme oo snnio. s s c ' example looks 
like this: 



c 


e 


n 


o 


o 


n 


o 


m 


m 


s 


t 


m 


m 


e 


(s) 


o 


o 


(s) 


s 


n 


n 


i 


o 




(s) 


s 


(s) 




s 


(s) 


c 





The plaintext variable will have a list of strings. Each string in the list is a single column of 
this grid. For this decryption, we want plaintext to end up with this value: 



¬ª&gt; plaintext = ['Common s', 


'ense is ' 


'not so c' , 


' ommon . ' ] 


¬ª&gt; pi ai ntext [0] 








'Common s' 









That way, we can join all the list's strings together to get the ' Common sense is not so 
common . ' string value to return. 





transposi ti onDecrypt . py 


34. 


# The col and row variables point to where in the grid the next 


35. 


# character in the encrypted message will go. 


36. 


col = 0 


37. 


row = 0 


38. 




39. 


for symbol in message: 



The col and row variables will track the column and row where the next character in message 
should go. We will start these variables at 0. Line 39 will start a for loop that iterates over the 
characters in the message string. Inside this loop the code will adjust the col and row 
variables so that we concatenate symbol to the correct string in the plaintext list. 



132 


http://inventwithpython.com/hacking 








trsn^nn^'i nnnprrvnl" nv 

li qiij|juj I l i ui iucli y \j l . yj y 


40. 


plaintext [col] += symbol 




41. 


col += 1 # point to next column 





As the first step in this loop we concatenate symbol to the string at index col in the 
plaintext list. Then we add 1 to col (that is, we increment col) on line 41 so that on the 
next iteration of the loop, symbol will be concatenated to the next string. 



The and and or Boolean Operators 

The Boolean operators and and or can help us form more complicated conditions for if and 
while statements. The and operator connects two expressions and evaluates to True if both 
expressions evaluate to True. The or operator connects two expressions and evaluates to True 
if one or both expressions evaluate to True. Otherwise these expressions evaluate to False. 
Type the following into the interactive shell: 



¬ª&gt; 10 &gt; 


5 


and 


2 &lt; 4 


True 








¬ª&gt; 10 &gt; 


5 


and 


4 != 4 


False 








¬ª&gt; 









The first expression above evaluates to True because the two expressions on the sides of the 
and operator both evaluate to True. This means that the expression 1 0 &gt; 5 and 2 &lt; 4 
evaluates to True and True, which in turn evaluates to True. 



However, for the second above expression, although 10 &gt; 5 evaluates to True the expression 
4 != 4 evaluates to False. This means the whole expression evaluates to True and 
False. Since both expressions have to be True for the and operator to evaluate to True, 
instead they evaluate to False. 



Type the following into the interactive shell: 



¬ª&gt; 10 &gt; 


5 


or 4 


!= 4 


True 








¬ª&gt; 10 &lt; 


5 


or 4 


!= 4 


False 








¬ª&gt; 









For the or operator, only one of the sides must be True for the or operator to evaluate them 
both to True. This is why 10 &gt; 5 or 4 !=4 evaluates to True. However, because both 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 133 



the expression 1 0 &lt; 5 and the expression 4 ! = 4 are both False, this makes the second 
above expression evaluate to False or False, which in turn evaluates to False. 

The third Boolean operator is not. The not operator evaluates to the opposite Boolean value of 
the value it operates on. So not True is False and not False is True. Type the following 
into the interactive shell: 



¬ª&gt; not 10 &gt; 5 
False 

¬ª&gt; not 10 &lt; 5 
True 

¬ª&gt; not False 
True 

¬ª&gt; not not False 
False 

¬ª&gt; not not not not not False 
True 

¬ª&gt; 



Practice Exercises, Chapter 9, Set B 

Practice exercises can be found at ht^://invpxAQrr^^J^^ra(^ce9B. 

Truth Tables 

If you ever forget how the Boolean operators work, you can look at these charts, which are called 
truth tables: 



Table 6-1: The and operator's truth table. 



A 


and 


B 


is 


Entire statement 


True 


and 


True 


is 


True 


True 


and 


False 


is 


False 


False 


and 


True 


is 


False 


False 


and 


False 


is 


False 



Table 6-2: The or operator's truth table. 



A 


or 


B 


is 


Entire statement 


True 


or 


True 


is 


True 


True 


or 


False 


is 


True 


False 


or 


True 


is 


True 


False 


or 


False 


is 


False 



1 34 http://inventwithpython.com/hacking 



Table 6-3: The not operator's truth table. 



not A 


is 


Entire statement 


not True 


is 


False 


not False 


is 


True 



The and and or Operators are Shortcuts 

Just like for loops let us do the same thing as while loops but with less code, the and and or 
operators let us shorten our code also. Type in the following into the interactive shell. Both of 
these bits of code do the same thing: 



¬ª&gt; if 10 &gt; 5: 
i f 2 &lt; 4 : 

print ('Hello! ') 

Hello! 

¬ª&gt; 

¬ª&gt; if 10 &gt; 5 and 2 &lt; 4: 
printC'Hello! ') 

Hello! 

¬ª&gt; 

So you can see that the and operator basically takes the place of two if statements (where the 
second if statement is inside the first if statement's block.) 

You can also replace the or operator with an if and elif statement, though you will have to 
copy the code twice. Type the following into the interactive shell: 



¬ª&gt; if 4 != 4: 

printC'Hello!') 
. . . elif 10 &gt; 5: 

printC'Hello!') 

Hello! 

¬ª&gt; 

¬ª&gt; if 4 != 4 or 10 &gt; 5: 
printC'Hello!') 

Hello! 

¬ª&gt; 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 135 



Order of Operations for Boolean Operators 

Just like the math operators have an order of operations, the and, or, and not operators also 
have an order of operations: first not, then and, and then or. Try typing the following into the 
interactive shell: 



¬ª&gt; not 


False and True 


# 


not False evaluates first 


True 








&gt;¬ª not 


(False and True) 


# 


(False and True) evaluates first 


False 








¬ª&gt; 









Back to the Code 







transposi ti onDecrypt . py 


43. 


# If there are no more columns OR 


we're at a shaded box, go back to 


44. 


# the first column and the next rc 




45. 


if (col == numOfCol umns) or (col = 


== numOfColumns - 1 and row &gt;= 


numOf Rows 


- numOf ShadedBoxes) : 




46. 


col = 0 




47. 


row += 1 





There are two cases where we want to reset col back to 0 (so that on the next iteration of the 
loop, symbol is added to the first string in the list in plaintext). The first is if we have 
incremented col past the last index in plaintext. In this case, the value in col will be equal 
to numOfColumns. (Remember that the last index in plaintext will be numOfColumns 
minus one. So when col is equal to numOfColumns, it is already past the last index.) 



The second case is if both col is at the last index and the row variable is pointing to a row that 
has a shaded box in the last column. Here's the complete decryption grid with the column indexes 
along the top and the row indexes down the side: 



136 http://inventwithpython.com/hacking 





0 


1 


2 


3 


0 


c 


e 


n 


o 




0 


1 


2 


3 


1 


o 


n 


o 


m 




4 


5 


6 


7 


2 


m 


s 


t 


m 




8 


9 


10 


11 


3 


m 


e 


(s) 


o 




12 


13 


14 


15 


4 


o 


(s) 


s 


n 




16 


17 


18 


19 


5 


n 


i 


o 






20 


21 


22 


23 


6 


(s) 


s 


(s) 






24 


25 


26 




7 


s 


(s) 


c 






27 


28 


29 





You can see that the shaded boxes are in the last column (whose index will be numOf Columns 
- 1) and rows 6 and 7. To have our program calculate which row indexes are shaded, we use the 
expression row &gt;= numOfRows - numOf ShadedBoxes. If this expression is True, and 
col is equal to numOf Columns - 1, then we know that we want to reset col to 0 for the 
next iteration. 

These two cases are why the condition on line 45 is (col == numOf Columns ) or (col 
== numOfColumns - 1 and row &gt;= numOfRows - numOf ShadedBoxes ). That 
looks like a big, complicated expression but remember that you can break it down into smaller 
parts. The block of code that executes will change col back to the first column by setting it to 0. 
We will also increment the row variable. 







transposi ti onDecrypt . py 


49. return 1 


' .join (plaintext) 





By the time the for loop on line 39 has finished looping over every character in me s sage, the 
plaintext list's strings have been modified so that they are now in the decrypted order (if the 
correct key was used, that is). The strings in the plaintext list are joined together (with a 
blank string in between each string) by the j oin ( ) string method. The string that this call to 
j oin ( ) returns will be the value that our decryptMessage ( ) function returns. 



Email questions to the author: al@inventwithpython.com 



Chapter 9 - The Transposition Cipher, Decrypting 137 



For our example decryption, plaintext will be [' Common s', 'ense is ', 'not so 
c', ' ommon .'], so ''. join (plaintext) will evaluate to ' Common sense is not 
so common . ' . 







transposi ti onDecrypt . py 


52. 


# If transpositionDecrypt.py is 


run ("instead of imported as a module) call 


53. 


# the mainO function. 




54. 


"if name == ' main ': 




55. 


mainO 





The first line that our program runs after importing modules and executing the de f statements is 
the i f statement on line 54. Just like in the transposition encryption program, we check if this 
program has been run (instead of imported by a different program) by checking if the special 

name variable is set to the string value ' main ' . If so, we execute the main ( ) 

function. 



Practice Exercises, Chapter 9, Set C 

Practice exercises can be found at ht^://invpxAQn^^J^^ra(^ce9C. 

Summary 

That's it for the decryption program. Most of the program is in the decryptMe s sage ( ) 
function. We can see that our programs can encrypt and decrypt the message "Common sense is 
not so common." with the key 8. But we should try several other messages and keys to see that a 
message that is encrypted and then decrypted will result in the same thing as the original 
message. Otherwise, we know that either the encryption code or the decryption code doesn't 
work. 

We could start changing the key and message variables in our transpositionEncrypt.py and 
transpositionDecrypt.py and then running them to see if it works. But instead, let's automate this 
by writing a program to test our program. 



138 http://inventwithpython.com/hacking 




Chapter 10 



Programming a Program to 
Test Our Program 

Topics Covered In This Chapter: 

‚Ä¢ The random . seed ( ) function 

‚Ä¢ The random . randint ( ) function 

‚Ä¢ List references 

‚Ä¢ The copy . deepcopy ( ) Functions 

‚Ä¢ The random . shuffle ( ) function 

‚Ä¢ Randomly scrambling a string 

‚Ä¢ The sys . exit ( ) function 



"It is poor civic hygiene to install technologies that 
could someday facilitate a police state." 

Bruce Schneier, cryptographer 

We can try out the transposition encryption and decryption programs from the previous chapter 
by encrypting and decrypting a few messages with different keys. It seems to work pretty well. 
But does it always work? 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 139 



You won't know unless you test the encryptMessage () and decryptMes sage () 
functions with different values for the mes sage and key parameters. This would take a lot of 
time. You'll have to type out a message in the encryption program, set the key, run the encryption 
program, paste the ciphertext into the decryption program, set the key, and then run the 
decryption program. And you'll want to repeat that with several different keys and messages! 

That's a lot of boring work. Instead we can write a program to test the cipher programs for us. 
This new program can generate a random message and a random key. It will then encrypt the 
message with the encryptMes sage ( ) function from transpositionEncrypt.py and then pass 
the ciphertext from that to the decryptMes sage ( ) in transpositionDecrypt.py. If the plaintext 
returned by decryptMes sage ( ) is the same as the original message, the program can know 
that the encryption and decryption messages work. This is called automated testing. 

There are several different message and key combinations to try, but it will only take the 
computer a minute or so to test thousands different combinations. If all of those tests pass, then 
we can be much more certain that our code works. 

Source Code of the Transposition Cipher Tester Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as transpositionTest.py. Press F5 to run the program. Note 
that first you will need to download the pyperclip.py module and place this file in the same 
directory as the transpositionTest.py file. You can download this file from 
http;//inypy,corrypyperclip.py. 



Source code for transpositionTest.py 

1. # Transposition Cipher Test 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import random, sys , transpositionEncrypt , transpositionDecrypt 

5. 

6. def mainQ : 



7. random . seed(42) # set the random "seed" to a static value 
8. 

9. for i in range(20): # run 20 tests 
10. # Generate random messages to test. 

11. 

12. # The message will have a random length: 

13. message = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ' * random . randi nt(4 , 40) 
14. 

15. # Convert the message string to a list to shuffle it. 

16. message = 1 i st(message) 

17. random. shuff 1 e(message) 



140 http://inventwithpython.com/hacking 



message = ' 1 .join (message) # convert list to string 

printC'Test #%s: "%s..."' % (i+1, message [: 50])) 

# Check all possible keys for each message, 
for key in range(l, len(message)) : 

encrypted = transpositionEncrypt.encryptMessage(key, message) 
decrypted = transpositionDecrypt.decryptMessage(key, encrypted) 

# If the decryption doesn't match the original message, display 

# an error message and quit, 
if message != decrypted: 

printC'Mismatch with key %s and message %s.' % (key, 

pri nt(decrypted) 
sys.exitQ 



18. 
19. 
20. 
21. 
22. 
23. 
24. 
25. 
26. 
27. 
28. 
29. 
30. 

message)) 
31. 
32. 
33. 

34. print('Transposition cipher test passed.') 

35. 

36. 

37. # If transpositionTest.py is run (instead of imported as a module) call 

38. # the main() function. 

39. if name == ' main ': 

40. mainQ 



Sample Run of the Transposition Cipher Tester Program 



When you run this program, the output will look like this: 



Test #1 
Test #2 
Test #3 
Test #4 
Test #5 
Test #6 
Test #7 
Test #8 
Test #9 
Test #10 
Test #11 
Test #12 
Test #13 
Test #14 
Test #15 
Test #16 



"kqdxsfqdbpmmrgxfkcgiqugwfflajijkfjgsyosawgybguntqx. . 
"iddxeewumwujpjszfjsgaomfiowweyanrxisciikxzrhmrncfyw. . 
"dkayrsagsgcsiqwkgarqhaozdlgkjisqvmdfgyxkcrmpcmqwjm. . 
"mzibc0exgrdtfxzkvnfqwqmwir0ja0ktwistdwahzrvigx0lza. . 
"tiniecncbfkjbrdiutngdinhulysvtghbawdqmzcnhzotnyhsx. . 
" jzqihcvndwrdufhzfxciasydstgqatqoylihufpkexsozxqgpp. . 
"bmkjuerfngidgwapqmdznhoqpleoqdyciiwrkpveiplagzcjvn . . 
"ipastgzslpycorcvekwholovufpomgqwzvjnyqiyveofluwlmq. . 
"ahryjaptaczqnnfotonmipyecoordgeyesyfhrozdasfipksop . . 

"fsxaaplsqhsfupqzgtixxdldmoivmwfghpbpjroosegpevrxsx. 

"ivbcxbihlwptdhgeganbgxwqzmvxqpnjzqpkmrumpllxpafitn . 

"llnsymnrxzvynprtvnibfrsugiwujrempzvcmjatmlamceehnw. 

"imwrujjhrwaabhyihgnps:uovkrrkbs:kdhobdlou:dgxivdme. 

"izvxwhtigkghkjggwmobaktwzw:phgneqpinyziberjpunwjmx. 

"bqgfnmgqcibotrhzzobhzfjzvsrtvhiujfowrfbnwkrnhgoheq. 

"lnkgksyiphmcdvkdlndvfcifgewqgujyjicuyivxarmucbnuwm . 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 141 



Test #17: "WCNRHKIQZMOPBQTCRYPSEPWHLRDXZMJOUTJCLECKEZZRRMQRNI . . 
Test #18: "PPVTELDHJRZFPBNMJRLAZWRXRQVKHUUMRPNFKXXUKFOXAGEHM . . 
Test #19: "UXUICAYKGLYUQTFBWQUTFNSOPEGMIWMQYEZAVCALCOHUXJZPTY. . ." 
Test #20: " JSYTDGLVLBCVVSITPTQPHBCYIZHKFOFMBWOZNFKCADHDKPJSJA. . 
Transposition cipher test passed. 

Our testing program works by importing the transpositionEncrypt.py and transpositionDecrypt.py 

programs as modules. This way, we can call the encryptMessage ( ) and 

decryptMes sage ( ) functions in these programs. Our testing program will create a random 

message and choose a random key. It doesn't matter that the message is just random letters, we 

just need to check that encrypting and then decrypting the message will result in the original 

message. 

Our program will repeat this test twenty times by putting this code in a loop. If at any point the 
returned string from transpositionDecrypt ( ) is not the exact same as the original 
message, our program will print an error message and exit. 

How the Program Works 

t ransposi ti onTest . py 

1. # Transposition Cipher Test 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import random, sys , transpositionEncrypt , transpositionDecrypt 

5. 

6. def main() : 

First our program imports two modules that come with Python, random and sys. We also want 
to import the transposition cipher programs we've written: transpositionEncrypt.py and 
transpositionDecrypt.py. Note that we don't put the .py extension in our import statement. 

Pseudorandom Numbers and the random . seed ( ) Function 

t ransposi ti onTest . py 

7. random. seed(42) # set the random "seed" to a static value 

Technically, the numbers produced by Python's random . randint ( ) function are not really 
random. They are produced from a pseudorandom number generator algorithm, and this 
algorithm is well known and the numbers it produces are predictable. We call these random- 
looking (but predictable) numbers pseudorandom numbers because they are not truly random. 



142 http://inventwithpython.com/hacking 



The pseudorandom number generator algorithm starts with an initial number called the seed. All 
of the random numbers produced from a seed are predictable. You can reset Python's random 
seed by calling the random . seed ( ) function. Type the following into the interactive shell: 



¬ª&gt; 


"import random 




¬ª&gt; 


random. seed (42) 




¬ª&gt; 


for i in range(5) : 






pMnt(random. randint(l, 


10)) 


7 






1 






3 






3 






8 






¬ª&gt; 


random. seed(42) 




¬ª&gt; 


for i in range(5) : 






print(random. randint(l, 


10)) 


7 






1 






3 






3 






8 






¬ª&gt; 







When the seed for Python's pseudorandom number generator is set to 42, the first "random" 
number between 1 and 1 0 will always be 7 . The second "random" number will always be 1 , and 
the third number will always be 3, and so on. When we reset the seed back to 42 again, the same 
set of pseudorandom numbers will be returned from random . randint ( ) . 



Setting the random seed by calling random . seed ( ) will be useful for our testing program, 
because we want predictable numbers so that the same pseudorandom messages and keys are 
chosen each time we run the automated testing program. Our Python programs only seem to 
generate "unpredictable" random numbers because the seed is set to the computer's current clock 
time (specifically, the number of seconds since January 1 st , 1970) when the random module is 
first imported. 

It is important to note that not using truly random numbers is a common security flaw of 
encryption software. If the "random" numbers in your programs can be predicted, then this can 
provide a cryptanalyst with a useful hint to breaking your cipher. More information about 
generating truly random numbers with Python using the os . urandom ( ) function can be found 
at http ;//inypy ;.cpm/randpm. 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 143 



The random, randint ( ) Function 







t ransposi ti onTest . py 


9. 


for i in range(20): # run 20 tests 




10. 


# Generate random messages to test. 




11. 






12. 


# The message will have a random length: 






message = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ' * 


random. randint(4, 40) 



The code that does a single test will be in this for loop's block. We want this program to run 
multiple tests since the more tests we try, the more certain that we know our programs work. 



Line 13 creates a random message from the uppercase letters and stores it in the message 
variable. Line 13 uses string replication to create messages of different lengths. The 
random . randint ( ) function takes two integer arguments and returns a random integer 
between those two integers (including the integers themselves). Type the following into the 
interactive shell: 



¬ª&gt; 


import 


random 


¬ª&gt; 


random 


randint(l, 20) 


20 






¬ª&gt; 


random 


randint(l, 20) 


18 






¬ª&gt; 


random 


randint(l, 20) 


3 






¬ª&gt; 


random 


randint(l, 20) 


18 






¬ª&gt; 


random 


randintdOO, 200) 


107 






¬ª&gt; 







Of course, since these are pseudorandom numbers, the numbers you get will probably be different 
than the ones above. Line 13 creates a random message from the uppercase letters and stores it in 
the message variable. Line 13 uses string replication to create messages of different lengths. 



References 

Technically, variables do not store list values in them. Instead, they store reference values to list 
values. Up until now the difference hasn't been important. But storing list references instead of 
lists becomes important if you copy a variable with a list reference to another variable. Try 
entering the following into the shell: 



144 http://inventwithpython.com/hacking 



&gt;&gt;&gt; 


spam = 


42 


&gt;&gt;&gt; 


cheese 


= spam 


&gt;&gt;&gt; 


spam = 


100 


&gt;&gt;&gt; 


spam 




100 






&gt;&gt;&gt; 


cheese 




42 






&gt;&gt;&gt; 







This makes sense from what we know so far. We assign 4 2 to the spam variable, and then we 
copy the value in spam and assign it to the variable cheese . When we later change the value in 
spam to 10 0, this doesn't affect the value in cheese. This is because spam and cheese are 
different variables that each store their own values. 

But lists don't work this way. When you assign a list to a variable with the = sign, you are 
actually assigning a list reference to the variable. A reference is a value that points to some bit 
of data, and a list reference is a value that points to a list. Here is some code that will make this 
easier to understand. Type this into the shell: 



&gt;&gt;&gt; 


spam = 


[0, 1, 2, 3, 4, 5] 


&gt;&gt;&gt; 


cheese 


= spam 


&gt;&gt;&gt; 


cheese [1] = 'Hello! ' 


&gt;&gt;&gt; 


spam 




[0, 


'Hello. 


2, 3, 4, 5] 


&gt;&gt;&gt; 


cheese 




[0, 


'Hello. 


2, 3, 4, 5] 



This looks odd. The code only changed the cheese list, but it seems that both the cheese and 
spam lists have changed. 

Notice that the line cheese = spam copies the list reference in spam to cheese, instead of 
copying the list value itself. This is because the value stored in the spam variable is a list 
reference, and not the list value itself. This means that the values stored in both spam and 
cheese refer to the same list. There is only one list because the list was not copied, the reference 
to the list was copied. So when you modify cheese in the cheese [ 1 ] = 'Hello ! ' line, 
you are modifying the same list that spam refers to. This is why spam seems to have the same 
list value that cheese does. 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 145 



Remember that variables are like boxes that contain values. List variables don't actually contain 
lists at all, they contain references to lists. Here are some pictures that explain what happens in 
the code you just typed in: 



Q spam = [0, 1,2, 3,4,5] 




(a lisf value) 



[0,1,2, 3,4,5] 



Figure 10-1. Variables do not store lists, but rather references to lists. 

On the first line, the actual list is not contained in the spam variable but a reference to the list. 
The list itself is not stored in any variable. 



^2) cheese = spam 



(a lisf value) 




Figure 10-2. Two variables store two references to the same list. 



146 http://inventwithpython.com/hacking 

When you assign the reference in spam to cheese, the cheese variable contains a copy of the 
reference in spam. Now both cheese and spam refer to the same list. 




Figure 10-3. Changing the list changes all variables with references to that list. 

When you alter the list that cheese refers to, the list that spam refers to is also changed because 
they refer to the same list. If you want spam and cheese to store two different lists, you have to 
create two different lists instead of copying a reference: 



&gt;&gt;&gt; spam = 


[0, 1, 2, 3, 


4, 5] 


&gt;&gt;&gt; cheese 


= [0, 1, 2, 


3, 4, 5] 



In the above example, spam and cheese have two different lists stored in them (even though 
these lists are identical in content). Now if you modify one of the lists, it will not affect the other 
because spam and cheese have references to two different lists: 

¬ª&gt; spam = [0, 1, 2, 3, 4, 5] 
¬ª&gt; cheese = [0, 1, 2, 3, 4, 5] 
&gt;&gt;&gt; cheese[l] = 'Hello!' 
&gt;&gt;&gt; spam 

[0, 1, 2, 3, 4, 5] 

&gt;&gt;&gt; cheese 

[0, 'Hello! ' , 2, 3, 4, 5] 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 147 
Figure 10-4 shows how the two references point to two different lists: 




Figure 10-4. Two variables each storing references to two different lists. 

The copy . deepcopy ( ) Functions 

As we saw in the previous example, the following code only copies the reference value, not the 
list value itself: 



&gt;¬ª spam = [0, 1, 2, 3, 4, 5] 

¬ª&gt; cheese = spam # copies the reference, not the list 

If we want to copy the list value itself, we can import the copy module to call the 
copy . deepcopy ( ) function, which will return a separate copy of the list it is passed: 



¬ª&gt; spam = [0, 1, 2, 3, 4, 5] 
&gt;¬ª import copy 

¬ª&gt; cheese = copy, deepcopy (spam) 
¬ª&gt; cheese[l] = 'Hello! ' 
&gt;¬ª spam 

[0, 1, 2, 3, 4, 5] 
¬ª&gt; cheese 

[0, 'Hello! ' , 2, 3, 4, 5] 

¬ª&gt; 



148 http://inventwithpython.com/hacking 



The copy . deepcopy ( ) fUnction isn't used in this chapter's program, but it is helpful when 
you need to make a duplicate list value to store in a different variable. 

Practice Exercises, Chapter 10, Set A 

Practice exercises can be found at ht^://inypxAQn^^J^^ra^celOA. 



The random, shuffle () Function 

The random . shuffle ( ) function is also in the random module. It accepts a list argument, 
and then randomly rearranges items in the list. Type the following into the interactive shell: 



¬ª&gt; 


"import random 




¬ª&gt; 


spam = [0, 1, 2, 3, 4, 5, 6, 7, 8 


, 9] 


¬ª&gt; 


spam 




[0, 


1, 2, 3, 4, 5, 6, 7, 8, 9] 




¬ª&gt; 


random. shuffl e(spam) 




¬ª&gt; 


spam 




[3, 


0, 5, 9, 6, 8, 2, 4, 1, 7] 




¬ª&gt; 


random. shuffl e(spam) 




¬ª&gt; 


spam 




[1, 


2, 5, 9, 4, 7, 0, 3, 6, 8] 




¬ª&gt; 







An important thing to note is that shuffle ( ) does not return a list value. Instead, it changes 
the list value that is passed to it (because shuffle ( ) modifies the list directly from the list 
reference value it is passed.) We say that the shuffle ( ) function modifies the list in-place. 
This is why we only need to execute random, shuffle ( spam) instead of spam = 
random. shuffle (spam) . 



Remember that you can use the list ( ) function to convert a string or range object to a list 
value. Type the following into the interactive shell: 



¬ª&gt; "import random 

¬ª&gt; eggs = listC'Hello') 

¬ª&gt; eggs 

[ 1 H 1 , 'e' , ' 1 1 , ' 1 ' , 'o'] 
¬ª&gt; random. shuffl e(eggs) 
¬ª&gt; eggs 
[‚ñ†o\ 'H' , ' 1 ' , '1', 'e'] 

¬ª&gt; 



Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 149 



And also remember you can use the j oin ( ) string method to pass a list of strings and return a 
single string: 



¬ª&gt; eggs 




['o\ 1 H 1 , 


' 1 1 , 'V , 'e'] 


¬ª&gt; eggs = 


' ' . join(eggs) 


¬ª&gt; eggs 




'oHlle' 




¬ª&gt; 





Randomly Scrambling a String 





t ransposi ti onTest . py 


15. 


# Convert the message string to a list to shuffle it. 


16. 


message = 1 i st(message) 


17. 


random . shuf f 1 e(message) 


18. 


message = '' .join (message) # convert list to string 



In order to shuffle the characters in a string value, first we convert the string to a list with 
list () , then shuffle the items in the list with shuffle ( ) , and then convert back to string 
value with the j oin ( ) string method. Try typing the following into the interactive shell: 



¬ª&gt; import random 

¬ª&gt; spam = 'Hello world!' 

¬ª&gt; spam = list(spam) 

¬ª&gt; random. shuff 1 e(spam) 

¬ª&gt; spam = ' ' .joi n(spam) 

¬ª&gt; spam 

'wl delHolorl ' 

¬ª&gt; 

We use this technique to scramble the letters in the message variable. This way we can test 
many different messages just in case our transposition cipher can encrypt and decrypt some 
messages but not others. 



Back to the Code 









t ransposi ti onTest . py 


20. 


print ('Test #%s: "%s. . . 


"' % (i+1, message [: 50])) 





Line 20 has a print ( ) call that displays which test number we are on (we add one to i because 
i starts at 0 and we want the test numbers to start at 1). Since the string in me s sage can be very 
long, we use string slicing to show only the first 50 characters of message. 



1 50 http://inventwithpython.com/hacking 



Line 20 uses string interpolation. The value that i+1 evaluates to will replace the first %s in the 
string and the value that message [ : 50 ] evaluates to will replace the second %s. When using 
string interpolation, be sure the number of % s in the string matches the number of values that are 
in between the parentheses after it. 







t ransposi ti onTest . py 


22. 


# Check all possible keys for each message. 




23. 


for key in range(l, 1 en (message) ) : 





While the key for the Caesar cipher could be an integer from 0 to 2 5, the key for the 
transposition cipher can be between 1 and the length of the message. We want to test every 
possible key for the test message, so the for loop on line 23 will run the test code with the keys 
1 up to (but not including) the length of the message. 







t ransposi ti onTest . py 


24. 


encrypted 


= transpos"it"ionEncrypt.encryptMessage(key, message) 


25. 


decrypted 


= transpos"it"ionDecrypt.decryptMessage(key, encrypted) 



Line 24 encrypts the string in message using our encryptMessage ( ) function. Since this 
function is inside the transpositionEncrypt.py file, we need to add transpositionEncrypt . 
(with the period at the end) to the front of the function name. 



The encrypted string that is returned from encryptMessage ( ) is then passed to 
decryptMes sage ( ) . We use the same key for both function calls. The return value from 
decryptMessage ( ) is stored in a variable named decrypted. If the functions worked, then 
the string in message should be the exact same as the string in decrypted. 



The sys .exit () Function 







t ransposi ti onTest . py 


27. 


# If the decryption doesn't match the original 


message, display 


28. 


# an error message and quit. 




29. 


if message != decrypted: 




30. 


print('Mismatch with key %s and message %s 


' % (key, 


message)) 






31. 


pri nt(decrypted) 




32. 


sys .exit () 




33. 






34. print('Transposition cipher test passed.') 





Email questions to the author: al@inventwithpython.com 



Chapter 10 - Programming a Program to Test Our Program 151 



Line 29 tests if message and decrypted are equal. If they aren't, we want to display an error 
message on the screen. We print the key, message, and decrypted values. This information 
could help us figure out what happened. Then we will exit the program. 

Normally our programs exit once the execution reaches the very bottom and there are no more 
lines to execute. However, we can make the program exit sooner than that by calling the 
sys . exit ( ) function. When sys . exit ( ) is called, the program will immediately end. 

But if the values in message and decrypted are equal to each other, the program execution 
skips the i f statement's block and the call to sys . exit ( ) . The next line is on line 34, but you 
can see from its indentation that it is the first line after line 9's for loop. 

This means that after line 29's if statement's block, the program execution will jump back to 
line 23 's for loop for the next iteration of that loop. If it has finished looping, then instead the 
execution jumps back to line 9's for loop for the next iteration of that loop. And if it has 
finished looping for that loop, then it continues on to line 34 to print out the string 

'Transposition cipher test passed.'. 







t ransposi ti onTest . py 


37. 


# If transpositionTest.py is 


run (instead of imported as a module) call 


38. 


# the main() function. 




39. 


if name == 1 main ': 




40. 


mainQ 





Here we do the trick of checking if the special variable name is set to ' main ' and if 

so, calling the main ( ) function. This way, if another program imports transpositionTest.py, the 
code inside main ( ) will not be executed but the def statements that create the main ( ) 
function will be. 



Testing Our Test Program 

We've written a test program that tests our encryption programs, but how do we know that the 
test program works? What if there is a bug with our test program, and it is just saying that our 
transposition cipher programs work when they really don't? 

We can test our test program by purposefully adding bugs to our encryption or decryption 
functions. Then when we run the test program, if it does not detect a problem with our cipher 
program, then we know that the test program is not correctly testing our cipher programs. 

Change transpositionEncrypt.py 's line 36 from this: 



t ransposi ti onEncrypt . py 



1 52 http://inventwithpython.com/hacking 



35. 


# move pointer over 




36. 


pointer += key 




...to this: 






transposi ti onEncrypt . py 


35. 


# move pointer over 




36. 


pointer += key + 1 





Now that the encryption code is broken, when we run the test program it should give us an error: 



Test #1: " JEQLDFKJZWALCOYACUPLTRRMLWHOBXQNEAWSLGWAGQQSRSIUIQ. . ." 
Mismatch with key 1 and message 

JEQLDFKJZWALCOYACUPLTRRMLWHOBXQNEAWSLGWACQQSRSIUIQTRGJHDVCZECRESZJARAVIPFOBWZXX 
TBFOFHVSIGBWIBBHGKUWHEUUDYONYTZVKNVVTYZPDDMIDKBHTYJAHBNDVJUZDCEMFMLUXEONCZXWAWG 
XZSFTMJNLJOKKIJXLWAPCQNYCIQOFTEAUHRJODKLGRIZSJBXQPBMQPPFGMVUZHKFWPGNMRYXROMSCEE 
XLUSCFHNELYPYKCNYTOUQGBFSRDDMVIGXNYPHVPQISTATKVKM. 

JQDKZACYCPTRLHBQEWLWGQRIITGHVZCEZAAIFBZXBOHSGWBHKWEUYNTVNVYPDIKHYABDJZCMMUENZWW 
XSTJLOKJLACNCQFEUROKGISBQBQPGVZKWGMYRMCELSFNLPKNTUGFRDVGNPVQSAKK 



Summary 

We can use our programming skills for more than just writing programs. We can also program 
the computer to test those programs to make sure they work for different inputs. It is a common 
practice to write code to test code. 

This chapter covered a few new functions such as the random . randint ( ) function for 
producing pseudorandom numbers. Remember, pseudorandom numbers aren't random enough 
for cryptography programs, but they are good enough for this chapter's testing program. The 
random . shuffle ( ) function is useful for scrambling the order of items in a list value. 

The copy . deepcopy ( ) function will create copies of list values instead of reference values. 
The difference between a list and list reference is explained in this chapter as well. 

All of our programs so far have only encrypted short messages. In the next chapter, we will learn 
how to encrypt and decrypt entire files on your hard drive. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 153 



Chapter 11 

Encrypting and Decrypting 
Files 



Topics Covered In This Chapter: 

‚Ä¢ Reading and writing files 

‚Ä¢ The open ( ) function 

‚Ä¢ The read ( ) file object method 

‚Ä¢ The close ( ) file object method 

‚Ä¢ The write ( ) file object method 

‚Ä¢ The os . path . exists ( ) function 

‚Ä¢ The startswith ( ) string method 

‚Ä¢ The title ( ) string method 

‚Ä¢ The time module and time . time ( ) function 



"Why do security police grab people and torture them? To get their 
information. If you build an information management system that 
concentrates information from dozens of people, you've made that 
dozens of times more attractive. You've focused the repressive regime's 
attention on the hard disk. And hard disks put up no resistance to torture. 
You need to give the hard disk a way to resist. That's cryptography." 



1 54 http://inventwithpython.com/hacking 



Patrick Ball 



Up until now our programs have only worked on small messages that we type directly into the 
source code as string values. The cipher program in this chapter will use the transposition cipher 
to encrypt and decrypt entire files, which can be millions of characters in size. 

Plain Text Files 

This program will encrypt and decrypt plain text files. These are the kind of files that only have 
text data and usually have the .txt file extension. Files from word processing programs that let 
you change the font, color, or size of the text do not produce plain text files. You can write your 
own text files using Notepad (on Windows), TextMate or TextEdit (on OS X), or gedit (on Linux) 
or a similar plain text editor program. You can even use IDLE's own file editor and save the files 
with a .txt extension instead of the usual .py extension. 

For some samples, you can download the following text files from this book's website: 

‚Ä¢ http;//mypy,comfdeyik 

‚Ä¢ http;//inypy^ 

‚Ä¢ http;//inypy,conVsid 

These are text files of some books (that are now in the public domain, so it is perfectly legal to 
download them.) For example, download Mary Shelley's classic novel "Frankenstein" from 
http://inypy,cq^ Double -click the file to open it in a text editor program. There 

are over 78,000 words in this text file! It would take some time to type this into our encryption 
program. But if it is in a file, the program can read the file and do the encryption in a couple 
seconds. 

If you get an error that looks like "UnicodeDecodeError : 'charmap' codec can't 
decode byte 0x90 in position 148: character maps to &lt;undefined&gt;" 
then you are running the cipher program on a non-plain text file, also called a "binary file". 

To find other public domain texts to download, go to the Project Gutenberg website at 
http://www.^utenberg,org/. 

Source Code of the Transposition File Cipher Program 

Like our transposition cipher testing program, the transposition cipher file program will import 
our transpositionEncrypt.py and transpositionDecrypt.py files so we can use the 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 155 



encryptMessage ( ) and decryptMessage ( ) functions in them. This way we don't have 
to re -type the code for these functions in our new program. 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as transpositionFileCipher.py . Press F5 to run the program. 
Note that first you will need to down\oadfrankenstein.txt and place this file in the same directory 
as the transpositionFileCipher.py file. You can download this file from 
http://inypy,co^ 



Source code for transpositionFileCipher.py 

1. # Transposition Cipher Encrypt/Decrypt File 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import time, os, sys, transpositionEncrypt, transpositionDecrypt 

5. 

6. def mainQ : 



7. i nputFi 1 ename = 'frankenstein.txt' 

8. # BE CAREFUL! If a file with the outputFi lename name already exists, 

9. # this program will overwrite that file. 

10. outputFi lename = 'frankenstein.encrypted.txt' 

11. myKey = 10 

12. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 
13. 

14. # If the input file does not exist, then the program terminates early. 

15. if not os. path. exists(inputFi lename) : 

16. print('The file %s does not exist. Quitting...' % (i nputFi 1 ename)) 

17. sys.exitO 
18. 

19. # If the output file already exists, give the user a chance to quit. 

20. if os. path. exists (outputFi 1 ename) : 

21. print('This will overwrite the file %s. (C)ontinue or (Q)uit?' % 
(outputFi lename)) 

22. response = input('&gt; ') 

23. if not response . 1 ower() . startswi th( ' c ') : 

24. sys.exitO 
25. 

26. # Read in the message from the input file 

27. fileObj = open(inputFilename) 

28. content = fileObj . read() 

29. fileObj .close() 
30. 

31. print('%sing. . . ' % (myMode. title())) 
32. 

33. # Measure how long the encryption/decryption takes. 

34. startTime = time.timeQ 



156 http://inventwithpython.com/hacking 



35. if myMode == 'encrypt': 

36. translated = transpositionEncrypt.encryptMessage(myKey, content) 

37. el if myMode == 'decrypt': 

38. translated = transpositionDecrypt.decryptMessage(myKey, content) 

39. totalTime = round (ti me . time () - startTime, 2) 

40. print('%sion time: %s seconds' % (myMode. ti ti e() , totalTime)) 
41. 

42. # Write out the translated message to the output file. 

43. outputFileObj = open(outputFilename, 'w') 

44. outputFileObj . wri te(transl ated) 

45. outputFileObj .close() 
46. 

47. print('Done %sing %s (%s characters).' % (myMode, i nputFi 1 ename , 
len(content))) 

48. print('%sed file is %s.' % (myMode . ti tl e() , outputFi 1 ename)) 
49. 

50. 

51. # If transpositionCipherFile.py is run (instead of imported as a module) 

52. # call the main() function. 

53. if name == ' main ': 

54. main() 

In the directory thatfrankenstein.txt and transpositionFileCipher.py files are in, there will be a 
new file named frankenstein.encrypted.txt that contains the content offrankenstein.txt in 
encrypted form. If you double-click the file to open it, it should look something like this: 



PtFiyedleo a arnvmt eneeCLchongnes Mmuyedl suO#ui SHTGA r sy,n t ys 
s nuaoGeL 
sc7s , 

(the rest has been cut out for brevity) 

To decrypt, make the following changes to the source code (written in bold) and run the 
transposition cipher program again: 



transposi ti onFi 1 eCi pher . py 

7. inputFilename = 'frankenstein.encrypted.txt' 

8. # BE CAREFUL! If a file with the outputFi 1 ename name already exists, 

9. # this program will overwrite that file. 

10. outputFi 1 ename = 'frankenstein.decrypted.txt' 

11. myKey = 10 

12. myMode = 'decrypt' # set to 'encrypt' or 'decrypt' 

This time when you run the program a new file will appear in the folder named 
frankenstein.decrypted.txt that is identical to the original frankenstein.txt file. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 157 



Sample Run of the Transposition File Cipher Program 

When you run the above program, it produces this output: 



Encrypti ng . . . 




Encryption time: 1.21 seconds 




Done encrypting frankenstein.txt (441034 


characters) . 


Encrypted file is frankenstei n . encrypted 


txt. 



A new frankenstein.encrypted.txt file will have been created in the same directory as 
transpositionFileCipher.py. If you open this file with IDLE's file editor, you will see the 
encrypted contents of frankenstein.py . You can now email this encrypted file to someone for them 
to decrypt. 



Reading From Files 

Up until now, any input we want to give our programs would have to be typed in by the user. 
Python programs can open and read files directly off of the hard drive. There are three steps to 
reading the contents of a file: opening the file, reading into a variable, and then closing the file. 

The open () Function and File Objects 

The open ( ) function's first parameter is a string for the name of the file to open. If the file is in 
the same directory as the Python program then you can just type in the name, such as 
' thetimemachine . txt ' . You can always specify the absolute path of the file, which 
includes the directory that it is in. For example, ' c : \\Python32\\f rankenstein . txt ' 
(on Windows) and ' /usr/f oobar/f rankenstein . txt ' (on OS X and Linux) are 
absolute filenames. (Remember that the \ backslash must be escaped with another backslash 
before it.) 

The open ( ) function returns a value of the "file object" data type. This value has several 
methods for reading from, writing to, and closing the file. 

The read ( ) File Object Method 

The read ( ) method will return a string containing all the text in the file. For example, say the 
file spam.txt contained the text "Hello world!". (You can create this file yourself using IDLE's 
file editor. Just save the file with a .txt extension.) Run the following from the interactive shell 
(this codes assumes you are running Windows and the spam.txt file is in the c:\ directory): 



¬ª&gt; fo = open ('c:\\spam. txt' , 'r') 
¬ª&gt; content = fo.readO 
¬ª&gt; pri nt(content) 



158 http://inventwithpython.com/hacking 



Hello world! 

¬ª&gt; 



If your text file has multiple lines, the string returned by read ( ) will have \n newline 
characters in it at the end of each line. When you try to print a string with newline characters, the 
string will print across several lines: 



¬ª&gt; print('Hello\nworld! ') 

Hello 

world ! 

¬ª&gt; 

If you get an error message that says "IOError : [Errno 2] No such file or 
directory" then double check that you typed the filename (and if it is an absolute path, the 
directory name) correctly. Also make sure that the file actually is where you think it is. 

The close () File Object Method 

After you have read the file's contents into a variable, you can tell Python that you are done with 
the file by calling the close ( ) method on the file object. 



¬ª&gt; fo.closeO 

¬ª&gt; 

Python will automatically close any open files when the program terminates. But when you want 
to re-read the contents of a file, you must close the file object and then call the open ( ) function 
on the file again. 



Here's the code in our transposition cipher program that reads the file whose filename is stored in 
the inputFilename variable: 







transposi tionFi 1 eCi pher . py 


26. 


# Read in the message from the input file 




27. 


fileObj = open(inputFilename) 




28. 


content = fileObj . readO 




29. 


fileObj .close Q 





Writing To Files 

We read the original file and now will write the encrypted (or decrypted) form to a different file. 
The file object returned by open ( ) has a write ( ) function, although you can only use this 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 159 



function if you open the file in "write" mode instead of "read" mode. You do this by passing the 
string value ' w ' as the second parameter. For example: 



¬ª&gt; fo = openCf-Mename.txt 1 , 'w') 

¬ª&gt; 

Along with "read" and "write", there is also an "append" mode. The "append" is like "write" 
mode, except any strings written to the file will be appended to the end of any content that is 
already in the file. "Append" mode will not overwrite the file if it already exists. To open a file in 
append mode, pass the string ' a ' as the second argument to open ( ) . 

(Just in case you were curious, you could pass the string ' r ' to open ( ) to open the file in read 
mode. But since passing no second argument at all also opens the file in read mode, there's no 
reason to pass ' r ' .) 

The write ( ) File Object Method 

You can write text to a file by calling the file object's write ( ) method. The file object must 
have been opened in write mode, otherwise, you will get a "io . UnsupportedOperation : 
not readable" error message. (And if you try to call read ( ) on a file object that was 
opened in write mode, you will get a "io . UnsupportedOperation : not readable" 
error message.) 

The write ( ) method takes one argument: a string of text that is to be written to the file. Lines 
43 to 45 open a file in write mode, write to the file, and then close the file object. 



transposi ti onFi 1 eCi pher . py 

42. # Write out the translated message to the output file. 

43. outputFileObj = open(outputFilename, 'w') 

44. outputFileObj . wri te(transl ated) 

45. outputFileObj .closeO 

Now that we have the basics of reading and writing files, let's look at the source code to the 
transposition file cipher program. 

How the Program Works 

transposi ti onFi 1 eCi pher . py 

1. # Transposition Cipher Encrypt/Decrypt File 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import time, os, sys, transpositionEncrypt, transpositionDecrypt 

5. 



1 60 http://inventwithpython.com/hacking 



6. def mainO : 

7. i nputFi 1 ename = 'frankenstein.txt' 

8. # BE CAREFUL! If a file with the outputFil ename name already exists, 

9. # this program will overwrite that file. 

10. outputFil ename = 'frankenstein.encrypted.txt' 

11. myKey = 10 

12. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 

The first part of the program should look familiar. Line 4 is an import statement for our 
transpositionEncrypt.py and transpositionDecrypt.py programs. It also imports the Python's 
time, os, and sys modules. 

The main ( ) function will be called after the def statements have been executed to define all 
the functions in the program. The inputFilename variable holds a string of the file to read, 
and the encrypted (or decrypted) text is written to the file with the name in outputFilename. 

The transposition cipher uses an integer for a key, stored in myKey. If ' encrypt ' is stored in 
myMode, the program will encrypt the contents of the inputFilename file. If ' decrypt ' is 
stored in myMode, the contents of inputFilename will be decrypted. 

The os .path. exists () Function 

Reading files is always harmless, but we need to be careful when writing files. If we call the 
open ( ) function in write mode with a filename that already exists, that file will first be deleted 
to make way for the new file. This means we could accidentally erase an important file if we pass 
the important file's name to the open ( ) function. Using the os . path . exists ( ) function, 
we can check if a file with a certain filename already exists. 

The os . path . exists ( ) file has a single string parameter for the filename, and returns True 
if this file already exists and Fal se if it doesn't. The o s . path .exists ( ) function exists 
inside the path module, which itself exists inside the os module. But if we import the os 
module, the path module will be imported too. 

Try typing the following into the interactive shell: 



¬ª&gt; import os 

¬ª&gt; os.path.exists('abcdef ') 
False 

¬ª&gt; os . path . exi sts ( ' C : \\Wi ndows\\System32\\cal c . exe ' ) 
True 

&gt;¬ª 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 161 



(Of course, you will only get the above results if you are running Python on Windows. The 
calc.exe file does not exist on OS X or Linux.) 







transposi ti onFi 1 eCi pher . py 


14. 


# If the input 


file does not exist, then the program terminates early. 


15. 


if not os. path 


exi sts (i nputFi 1 ename) : 


16. 


pri nt( 'The 


file %s does not exist. Quitting...' % (i nputFi 1 ename)) 


17. 


sys.exitQ 





We use the os . path . exists ( ) function to check that the filename in inputFilename 
actually exists. Otherwise, we have no file to encrypt or decrypt. In that case, we display a 
message to the user and then quit the program. 



The startswith ( ) and endswith ( ) String Methods 



transposi ti onFi 1 eCi pher . py 

19. # If the output file already exists, give the user a chance to quit. 

20. if os. path. exi sts (outputFil ename) : 

21. print('This will overwrite the file %s. (C)ontinue or (Q)uit? 1 % 
(outputFil ename)) 

22. response = input('&gt; ') 

23. if not response . 1 ower() . startswi th( ' c ') : 

24. sys.exitQ 



If the file the program will write to already exists, the user is asked to type in "C" if they want to 
continue running the program or "Q" to quit the program. 

The string in the response variable will have lower ( ) called on it, and the returned string from 
lower ( ) will have the string method startswith ( ) called on it. The startswith ( ) 
method will return True if its string argument can be found at the beginning of the string. Try 
typing the following into the interactive shell: 



¬ª&gt; 'hello' . startswi th('h') 
True 

&gt;¬ª 'hello world! 1 .startswithC'hello wo') 
True 

¬ª&gt; 'hello'. startswi th('H') 
False 

¬ª&gt; spam = 'Albert' 

¬ª&gt; spam.startswithC'Al ') 

True 



1 62 http://inventwithpython.com/hacking 



¬ª&gt; 



On line 23, if the user did not type in ' c ' , 'continue', 'C',or another string that begins 
with C, then sys . exit ( ) will be called to end the program. Technically, the user doesn't have 
to enter "Q" to quit; any string that does not begin with "C" will cause the sys.exit() function to 
be called to quit the program. 



There is also an ends with ( ) string method that can be used to check if a string value ends with 
another certain string value. Try typing the following into the interactive shell: 



¬ª&gt; 1 Hello world ! 


' .endswith('world! ') 


True 




¬ª&gt; 'Hello world! ' 


. endswi th( 'world ' ) 


False 




¬ª&gt; 





The title () String Method 

Just like the lower ( ) and upper ( ) string methods will return a string in lowercase or 
uppercase, the title ( ) string method returns a string in "title case". Title case is where every 
word is uppercase for the first character and lowercase for the rest of the characters. Try typing 
the following into the interactive shell: 



¬ª&gt; 'hello' .titleO 
'Hello' 

¬ª&gt; 'HELLO' .titleO 
'Hello' 

¬ª&gt; 'hElLo' .titleO 
'Hello' 

¬ª&gt; 'hello world! HOW ARE YOU? ' .titleO 
'Hello World! How Are You?' 
¬ª&gt; 'extra! extra! man bites shark! ' .titleO 
'Extra! Extra! Man Bites Shark!' 

¬ª&gt; 







transposi tionFi 1 eCi pher . py 


26. 


# Read in the message from the input file 




27. 


fileObj = open(inputFilename) 




28. 


content = fileObj . readO 




29. 


fileObj .close O 




30. 






31. 


print('%sing. . . ' % (myMode. titleO)) 





Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 163 



Lines 27 to 29 open the file with the name stored in input Filename and read in its contents 
into the content variable. On line 31, we display a message telling the user that the encryption 
or decryption has begun. Since myMode should either contain the string ' encrypt ' or 
' decrypt ' , calling the title ( ) string method will either display ' Encrypting . . . ' or 
' Decrypting . . . ' . 

The time Module and time . time ( ) Function 

All computers have a clock that keeps track of the current date and time. Your Python programs 
can access this clock by calling the time . time ( ) function. (This is a function named time ( ) 
that is in a module named time.) 

The time . time ( ) function will return a float value of the number of seconds since January 1 st , 
1970. This moment is called the Unix Epoch. Try typing the following into the interactive shell: 



¬ª&gt; "import time 
¬ª&gt; time.timeO 
1349411356.892 
¬ª&gt; time.timeO 
1349411359.326 
¬ª&gt; 

The float value shows that the time . time ( ) function can be precise down to a millisecond 
(that is, 1/1,000 of a second). Of course, the numbers that time . time ( ) displays for you will 
depend on the moment in time that you call this function. It might not be clear that 
1349411356.892 is Thursday, October 4 th , 2012 around 9:30 pm. However, the time .time ( ) 
function is useful for comparing the number of seconds between calls to time . time ( ) . We can 
use this function to determine how long our program has been running. 





transposi ti onFi 1 eCi pher . py 


33. 


# Measure how long the encryption/decryption takes. 


34. 


startTime = time.timeO 


35. 


if myMode == 'encrypt': 


36. 


translated = transpositionEncrypt.encryptMessage(myKey, content) 


37. 


el if myMode == 'decrypt': 


38. 


translated = transpositionDecrypt.decryptMessage(myKey, content) 


39. 


totalTime = round (time.timeO - startTime, 2) 


40. 


print('%sion time: %s seconds' % (myMode. ti tl e() , totalTime)) 



We want to measure how long the encryption or decryption process takes for the contents of the 
file. Lines 35 to 38 call the encryptMessage ( ) or decryptMessage ( ) (depending on 
whether ' encrypt ' or ' decrypt ' is stored in the myMode variable). Before this code 



1 64 http://inventwithpython.com/hacking 

however, we will call time .time ( ) and store the current time in a variable named 

startTime. 

On line 39 after the encryption or decryption function calls have returned, we will call 

time .time ( ) again and subtract startTime from it. This will give us the number of seconds 

between the two calls to time . time ( ) . 

For example, if you subtract the floating point values returned when I called time .time ( ) 
before in the interactive shell, you would get the amount of time in between those calls while I 
was typing: 



¬ª&gt; 1349411359.326 - 1349411356.892 
2.434000015258789 

¬ª&gt; 



(The difference Python calculated between the two floating point values is not precise due to 
rounding errors, which cause very slight inaccuracies when doing math with floats. For our 
programs, it will not matter. But you can read more about rounding errors at 
h^://inypy.com/roMdin5.) 

The time .time ( ) - startTime expression evaluates to a value that is passed to the 
round ( ) function which rounds to the nearest two decimal points. This value is stored in 
totalTime. On line 40, the amount of time is displayed to the user by calling print ( ) . 

Back to the Code 

transpositionFiieCipher.py 

42. # Write out the translated message to the output file. 

43. outputFileObj = open(outputFilename, 'w') 

44. outputFileObj . wri te(transl ated) 

45. outputFileObj .close() 

The encrypted (or decrypted) file contents are now stored in the translated variable. But this 
string will be forgotten when the program terminates, so we want to write the string out to a file 
to store it on the hard drive. The code on lines 43 to 45 do this by opening a new file (passing 
' w ' to open ( ) to open the file in write mode) and then calling the write ( ) file object 
method. 



transposi tionFii eCi pher . py 

47. print('Done %sing %s (%s characters).' % (myMode, i nputFi 1 ename , 
len(content))) 

48. print('%sed file is %s.' % (myMode . ti tl e() , outputFi 1 ename)) 



Email questions to the author: al@inventwithpython.com 



Chapter 1 1 - Encrypting and Decrypting Files 165 



49. 
50. 

51. # If transpositionCipherFile.py is run (instead of imported as a module) 

52. # call the main() function. 

53. if name == 1 main ': 

54. main() 

Afterwards, we print some more messages to the user telling them that the process is done and 
what the name of the written file is. Line 48 is the last line of the main ( ) function. 

Lines 53 and 54 (which get executed after the def statement on line 6 is executed) will call the 
main ( ) function if this program is being run instead of being imported. (This is explained in 
Chapter 8's "The Special name Variable" section.) 

Practice Exercises, Chapter 11, Set A 

Practice exercises can be found at http://inypy^ 

Summary 

Congratulations! There wasn't much to this new program aside from the open (), write () , 
read () , and close ( ) functions, but this lets us encrypt text files on our hard drive that are 
megabytes or gigabytes in size. It doesn't take much new code because all of the implementation 
for the cipher has already been written. We can extend our programs (such as adding file reading 
and writing capabilities) by importing their functions for use in new programs. This greatly 
increases our ability to use computers to encrypt information. 

There are too many possible keys to simply brute-force and examine the output of a message 
encrypted with the transposition cipher. But if we can write a program that recognizes English (as 
opposed to strings of gibberish), we can have the computer examine the output of thousands of 
decryption attempts and determine which key can successfully decrypt a message to English. 



1 66 http://inventwithpython.com/hacking 




Chapter 12 



Detecting English 
Programmatically 

Topics Covered In This Chapter: 

‚Ä¢ Dictionaries 

‚Ä¢ The split () Method 

‚Ä¢ The None Value 

‚Ä¢ "Divide by Zero" Errors 

‚Ä¢ The float ( ) , int ( ) , and str ( ) Functions and Python 2 Division 

‚Ä¢ The append ( ) List Method 

‚Ä¢ Default Arguments 

‚Ä¢ Calculating Percentage 



The gaffer says something longer and more 
complicated. After a while, Waterhouse (now 
wearing his cryptoanalyst hat, searching for 
meaning midst apparent randomness, his neural 
circuits exploiting the redundancies in the signal) 
realizes that the man is speaking heavily accented 
English. 

"Cryptonomicon" by Neal Stephenson 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 167 



A message encrypted with the transposition cipher can have thousands of possible keys. Your 
computer can still easily brute -force this many keys, but you would then have to look through 
thousands of decryptions to find the one correct plaintext. This is a big problem for the brute- 
force method of cracking the transposition cipher. 

When the computer decrypts a message with the wrong key, the resulting plaintext is garbage 
text. We need to program the computer to be able to recognize if the plaintext is garbage text or 
English text. That way, if the computer decrypts with the wrong key, it knows to go on and try the 
next possible key. And when the computer tries a key that decrypts to English text, it can stop and 
bring that key to the attention of the cryptanalyst. Now the cryptanalyst won't have to look 
through thousands of incorrect decryptions. 

How Can a Computer Understand English? 

It can't. At least, not in the way that human beings like you or I understand English. Computers 
don't really understand math, chess, or lethal military androids either, any more than a clock 
understands lunchtime. Computers just execute instructions one after another. But these 
instructions can mimic very complicated behaviors that solve math problems, win at chess, or 
hunt down the future leaders of the human resistance. 

Ideally, what we need is a Python function (let's call it i sEngli sh ( ) ) that has a string passed 
to it and then returns True if the string is English text and False if it's random gibberish. Let's 
take a look at some English text and some garbage text and try to see what patterns the two have: 



Robots are your friends. Except for RX-686. She will try to eat you. 

ai-pey e. xrx ne augur iirl6 Rtiyt fhubE6d hrSei t8..ow eo.telyoosEs t 

One thing we can notice is that the English text is made up of words that you could find in a 
dictionary, but the garbage text is made up of words that you won't. Splitting up the string into 
individual words is easy. There is already a Python string method named split ( ) that will do 
this for us (this method will be explained later). The split ( ) method just sees when each word 
begins or ends by looking for the space characters. Once we have the individual words, we can 
test to see if each word is a word in the dictionary with code like this: 



"if word == 'aardvark' or word == 'abacus' or word == 'abandon' or word == 
'abandoned' or word == 'abbreviate' or word == 'abbreviation' or word == 
'abdomen' or ... 



We can write code like that, but we probably shouldn't. The computer won't mind running 
through all this code, but you wouldn't want to type it all out. Besides, somebody else has already 



1 68 http://inventwithpython.com/hacking 

typed out a text file full of nearly all English words. These text files are called dictionary files. 
So we just need to write a function that checks if the words in the string exist somewhere in that 
file. 

Remember, a dictionary file is a text file that contains a large list of English words. A dictionary 
value is a Python value that has key-value pairs. 

Not every word will exist in our "dictionary file". Maybe the dictionary file is incomplete and 
doesn't have the word, say, "aardvark". There are also perfectly good decryptions that might have 
non-English words in them, such as "RX-686" in our above English sentence. (Or maybe the 
plaintext is in a different language besides English. But we'll just assume it is in English for 
now.) 

And garbage text might just happen to have an English word or two in it by coincidence. For 
example, it turns out the word "augur" means a person who tries to predict the future by studying 
the way birds are flying. Seriously. 

So our function will not be foolproof. But if most of the words in the string argument are English 
words, it is a good bet to say that the string is English text. It is a very low probability that a 
ciphertext will decrypt to English if decrypted with the wrong key. 

The dictionary text file will have one word per line in uppercase. It will look like this: 



AARHUS 

AARON 

ABABA 

ABACK 

ABAFT 

ABANDON 

ABANDONED 

ABANDONING 

ABANDONMENT 

ABANDONS 



. . .and so on. You can download this entire file (which has over 45,000 words) from 
http://inYpy-c^ 

Our isEnglish() function will have to split up a decrypted string into words, check if each 
word is in a file full of thousands of English words, and if a certain amount of the words are 
English words, then we will say that the text is in English. And if the text is in English, then 
there's a good bet that we have decrypted the ciphertext with the correct key. 

And that is how the computer can understand if a string is English or if it is gibberish. 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 169 



Practice Exercises, Chapter 12, Section A 

Practice exercises can be found at ht^://invpxAQr^^J^^ra^cel2A. 

The Detect English Module 

The detectEnglish.py program that we write in this chapter isn't a program that runs by itself. 
Instead, it will be imported by our encryption programs so that they can call the 
detectEnglish . isEnglish ( ) function. This is why we don't give detectEnglish.py a 
main ( ) function. The other functions in the program are all provided for isEnglish ( ) to 
call. 

Source Code for the Detect English Module 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as detectEnglish.py. Press F5 to run the program. 



Source code for detectEnglish.py 

1. # Detect English module 

2. # http://inventwithpython.com/hacklng (BSD Licensed) 
3. 

4. # To use, type this code: 

5. # import detectEnglish 

6. # detectEngl i sh . i sEngl i sh(someStri ng) # returns True or False 

7. # (There must be a "dictionary.txt" file in this directory with all English 

8. # words in it, one word per line. You can download this from 

9. # http://invpy.com/dictionary.txt) 

10. UPPERLETTERS = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

11. L ETTE RS_AN D_S PAC E = UPPERLETTERS + UPPERLETTERS . lowerO + ' \t\n ' 
12. 

13. def loadDictionaryO : 

14. dictionaryFile = open ('dictionary.txt') 

15. englishWords = {} 

16. for word in dictionaryFile. read() .split('\n') : 

17. engl i shWords [word] = None 

18. dictionaryFile. close() 

19. return englishWords 

20. 

21. ENGLISH_WORDS = loadDictionaryO 

22. 

23. 

24. def getEngl i shCount (message) : 

25. message = message . upper() 

26. message = removeNonLetters (message) 

27. possibleWords = message. splitQ 



170 http://inventwithpython.com/hacking 



28. 

29. if possiblewords == [] : 

30. return 0.0 # no words at all, so return 0.0 
31. 

32. matches = 0 

33. for word in possi bl eWords : 

34. if word in ENGLISH_W0RDS: 

35. matches += 1 

36. return float (matches) / len(possibleWords) 
37. 

38. 

39. def removeNonLetters(message) : 

40. lettersOnly = [] 

41. for symbol in message: 

42. if symbol in LETTERS_AND_SPACE : 

43. lettersOnly. append (symbol) 

44. return 1 ' . join(lettersOnly) 
45. 

46. 

47. def isEng"lish(message, wordPercentage=20 , 1 etterPercentage=85) : 

48. # By default, 20% of the words must exist in the dictionary file, and 

49. # 85% of all the characters in the message must be letters or spaces 

50. # (not punctuation or numbers). 

51. wordsMatch = getEngl i shCount(message) * 100 &gt;= wordPercentage 

52. numLetters = 1 en(removeNonLetters(message)) 

53. messageLettersPercentage = float (numLetters) / len(message) * 100 

54. lettersMatch = messageLettersPercentage &gt;= 1 etterPercentage 

55. return wordsMatch and lettersMatch 



How the Program Works 

detectEngl i sh . py 

1. # Detect English module 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. # To use, type this code: 

5. # import detectEngl i sh 

6. # detectEngl i sh . i sEngl i sh(someStri ng) # returns True or False 

7. # (There must be a "dictionary.txt" file in this directory with all English 

8. # words in it, one word per line. You can download this from 

9. # http://invpy.com/dictionary.txt) 

These comments at the top of the file give instructions to programmers on how to use this 
module. They give the important reminder that if there is no file named dictionary.txt in the same 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 171 



directory as detectEnglish.py then this module will not work. If the user doesn't have this file, the 
comments tell them they can download it from http://inypy .conVdictionary .txt. 







detectEngl i sh . py 


10. 


UPPERLETTERS = ' ABCDEFGHI JKLMNOPQRSTUVWXYZ 1 




11. 


L ETTE RS_AN D_S PAC E = UPPERLETTERS + UPPERLETTERS . lower Q + 


\t\n' 



Lines 10 and 1 1 set up a few variables that are constants, which is why they have uppercase 
names. UPPERLETTERS is a variable containing the 26 uppercase letters, and 
LETTERS_AND_SPACE contain these letters (and the lowercase letters returned from 
UPPERLETTERS . lower ( ) ) but also the space character, the tab character, and the newline 
character. The tab and newline characters are represented with escape characters \t and \n. 





detectEngl i sh . py 


13. def loadDictionaryO : 




14. dictionaryFile = openCdictionary.txt') 





The dictionary file sits on the user's hard drive, but we need to load the text in this file as a string 
value so our Python code can use it. First, we get a file object by calling open ( ) and passing the 
string of the filename ' dictionary . txt ' . Before we continue with the 
loadDictionary ( ) code, let's learn about the dictionary data type. 



Dictionaries and the Dictionary Data Type 

The dictionary data type has values which can contain multiple other values, just like lists do. In 
list values, you use an integer index value to retrieve items in the list, like spam [ 42 ] . For each 
item in the dictionary value, there is a key used to retrieve it. (Values stored inside lists and 
dictionaries are also sometimes called items.) The key can be an integer or a string value, like 
spam [' hello ' ] or spam [ 42 ] . Dictionaries let us organize our program's data with even 
more flexibility than lists. 

Instead of typing square brackets like list values, dictionary values (or simply, dictionaries) use 
curly braces. Try typing the following into the interactive shell: 



¬ª&gt; emptyList = [] 

¬ª&gt; emptyDictionary = {} 

¬ª&gt; 



A dictionary's values are typed out as key- value pairs, which are separated by colons. Multiple 
key-value pairs are separated by commas. To retrieve values from a dictionary, just use square 



172 http://inventwithpython.com/hacking 

brackets with the key in between them (just like indexing with lists). Try typing the following 
into the interactive shell: 



¬ª&gt; spam = { ' keyT : 'Thi s is a value', 'key2':42} 

¬ª&gt; spam ['keyT] 

'This is a value' 

¬ª&gt; spam['key2'] 

42 

¬ª&gt; 



It is important to know that, just as with lists, variables do not store dictionary values themselves, 
but references to dictionaries. The example code below has two variables with references to the 
same dictionary: 



¬ª&gt; spam = {'hello' 


42} 


¬ª&gt; eggs = spam 




&gt;¬ª eggs['hello'] = 


99 


¬ª&gt; eggs 




{'hello': 99} 




¬ª&gt; spam 




{'hello': 99} 




¬ª&gt; 





Adding or Changing Items in a Dictionary 

You can add or change values in a dictionary with indexes as well. Try typing the following into 
the interactive shell: 



¬ª&gt; spam = {42: 'hello'} 
¬ª&gt; print(spam[42]) 
hello 

¬ª&gt; spam [42] = 'goodbye' 
¬ª&gt; print(spam[42]) 
goodbye 

¬ª&gt; 



And just like lists can contain other lists, dictionaries can also contain other dictionaries (or lists). 
Try typing the following into the interactive shell: 



¬ª&gt; foo = {'fizz' : {'name': 'AT, 'age': 144}, 'moo':['a', 


'brown ' , 


'cow']} 


&gt;¬ª foo['fizz'] 






{'age' : 144, 'name' : 'AT} 






&gt;¬ª foo [ ' f i zz ' ] [ ' name ' ] 







Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 173 



'Al ' 

¬ª&gt; f oo ['moo'] 
['a', 'brown', 'cow'] 
¬ª&gt; foo['moo'] [1] 
'brown ' 

¬ª&gt; 



Practice Exercises, Chapter 12, Set B 

Practice exercises can be found at ht^://inypxAQn^^J^^ra^cel2B. 

Using the len ( ) Function with Dictionaries 

The len ( ) function can tell you how many items are in a list or how many characters are in a 
string, but it can also tell you how many items are in a dictionary as well. Try typing the 
following into the interactive shell: 



¬ª&gt; spam = {} 
¬ª&gt; len (spam) 
0 

¬ª&gt; spam [' name' ] 
¬ª&gt; spam['pet'] 
&gt;¬ª spam ['age'] 
¬ª&gt; len (spam) 
3 

¬ª&gt; 



Using the in Operator with Dictionaries 

The in operator can also be used to see if a certain key value exists in a dictionary. It is important 
to remember that the i n operator checks if a key exists in the dictionary, not a value. Try typing 
the following into the interactive shell: 



¬ª&gt; eggs = {'foo': 'milk', 'bar': 'bread'} 

¬ª&gt; 'foo' in eggs 

True 

¬ª&gt; 'blah blah blah' in eggs 
Fal se 

¬ª&gt; 'milk' in eggs 
False 

¬ª&gt; 'bar' in eggs 
True 

¬ª&gt; 'bread' in eggs 
False 



= 'Al ' 
= 'Zophie the cat' 
= 89 



174 http://inventwithpython.com/hacking 



¬ª&gt; 



The not in operator works with dictionary values as well. 

Using for Loops with Dictionaries 

You can also iterate over the keys in a dictionary with for loops, just like you can iterate over 
the items in a list. Try typing the following into the interactive shell: 



¬ª&gt; spam = { 1 name 1 : 1 Al ' , 'age': 99} 
&gt;¬ª for k in spam: 

print(k) 

print(spam[k]) 

print ('==========') 

age 
99 



name 
Al 



¬ª&gt; 



Practice Exercises, Chapter 12, Set C 

Practice exercises can be found at ht^://invpx^Qr^^J^^ra(^cel2C. 

The Difference Between Dictionaries and Lists 

Dictionaries are like lists in many ways, but there are a few important differences: 

1 . Dictionary items are not in any order. There is no "first" or "last" item in a dictionary like 
there is in a list. 

2. Dictionaries do not have concatenation with the + operator. If you want to add a new 
item, you can just use indexing with a new key. For example, foo [' a new key'] = 
'a string' 

3. Lists only have integer index values that range from 0 to the length of the list minus one. 
But dictionaries can have any key. If you have a dictionary stored in a variable spam, 
then you can store a value in spam [ 3 ] without needing values for spam [ 0 ] , 

spam [ 1 ] , or spam [ 2 ] first. 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 175 



Finding Items is Faster with Dictionaries Than Lists 







detectEngl i sh . py 


15. 


engl i shWords = {} 





In the loadDictionary ( ) function, we will store all the words in the "dictionary file" (as in, 
a file that has all the words in an English dictionary book) in a dictionary value (as in, the Python 
data type.) The similar names are unfortunate, but they are two completely different things. 



We could have also used a list to store the string values of each word from the dictionary file. The 
reason we use a dictionary is because the in operator works faster on dictionaries than lists. 
Imagine that we had the following list and dictionary values: 



&gt;¬ª listVal = ['spam', 'eggs', 'bacon'] 

¬ª&gt; dictionaryVal = {'spam':0, 'eggs' :0, 'bacon' :0} 

Python can evaluate the expression ' bacon ' in dictionaryVal a little bit faster than 
'bacon' in listVal. The reason is technical and you don't need to know it for the 
purposes of this book (but you can read more about it at h^A//iQypy-Cpn^stys^ct). This faster 
speed doesn't make that much of a difference for lists and dictionaries with only a few items in 
them like in the above example. But our detectEnglish module will have tens of thousands 
of items, and the expression word in ENGLI SH_WORDS will be evaluated many times when 
the isEnglish ( ) function is called. The speed difference really adds up for the 
detectEnglish module. 

The split () Method 

The split () string method returns a list of several strings. The "split" between each string 
occurs wherever a space is. For an example of how the split ( ) string method works, try typing 
this into the shell: 



¬ª&gt; 'My 


very energetic mother just served us Nutella. 


'.splitO 


['My', 


very', 'energetic', 'mother', 'just', 'served', 


'us', 'Nutella.'] 


¬ª&gt; 







The result is a list of eight strings, one string for each of the words in the original string. The 
spaces are dropped from the items in the list (even if there is more than one space). You can pass 
an optional argument to the split ( ) method to tell it to split on a different string other than just 
a space. Try typing the following into the interactive shell: 



¬ª&gt; 'helloXXXworldXXXhowXXXareXXyou?' .split('XXX') 



176 http://inventwithpython.com/hacking 



['hello', 'world', 'how', 'areXXyou?'] 

¬ª&gt; 







detectEngl i sh . py 


16. 


for word in dictionaryFile. readQ .split('\n') : 





Line 16 is a for loop that will set the word variable to each value in the list 
dictionaryFile . read ( ) . split ( ' \n ' ) . Let's break this expression down. 
dictionaryFile is the variable that stores the file object of the opened file. The 
dictionaryFile . read ( ) method call will read the entire file and return it as a very large 
string value. On this string, we will call the split ( ) method and split on newline characters. 
This split () call will return a list value made up of each word in the dictionary file (because 
the dictionary file has one word per line.) 

This is why the expression dictionaryFile . read ( ) . split ( ' \n ' ) will evaluate to a 
list of string values. Since the dictionary text file has one word on each line, the strings in the list 
that split () returns will each have one word. 

The None Value 

None is a special value that you can assign to a variable. The None value represents the lack of 
a value. None is the only value of the data type NoneType. (Just like how the Boolean data type 
has only two values, the NoneType data type has only one value, None.) It can be very useful to 
use the None value when you need a value that means "does not exist". The None value is 
always written without quotes and with a capital "N" and lowercase "one". 

For example, say you had a variable named qui zAnswer which holds the user's answer to some 
True -False pop quiz question. You could set quizAnswer to None if the user skipped the 
question and did not answer it. Using None would be better because if you set it to True or 
False before assigning the value of the user's answer, it may look like the user gave an answer 
for the question even though they didn't. 

Calls to functions that do not return anything (that is, they exit by reaching the end of the function 
and not from a return statement) will evaluate to None. 



detectEngl ish.py 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 177 



17. engl i shWords [word] = None 

In our program, we only use a dictionary for the engli shWords variable so that the in 
operator can find keys in it. We don't care what is stored for each key, so we will just use the 
None value. The for loop that starts on line 16 will iterate over each word in the dictionary file, 
and line 17 will use that word as a key in engli shWords with None stored for that key. 

Back to the Code 







detectEngl i sh . py 


18. 


di cti onaryFi 1 e . cl ose() 




19. 


return engl 1 shWords 





After the for loop finishes, the englishWords dictionary will have tens of thousands of keys 
in it. At this point, we close the file object since we are done reading from it and then return 

englishWords. 



detectEngl i sh . py 

21. ENGLISH_WORDS = 1 oadDi cti onary () 

Line 21 calls loadDictionaryO and stores the dictionary value it returns in a variable 
named ENGLI SH_WORDS. We want to call loadDictionary ( ) before the rest of the code in 
the detectEnglish module, but Python has to execute the def statement for 
loadDictionary ( ) before we can call the function. This is why the assignment for 
ENGLISH_WORDS comes after the loadDictionary ( ) function's code. 







detectEngl i sh . py 


24. 


def getEngli shCount(message) : 




25. 


message = message . upper () 




26. 


message = removeNonLetters (message) 




27. 


possibleWords = message. splitQ 





The getEngli shCount ( ) function will take one string argument and return a float value 
indicating the amount of recognized English words in it. The value 0 . 0 will mean none of the 
words in message are English words and 1 . 0 will mean all of the words in message are 
English words, but most likely getEngli shCount ( ) will return something in between 0 . 0 
and 1 . 0. The isEnglish ( ) function will use this return value as part of whether it returns 
True or False. 



178 http://inventwithpython.com/hacking 



First we must create a list of individual word strings from the string in message. Line 25 will 
convert it to uppercase letters. Then line 26 will remove the non-letter characters from the string, 
such as numbers and punctuation, by calling removeNonLetters ( ) . (We will see how this 
function works later.) Finally, the split ( ) method on line 27 will split up the string into 
individual words that are stored in a variable named possibleWords. 



So if the string 'Hello there. How are you?' was passed when 
getEnglishCount () was called, the value stored in possibleWords after lines 25 to 27 
execute would be [' HELLO ' , 'THERE', 'HOW, 'ARE', 'YOU']. 









detectEngl i sh . py 


29. 


if possibleWords 


== []: 




30. 


return 0.0 # 


no words at all, so return 0.0 





If the string in me s s age was something like ' 1 2 3 4 5 ', all of these non-letter characters would 
have been taken out of the string returned from removeNonLetters ( ) . The call to 
removeNonLetters ( ) would return the blank string, and when split ( ) is called on the 
blank string, it will return an empty list. 



Line 29 does a special check for this case, and returns 0.0. This is done to avoid a "divide -by- 
zero" error (which is explained later on). 







detectEngl i sh . py 


32. 


matches = 0 




33. 


for word in possibleWords: 




34. 


if word in ENGLISH_W0RDS: 




35. 


matches += 1 





The float value that is returned from getEnglishCount ( ) ranges between 0 . 0 and 1 . 0. To 
produce this number, we will divide the number of the words in possibleWords that are 
recognized as English by the total number of words in possibleWords. 



The first part of this is to count the number of recognized English words in pos sibleWords, 
which is done on lines 32 to 35. The matches variable starts off as 0. The for loop on line 33 
will loop over each of the words in possibleWords, and checks if the word exists in the 
ENGLISH_WORDS dictionary. If it does, the value in matches is incremented on line 35. 

Once the for loop has completed, the number of English words is stored in the matches 
variable. Note that technically this is only the number of words that are recognized as English 
because they existed in our dictionary text file. As far as the program is concerned, if the word 
exists in dictionary.txt, then it is a real English word. And if it doesn't exist in the dictionary file, 

Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 179 



it is not an English word. We are relying on the dictionary file to be accurate and complete in 
order for the detect English module to work correctly. 



"Divide by Zero" Errors 







detectEngl i sh . py 


36. 


return float (matches) / len(possibleWords) 





Returning a float value between 0 . 0 and 1 . 0 is a simple matter of dividing the number of 
recognized words by the total number of words. 



However, whenever we divide numbers using the / operator in Python, we should be careful not 
to cause a "divide-by-zero" error. In mathematics, dividing by zero has no meaning. If we try to 
get Python to do it, it will result in an error. Try typing the following into the interactive shell: 



¬ª&gt; 42/0 

Traceback (most recent call last): 

File "&lt;pyshell#0&gt;" , line 1, in &lt;module&gt; 
42/0 

ZeroDivisionError : int division or modulo by zero 

¬ª&gt; 

But a divide by zero can't possibly happen on line 36. The only way it could is if 
len (possibleWords ) evaluated to 0. And the only way that would be possible is if 
possibleWords were the empty list. However, our code on lines 29 and 30 specifically checks 
for this case and returns 0 . 0. So if possibleWords had been set to the empty list, the 
program execution would have never gotten past line 30 and line 36 would not cause a "divide- 
by-zero" error. 



The float ( ) , int ( ) , and str ( ) Functions and Integer 
Division 







detectEngl i sh . py 


36. 


return float(matches) / len(possibleWords) 





The value stored in matches is an integer. However, we pass this integer to the float ( ) 
function which returns a float version of that number. Try typing the following into the interactive 
shell: 



¬ª&gt; float (42) 
42.0 



1 80 http://inventwithpython.com/hacking 



¬ª&gt; 

The int ( ) function returns an integer version of its argument, and the str ( ) function returns a 
string. Try typing the following into the interactive shell: 



¬ª&gt; 


float (42) 


42.0 




¬ª&gt; 


int (42. 


0) 


42 






¬ª&gt; 


int (42. 


7) 


42 






¬ª&gt; 


int("42 


") 


42 






¬ª&gt; 


str(42) 




‚ñ†42' 






¬ª&gt; 


str(42. 


7) 


'42. 


7' 




¬ª&gt; 







The float(),int(), and str ( ) functions are helpful if you need a value's equivalent in a 
different data type. But you might be wondering why we pass matches to float ( ) on line 36 
in the first place. 

The reason is to make our detectEnglish module work with Python 2. Python 2 will do 
integer division when both values in the division operation are integers. This means that the result 
will be rounded down. So using Python 2,22 / 7 will evaluate to 3 . However, if one of the 
values is a float, Python 2 will do regular division: 2 2.0 / 7 will evaluate to 
3.142857142857143. This is why line 36 calls f 1 oat ( ) . This is called making the code 
backwards compatible with previous versions. 

Python 3 always does regular division no matter if the values are floats or ints. 

Practice Exercises, Chapter 12, Set D 

Practice exercises can be found at http://inypy.co^ 



Back to the Code 







detectEngl i sh . py 


39. 


def removeNonLetters(message) : 




40. 


TettersOnly = [] 




41. 


for symbol in message: 





Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 181 



The previously explained getEnglishCount ( ) function calls the removeNonLetters ( ) 
function to return a string that is the passed argument, except with all the numbers and 
punctuation characters removed. 

The code in removeNonLetters ( ) starts with a blank list and loops over each character in 
the message argument. If the character exists in the LETTERS_AND_SPACE string, then it is 
added to the end of the list. If the character is a number or punctuation mark, then it won't exist in 
the LETTERS_AND_SPACE string and won't be added to the list. 



1 82 http://inventwithpython.com/hacking 



The append() List Method 







detectEngl i sh . py 


42. 


-if symbol in LETTERS_AND_SPACE : 




43. 


1 ettersOnl y . append (symbol ) 





Line 42 checks if symbol (which is set to a single character on each iteration of line 41 's for 
loop) exists in the LETTERS_AND_S PACE string. If it does, then it is added to the end of the 
lettersOnly list with the append ( ) list method. 



If you want to add a single value to the end of a list, you could put the value in its own list and 
then use list concatenation to add it. Try typing the following into the interactive shell, where the 
value 42 is added to the end of the list stored in spam: 



¬ª&gt; 


spam 


= [2, 3, 5, 7, 


¬ª&gt; 


spam 




[2, 


3, 5, 


7, 9, 11] 


¬ª&gt; 


spam 


= spam + [42] 


¬ª&gt; 


spam 




[2, 


3, 5, 


7, 9, 11, 42] 


¬ª&gt; 







When we add a value to the end of a list, we say we are appending the value to the list. This is 
done with lists so frequently in Python that there is an append ( ) list method which takes a 
single argument to append to the end of the list. Try typing the following into the shell: 

¬ª&gt; eggs = [] 

¬ª&gt; eggs.append('hovercraft') 

¬ª&gt; eggs 

[ 1 hovercraft ' ] 

¬ª&gt; eggs, append ('eels') 

¬ª&gt; eggs 

['hovercraft', 'eels'] 
¬ª&gt; eggs . append(42) 
¬ª&gt; eggs 

['hovercraft' , 'eels' , 42] 

¬ª&gt; 

For technical reasons, using the append ( ) method is faster than putting a value in a list and 
adding it with the + operator. The append ( ) method modifies the list in-place to include the 
new value. You should always prefer the append ( ) method for adding values to the end of a 
list. 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 183 









detectEngl i sh . py 


44. 


return 1 


' . join(lettersOnly) 





After line 41 's for loop is done, only the letter and space characters are in the lettersOnly 
list. To make a single string value from this list of strings, we call the j oin ( ) string method on 
a blank string. This will join the strings in lettersOnly together with a blank string (that is, 
nothing) between them. This string value is then returned as removeNonLetters ( ) 's return 
value. 

Default Arguments 



detectEngl i sh . py 

47. def isEnglish (message, wordPercentage=20 , 1 etterPercentage=85) : 

48. # By default, 20% of the words must exist in the dictionary file, and 

49. # 85% of all the characters in the message must be letters or spaces 

50. # (not punctuation or numbers). 



The isEnglish ( ) function will accept a string argument and return a Boolean value that 
indicates whether or not it is English text. But when you look at line 47, you can see it has three 
parameters. The second and third parameters (wordPercentage and letterPercentage) 
have equal signs and values next to them. These are called default arguments. Parameters that 
have default arguments are optional. If the function call does not pass an argument for these 
parameters, the default argument is used by default. 

If i sEngli sh ( ) is called with only one argument, the default arguments are used for the 
wordPercentage (the integer 2 0) and letterPercentage (the integer 85) parameters. 
Table 12-1 shows function calls to isEnglish ( ) , and what they are equivalent to: 

Table 12-1. Function calls with and without default arguments. 

Function Call Equivalent To 

isEnglish ( 'Hello ' ) isEnglish (' Hello ' , 20, 85) 

isEnglish ( 'Hello ' , 50) isEnglish (' Hello ' , 50, 85) 

isEnglish ( 'Hello ' , 50, 60) isEnglish (' Hello ' , 50, 60) 

isEnglish (' Hello ' , isEnglish (' Hello ' , 20, 60) 

letterPercentage=60 ) 



1 84 http://inventwithpython.com/hacking 

When isEnglish() is called with no second and third argument, the function will require that 
20% of the words in mes sage are English words that exist in the dictionary text file and 85% of 
the characters in mes sage are letters. These percentages work for detecting English in most 
cases. But sometimes a program calling i sEngli sh ( ) will want looser or more restrictive 
thresholds. If so, a program can just pass arguments for wordPercentage and 
letterPercentage instead of using the default arguments. 

Calculating Percentage 

A percentage is a number between 0 and 100 that shows how much of something there is 
proportional to the total number of those things. In the string value 'Hello cat MOOSE 
f sdkl ewpin ' there are five "words" but only three of them are English words. To calculate 
the percentage of English words, you divide the number of English words by the total 
number of words and multiply by 100. The percentage of English words in ' Hel lo cat 
MOOSE fsdkl ewpin' is 3 / 5 * 100, which is 60. 

Table 12-2 shows some percentage calculations: 



Table 12-2. Some percentage calculations. 



Number of 


Total Number 


English 


* 100 


= Percentage 


English Words 


of Words 


Words / Total 






3 


5 


0.6 


* 100 


60 


6 


10 


0.6 


*100 


60 


300 


500 


0.6 


* 100 


60 


32 


87 


0.3678 


* 100 


36.78 


87 


87 


1.0 


* 100 


100 


0 


10 


0 


* 100 


0 



The percentage will always be between 0% (meaning none of the words) and 100% (meaning all 
of the words). Our isEnglish ( ) function will consider a string to be English if at least 20% of 
the words are English words that exist in the dictionary file and 85% of the characters in the 
string are letters (or spaces). 



detectEngl i sh . py 

51. wordsMatch = getEngl i shCount(message) * 100 &gt;= wordPercentage 

Line 51 calculates the percentage of recognized English words in message by passing 
message to getEngl ishCount ( ) , which does the division for us and returns a float 
between 0 . 0 and 1 . 0 . To get a percentage from this float, we just have to multiply it by 1 0 0 . If 
this number is greater than or equal to the wordPercentage parameter, then True is stored in 



Email questions to the author: al@inventwithpython.com 



Chapter 12 - Detecting English Programmatically 185 



wordsMatch. (Remember, the &gt;= comparison operator evaluates expressions to a Boolean 
value.) Otherwise, False is stored in wordsMatch. 



detectEngl i sh . py 

52. numLetters = 1 en(removeNonLetters(message)) 

53. messageLettersPercentage = float (numLetters) / 1 en (message) * 100 

54. lettersMatch = messageLettersPercentage &gt;= 1 etterPercentage 

Lines 52 to 54 calculate the percentage of letter characters in the me s sage string. To determine 
the percentage of letter (and space) characters in message, our code must divide the number of 
letter characters by the total number of characters in message. Line 52 calls 
removeNonLetters (message ) . This call will return a string that has the number and 
punctuation characters removed from the string. Passing this string to len ( ) will return the 
number of letter and space characters that were in message. This integer is stored in the 
numLetters variable. 

Line 53 determines the percentage of letters getting a float version of the integer in 
numLetters and dividing this by len (message) . The return value of len (message) will 
be the total number of characters in message. (The call to float ( ) was made so that if the 
programmer who imports our detectEnglish module is running Python 2, the division done 
on line 53 will always be regular division instead of integer division.) 

Line 54 checks if the percentage in messageLettersPercentage is greater than or equal to 
the letterPercentage parameter. This expression evaluates to a Boolean value that is stored 

in lettersMatch. 







detectEngl i sh . py 


55. 


return wordsMatch and lettersMatch 





We want isEnglish ( ) to return True only if both the wordsMatch and lettersMatch 
variables contain True, so we put them in an expression with the and operator. If both the 
wordsMatch and lettersMatch variables are True, then isEnglish ( ) will declare that 
the message argument is English and return True. Otherwise, isEnglish ( ) will return 

False. 



Practice Exercises, Chapter 12, Set E 

Practice exercises can be found at http://inypy.con^^ 



186 http://inventwithpython.com/hacking 



Summary 

The dictionary data type is useful because like a list it can contain multiple values. However 
unlike the list, we can index values in it with string values instead of only integers. Most of the 
the things we can do with lists we can also do with dictionaries, such as pass it to len ( ) or use 
the in and not in operators on it. In fact, using the in operator on a very large dictionary 
value executes much faster than using in on a very large list. 

The NoneType data type is also a new data type introduced in this chapter. It only has one value: 
None. This value is very useful for representing a lack of a value. 

We can convert values to other data types by using the int ( ) , float ( ) , and str ( ) functions. 
This chapter brings up "divide -by-zero" errors, which we need to add code to check for and 
avoid. The split ( ) string method can convert a single string value into a list value of many 
strings. The split ( ) string method is sort of the reverse of the j oin ( ) list method. The 
append ( ) list method adds a value to the end of the list. 

When we define functions, we can give some of the parameters "default arguments". If no 
argument is passed for these parameters when the function is called, the default argument value is 
used instead. This can be a useful shortcut in our programs. 

The transposition cipher is an improvement over the Caesar cipher because it can have hundreds 
or thousands of possible keys for messages instead of just 26 different keys. A computer has no 
problem decrypting a message with thousands of different keys, but to hack this cipher, we need 
to write code that can determine if a string value is valid English or not. 

Since this code will probably be useful in our other hacking programs, we will put it in its own 
module so it can be imported by any program that wants to call its i sEngli sh ( ) function. All 
of the work we've done in this chapter is so that any program can do the following: 



¬ª&gt; "import detectEngl i sh 

¬ª&gt; detectEnglish.isEnglish('Is this sentence English text?') 
True 

¬ª&gt; 



Now armed with code that can detect English, let's move on to the next chapter and hack the 
transposition cipher! 



Email questions to the author: al@inventwithpython.com 



Chapter 13 - Hacking the Transposition Cipher 187 




Chapter 13 



Hacking the Transposition 
Cipher 



Topics Covered In This Chapter: 

‚Ä¢ Multi-line Strings with Triple Quotes 

‚Ä¢ The strip ( ) String Method 



To hack the transposition cipher, we will use a brute -force approach. Of the thousands of keys, 
the correct key is most likely that only one that will result in readable English. We developed 
English-detection code in the last chapter so the program can realize when it has found the correct 
key. 

Source Code of the Transposition Cipher Hacker Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as transpositionHacker.py . Press F5 to run the program. Note 
that first you will need to download the pyperclip.py module and place this file in the same 
directory as the transpositionHacker.py file. You can download this file from 
http://inypy.conVpyperclip.py. 

Source code for transpositionHacker.py 

1. # Transposition Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip, detectEngl i sh , transpositionDecrypt 

5. 



188 http://inventwithpython.com/hacking 



6. def main() : 

7. # You might want to copy &amp; paste this text from the source code at 

8. # http://invpy.com/transpositionHacker.py 

9. myMessage = """Cb b rssti aieih rooaopbrtnsceee er es no npfgcwu pi ri 
ch nitaalr ei uengi teehb(el hi 1 i ncegeoamn f ubehgtarndcstudmd nM eu eacBol taetee 
oi nebcdkyremdteghn . aa2r81a condari fmps" tad 1 t oisn sit ulrnd stara nvhn fs 
edbh ee,n e necrg6 8nmisv 1 nc muiftegiitm tutmg cm shSs9fcie ebintcaets h a 
ihda cctrhe ele 107 aaoem waoaatdahretnhechaopnooeapece9etf ncdbgsoeb uuteitgna. 
rteoh add e , D7clEtnpneehtn beete" evecoal lsfmcrl iulcifgo ai . sllrchdnheev sh 
meBd ies e9t)nh,htcnoecpl rrh ,ide hmtlme. pheaLem , toei nf gn t e9yce da' eN eMp a 
ffn Fclo ge eohg dere.eec s nfap yox hla yon. "InrnsreaBoa t,e eitsw il ulpbdofg 
BRe bwlmprraio po droB wtinue r Pieno nc ayi eeto ' 1 ul ci h sfnc ownaSserberei aSm 
-eaiah, nnrttgcC macii ritvledastinidel nn rms iehn tsi gaBmuoetceti as rn 



10. 

11. hackedMessage = hackTransposition(myMessage) 

12. 

13. if hackedMessage == None: 

14. printC Failed to hack encryption.') 

15. else: 

16. printC Copying hacked message to clipboard:') 

17. pri nt(hackedMessage) 

18 . pypercl i p . copy(hackedMessage) 

19. 
20. 

21. def hackTransposi ti on (message) : 

22. printC'Hacking. . . ') 

23. 

24. # Python programs can be stopped at any time by pressing Ctrl-C (on 

25. # Windows) or Ctrl-D (on Mac and Linux) 

26. printC (Press Ctrl-C or Ctrl-D to quit at any time.)') 
27. 

28. # brute-force by looping through every possible key 

29. for key in range(l, len(message)) : 

30. print('Trying key #%s...' % (key)) 
31. 

32. decryptedText = transpositionDecrypt.decryptMessage(key, message) 

33. 

34. if detectEnglish.isEnglish(decryptedText) : 

35. # Check with user to see if the decrypted key has been found. 

36. print() 

37. printC Possible encryption hack:') 

38. printC Key %s: %s' % (key, decryptedText [: 100] )) 

39. print() 

40. print('Enter D for done, or just press Enter to continue 
hacki ng : ' ) 

41. response = input('&gt; ') 



Email questions to the author: al@inventwithpython.com 



Chapter 13 - Hacking the Transposition Cipher 189 



42. 






43. 




if response . stri p() .upperO .startswith('D') : 


44. 




return decryptedText 


45. 






46. 


return 


None 


47. 






48. 


if name_ 


. == ' man n ' : 


49. 


mainO 





Sample Run of the Transposition Breaker Program 

When you run this program, the output will look this: 



Hacki ng . . . 

(Press Ctrl-C or Ctrl-D to quit at any time.) 

Trying key #1. . . 

Tryi ng key #2 . . . 

Tryi ng key #3 . . . 

Tryi ng key #4 . . . 

Tryi ng key #5 . . . 

Trying key #6. . . 

Tryi ng key #7 . . . 

Tryi ng key #8 . . . 

Tryi ng key #9 . . . 

Trying key #10. . . 

Possible encryption hack: 

Key 10: Charles Babbage, FRS (26 December 1791 - 18 October 1871) was an 
English mathematician, philosopher, 

Enter D for done, or just press Enter to continue hacking: 
&gt; D 

Copying hacked message to clipboard: 

Charles Babbage, FRS (26 December 1791 - 18 October 1871) was an English 
mathematician, philosopher, inventor and mechanical engineer who originated the 
concept of a programmable computer. Considered a "father of the computer", 
Babbage is credited with inventing the first mechanical computer that 
eventually led to more complex designs. Parts of his uncompleted mechanisms are 
on display in the London Science Museum. In 1991, a perfectly functioning 
difference engine was constructed from Babbage's original plans. Built to 
tolerances achievable in the 19th century, the success of the finished engine 
indicated that Babbage's machine would have worked. Nine years later, the 
Science Museum completed the printer Babbage had designed for the difference 
engi ne . 



190 http://inventwithpython.com/hacking 

When the hacker program has found a likely correct decryption, it will pause and wait for the user 
to press "D" and then Enter. If the decryption is a false positive, the user can just press Enter and 
the program will continue to try other keys. 

Run the program again and skip the correct decryption by just pressing Enter. The program 
assumes that it was not a correct decryption and continues brute -forcing through the other 
possible keys. Eventually the program runs through all the possible keys and then gives up, 
telling the user that it was unable to hack the ciphertext: 



Tryi ng key #757 . . . 
Tryi ng key #758 . . . 
Tryi ng key #759 . . . 
Tryi ng key #760 . . . 
Trying key #761. . . 
Failed to hack encryption. 



How the Program Works 







t ransposi ti onHacke r . py 


1. 


# Transposition Cipher Hacker 




2. 
3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 


import pyperclip, detectEngl i sh , transpositionDecrypt 





The transposition hacker program is under 50 lines of code because much of it exists in other 
programs. Several modules are imported on line 4. 



Multi-line Strings with Triple Quotes 

t ransposi ti onHacke r . py 

6. def main() : 

7. # You might want to copy &amp; paste this text from the source code at 

8. # http://invpy.com/transpositionHacker.py 

9. myMessage = """Cb b rssti aieih rooaopbrtnsceee er es no npfgcwu pi ri 
ch nitaalr ei uengi teehb(el hi 1 i ncegeoamn f ubehgtarndcstudmd nM eu eacBoltaetee 
oi nebcdkyremdteghn . aa2r81a condari fmps" tad 1 t oisn sit ulrnd stara nvhn fs 
edbh ee,n e necrg6 8nmisv 1 nc muiftegiitm tutmg cm shSs9fcie ebintcaets h a 
ihda cctrhe ele 107 aaoem waoaatdahretnhechaopnooeapece9etf ncdbgsoeb uuteitgna. 
rteoh add e , D7clEtnpneehtn beete" evecoal lsfmcrl iulcifgo ai . sllrchdnheev sh 
meBd ies e9t)nh,htcnoecpl rrh ,ide hmtlme. pheaLem , toei nf gn t e9yce da' eN eMp a 
ffn Fclo ge eohg dere.eec s nfap yox hla yon. InrnsreaBoa t,e eitsw il ulpbdofg 
BRe bwlmprraio po droB wtinue r Pieno nc ayi eeto ' 1 ul ci h sfnc ownaSserberei aSm 
-eaiah, nnrttgcC macii ritvledastinidel nn rms iehn tsigaBmuoetcetias rn""" 



Email questions to the author: al@inventwithpython.com 



Chapter 13 - Hacking the Transposition Cipher 191 



The ciphertext to be hacked is stored in the myMessage variable. Line 9 has a string value that 
begins and ends with triple quotes. These strings do not have to have literal single and double 
quotes escaped inside of them. Triple quote strings are also called multi-line strings, because they 
can also contain actual newlines within them. Try typing the following into the interactive shell: 



¬ª&gt; spam = """Dear Alice, 




Why did you dress up my hamster in doll clothing? 




I look at Mr. Fuzz and think, "I know this was Alice 


s doing." 


Sincerely, 




Bob ' 




¬ª&gt; print(spam) 




Dear Alice, 




Why did you dress up my hamster in doll clothing? 




I look at Mr. Fuzz and think, "I know this was Alice 


s doing." 


Sincerely, 




Bob 




¬ª&gt; 





Notice that this string value can span over multiple lines. Everything after the opening triple 
quotes will be interpreted as part of the string until it reaches triple quotes ending it. Multi-line 
strings can either use three double quote characters or three single quote characters. 



Multi-line strings are useful for putting very large strings into the source code for a program, 
which is why it is used on line 9 to store the ciphertext to be broken. 



Back to the Code 







t ransposi ti onHacke r . py 


11. 


hackedMessage = hackTransposition(myMessage) 





The ciphertext hacking code exists inside the hackTransposition ( ) function. This function 
takes one string argument: the encrypted ciphertext message to be broken. If the function can 
hack the ciphertext, it returns a string of the decrypted text. Otherwise, it returns the None value. 
This value is stored in the hackedMessage variable. 







t ransposi ti onHacke r . py 


13. 


if hackedMessage == None: 




14. 


print('Failed to hack encryption.') 





If None was stored in hackedMessage, the program prints that it was unable to break the 
encryption on the message. 



192 http://inventwithpython.com/hacking 







t ransposi ti onHacke r . py 


15. 


else: 




16. 


pri nt( ' Copyi ng hacked message to clipboard:') 




17. 


print(hackedMessage) 




18. 


pypercl i p . copy(hackedMessage) 





Otherwise, the text of the decrypted message is printed to the screen on line 17 and also copied to 
the clipboard on line 18. 



t ransposi ti onHacker . py 

21. def hackTransposi ti on (message) : 



22. pri nt(' Hacking. .. ') 

23. 

24. # Python programs can be stopped at any time by pressing Ctrl-C (on 

25. # Windows) or Ctrl-D (on Mac and Linux) 

26. printC (Press Ctrl-C or Ctrl-D to quit at any time.)') 



Because there are many keys the program can go through, the program displays a message to the 
user telling her that the hacking has started. The print ( ) call on line 26 also tells her that she 
can press Ctrl-C (on Windows) or Ctrl-D (on OS X and Linux) to exit the program at any point. 
(Pressing these keys will always exit a running Python program.) 



t ransposi ti onHacke r . py 

28. # brute-force by looping through every possible key 

29. for key in range(l, len(message)) : 

30. print('Trying key #%s...' % (key)) 

The range of possible keys for the transposition cipher is the integers between 1 and the length of 
the message. The for loop on line 29 will run the hacking part of the function with each of these 
keys. 

To provide feedback to the user, the key that is being tested is printed to the string on line 30, 
using string interpolation to place the integer in key inside the ' Trying key #%s . . . ' % 
(key) string. 



t ransposi ti onHacker . py 

32. decryptedText = transpositionDecrypt.decryptMessage(key, message) 

Using the decryptMes sage ( ) function in the transpositionDecrypt.py program that we've 
already written, line 32 gets the decrypted output from the current key being tested and stores it in 
the decryptedText variable. 



Email questions to the author: al@inventwithpython.com 



Chapter 13 - Hacking the Transposition Cipher 193 





t ransposi ti onHacker. py 


34. 


if detectEnglish.isEnglish(decryptedText) : 


35. 


# Check with user to see if the decrypted key has been found. 


36. 


pri nt() 


37. 


printC Possible encryption hack:') 


38. 


printC'Key %s: %s' % (key, decryptedText [ : 100] )) 


39. 


printO 


40. 


printC'Enter D for done, or just press Enter to continue 


hacki ng : ' ) 




41. 


response = input('&gt; ') 



The decrypted output in decryptedText will most likely only be English if the correct key 
was used (otherwise, it will appear to be random garbage). The string in decryptedText is 
passed to the detectEnglish . isEnglish ( ) function we wrote in the last chapter. 



But just because detectEnglish . isEnglish ( ) returns True (making the program 
execution enter the block following the i f statement on line 34) doesn't mean the program has 
found the correct key. It could be a "false positive". To be sure, line 38 prints out the first 100 
characters of the decryptedText string (by using the slice decryptedText [ : 100 ] ) on 
the screen for the user to look at. 

The program pauses when line 41 executes, waiting for the user to type something in either D on 
nothing before pressing Enter. This input is stored as a string in response. 



The strip () String Method 



The stripC) string method returns a version of the string that 


has any 


whitespace at the beginning and end of the string stripped out 


Try typing in 


the following into the interactive shell: 




¬ª&gt; ' Hello' .stripC) 




'Hello' 




¬ª&gt; 'Hello ' .stripC) 




'Hello' 




¬ª&gt; ' Hello World ' .stripC) 




'Hello World' 




¬ª&gt; 'Hello x'. stripC) 




'Hello x' 




¬ª&gt; 





The strip ( ) method can also have a string argument passed to it that tells the method which 
characters should be removed from the start and end of the string instead of removing whitespace. 



194 http://inventwithpython.com/hacking 



The whitespace characters are the space character, the tab character, and the newline 
character. Try typing the following into the interactive shell: 



&gt;¬ª 'Helloxxxxxx' .strip('x') 
'Hello' 

¬ª&gt; 'aaaaaHELLOaa' .strip('a') 
'HELLO' 

&gt;¬ª 'ababaHELLOab' .str-ip('ab') 
'HELLO' 

¬ª&gt; 'abccabcbacbXYZabcXYZacccab' .strip('abc') 
'XYZabcXYZ' 

¬ª&gt; 







t ransposi ti onHacke r . py 


43. 


if response. stripO .upperO .startswith('D') : 




44. 


return decryptedText 





The expression on line 43 used for the i f statement's condition lets the user have some 
flexibility with what has to be typed in. If the condition were response == ' D ' , then the user 
would have to type in exactly "D" and nothing else in order to end the program. 



If the user typed in ' d ' or ' D ' or ' Done ' then the condition would be Fal se and the 
program would continue. To avoid this, the string in response has any whitespace removed 
from the start or end with the call to strip ( ) . Then the string that response . strip ( ) 
evaluates to has the upper ( ) method called on it. If the user typed in either "d" or "D", the 
string returned from upper ( ) will be ' D ' . Little things like this make our programs easier for 
the user to use. 



If the user has indicated that the decrypted string is correct, the decrypted text is returned from 

hackTransposition ( ) on line 44. 







t ransposi ti onHacke r . py 


46. 


return None 





Line 46 is the first line after the for loop that began on line 29. If the program execution reaches 
this point, it's because the return statement on line 44 was never reached. That would only 
happen if the correctly decrypted text was never found for any of the keys that were tried. 



In that case, line 46 returns the None value to indicate that the hacking has failed. 







t ransposi ti onHacke r . py 


48. if name == 


= ' mai n ' : 





Email questions to the author: al@inventwithpython.com 



Chapter 13 - Hacking the Transposition Cipher 195 



49. main() 

Lines 48 and 49 call the main ( ) function if this program was run by itself, rather than imported 
by another program that wants to use its hackTransposition ( ) function. 

Practice Exercises, Chapter 13, Set A 

Practice exercises can be found at ht^://invpxAQn^^J^^ra(^cel3A. 

Summary 

This chapter was short like the "Breaking the Caesar Cipher with the Brute-Force Technique" 
chapter because (also like that chapter) most of the code was already written in other programs. 
Our hacking program can import functions from these other programs by importing them as 
modules. 

The strip ( ) string method is useful for removing whitespace (or other) characters from the 
beginning or end of a string. If we use triple quotes, then a string value can span across multiple 
lines in our source code. 

The detectEnglish.py program removes a lot of the work of inspecting the decrypted output to see 
if it's English. This allows the brute -force technique to be applied to a cipher that can have 
thousands of keys. 

Our programs are becoming more sophisticated. Before we learn the next cipher, we should learn 
how to use Python's debugger tool to help us find bugs in our programs. 



196 http://inventwithpython.com/hacking 




Chapter 14 



Modular Arithmetic with 
the Multiplicative and 
Affine Ciphers 

Topics Covered In This Chapter: 

‚Ä¢ Modular Arithmetic 

‚Ä¢ "Mod" is "Remainder Of '(Sort Of) 

‚Ä¢ GCD: Greatest Common Divisor (aka Greatest Common Factor) 

‚Ä¢ Multiple Assignment Trick 

‚Ä¢ Euclid's Algorithm for Finding the GCD of Two Numbers 

‚Ä¢ "Relatively Prime" 

‚Ä¢ The Multiplicative Cipher 

‚Ä¢ Finding Modular Inverses 

‚Ä¢ The cryptomath Module 



"People have been defending their own privacy for centuries 
with whispers, darkness, envelopes, closed doors, secret 
handshakes, and couriers. The technologies of the past did 
not allow for strong privacy, but electronic technologies do." 

Eric Hughes, "A Cypherpunk's Manifesto", 1993 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 197 



The multiplicative and affine ciphers are similar to the Caesar cipher, except instead of adding a 
key to a symbol's index in a string, these ciphers use multiplication. But before we learn how to 
encrypt and decrypt with these ciphers, we're going to need to learn a little math. This knowledge 
is also needed for the last cipher in this book, the RSA cipher. 

Oh No Math! 

Don't let it scare you that you need to learn some math. The principles here are easy to learn from 
pictures, and we'll see that they are directly useful in cryptography. 

Math Oh Yeah! 

That's more like it. 

Modular Arithmetic (aka Clock Arithmetic) 

This is a clock in which I've replaced the 12 with a 0. (I'm a programmer. I think it's weird that 
the day begins at 12 AM instead of 0 AM.) Ignore the hour, minute, and second hands. We just 
need to pay attention to the numbers. 




Figure 14-1. A clock with a zero o'clock. 



198 http://inventwithpython.com/hacking 

3 O'clock + 5 Hours = 8 O'clock 

If the current time is 3 o'clock, what time will it be in 5 hours? This is 
easy enough to figure out. 3 + 5 = 8. It will be 8 o'clock. Think of the 
hour hand on the clock in Figure 14-1 starting at 3, and then moving 5 
hours clockwise. It will end up at 8. This is one way we can double- 
check our math. 



10 O'clock + 5 Hours = 3 O'clock 

If the current time is 10 o'clock, what time will it be in 5 hours? If you 
add 10 + 5, you get 15. But 15 o'clock doesn't make sense for clocks 
like the one to the right. It only goes up to 12. So to find out what time 
it will be, we subtract 15-12 = 3. The answer is it will be 3 o'clock. 
(Whether or not it is 3 AM or 3PM depends on if the current time is 10 
AM or 10 PM. But it doesn't matter for modular arithmetic.) 

If you think of the hour hand as starting at 10 and then moving forward 

5 hours, it will land on 3. So double-checking our math by moving the 
hour hand clockwise shows us that we are correct. 

10 O'clock + 200 Hours = 6 O'clock 

If the current time is 10 o'clock, what time will it be in 200 hours? 200 
+ 10 = 210, and 210 is larger than 12. So we subtract 210 - 12 = 198. 
But 198 is still larger than 12, so we subtract 12 again. 198 - 12 = 186. 
If we keep subtracting 12 until the difference is less than 12, we end up 
with 6. If the current time is 10 o'clock, the time 200 hours later will be 

6 o'clock. 

If we wanted to double check our 10 o'clock + 200 hours math, we 
would keep moving the hour hand around and around the clock face. 
When we've moved the hour hand the 200 th time, it will end up landing 
on 6. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 199 



The % Mod Operator 

This sort of "wrap-around" arithmetic is called modular arithmetic. We say "fifteen mod 
twelve" is equal to 3. (Just like how "15 o'clock" mod twelve would be "3 o'clock) In Python, 
the mod operator is the % percent sign. Try typing the following into the interactive shell: 



¬ª&gt; 


15 ¬∞, 


&amp; 12 


3 






¬ª&gt; 


210 


% 12 


6 






¬ª&gt; 


10 % 


10 


0 






¬ª&gt; 


20 % 


10 


0 






¬ª&gt; 







"Mod" is "Division Remainder"(Sort Of) 

You can think of the mod operator as a "division remainder" operator. 21 -r 5 = 4 remainder 1. 
And 21 % 5 = 1. This works pretty well for positive numbers, but not for negative numbers. -21 4- 
5 = -4 remainder -1. But the result of a mod operation will never be negative. Instead, think of 
that -1 remainder as being the same as 5 - 1, which comes to 4. This is exactly what -21 % 5 
evaluates to: 



¬ª&gt; -21 % 5 
4 

¬ª&gt; 

But for the purposes of cryptography in this book, we'll only be modding positive numbers. 

Practice Exercises, Chapter 14, Set A 

Practice exercises can be found at ht^://mvpxcpr^^togpracticel4A. 

GCD: Greatest Common Divisor (aka Greatest Common Factor) 

Factors are the numbers that can be multiplied to produce a particular number. Look at this 
simple multiplication: 

4 x 6 = 24 

In the above math problem, we say 4 and 6 are factors of 24. (Another name for factor is 
divisor.) The number 24 also has some other factors: 



200 http://inventwithpython.com/hacking 



8 x 3 = 24 
12 x 2 = 24 
24 x 1 = 24 

From the above three math problems, we can see that 8 and 3 are also factors of 24, as are 12 and 
2, and 24 and 1. So we can say the factors of 24 are: 1, 2, 3, 4, 6, 8, 12, and 24. 

Let's look at the factors of 30: 

1 x 30 = 30 

2 x 15 = 30 

3 x 10 = 30 
5 x 6 = 30 

So the factors of 30 are 1, 2, 3, 5, 6, 10, 15, and 30. (Notice that any number will always have 1 
and itself as factors.) If you look at the list of factors for 24 and 30, you can see that the factors 
that they have in common are 1, 2, 3, and 6. The greatest number of these is 6, so we call 6 the 
greatest common factor (or, more commonly, the greatest common divisor) of 24 and 30. 

Visualize Factors and GCD with Cuisenaire Rods 

E 



2 



rm 




i ' ' ' ' :~m 
i ' ' ' ' 

i --------- i 

Figure 14-2. Each Cuisenaire rod has a different color for each integer length. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 201 

Above are some rectangular blocks with a width of 1 unit, 2 units, 3 units, and so on. The block's 
length can be used to represent a number. You can count the number of squares in each block to 
determine the length and number. These blocks (sometimes called Cuisenaire rods) can be used to 
visualize math operations, like 3 + 2 = 5 or 5x3 = 15: 



3+2=5 5x3=15 

Figure 14-3. Using Cuisenaire rods to demonstrate addition and multiplication. 

If we represent the number 30 as a block that is 30 units long, a number is a factor of 30 if the 
number's blocks can evenly fit with the 30-block. You can see that 3 and 10 are factors of 30: 

I 



i ::::::::::::::::::::::::::::: i 


i : ‚ñ† : : 








: ‚ñ† : i : : 








i : : i : 


. 1 . 


: i : : i : 


. 1 . 


: i : i : 


. 1 . 


. 1 . 


: i 



I 

1 0 and 3 are factors of 30, since they evenly fit into 30. 



Figure 14-4. Cuisenaire rods demonstrating factors. 

But 4 and 7 are not factors of 30, because the 4-blocks and 7-blocks won't evenly fit into the 30- 
block: 



I Too much! 




4 and 7 are not factors of 30, 
since they can't evenly fit into 30. 



Figure 14-5. Cuisenaire rods demonstrating numbers that are not factors of 30. 

The Greatest Common Divisor of two blocks (that is, two numbers represented by those blocks) 
is the longest block that can evenly fit both blocks. 



202 http://inventwithpython.com/hacking 



i ::::::::::::::::::::::: I 
i ------- i ------- i ------- ~i 



|32 








: : h 




8 


8 


8 


BBSS 


i 



The greatest common divisor of 32 and 
24 is 8, since 8 is the longest block that 
can evenly fit into both 32 and 24. 

Figure 14-6. Cuisenaire rods demonstrating Greatest Common Divisor. 

More information about Cuisenaire rods can be found at http://invpy,^ 

Practice Exercises, Chapter 14, Set B 

Practice exercises can be found at http://inypy.co^ 

Multiple Assignment 

Our GCD function will use Python's multiple assignment trick. The multiple assignment trick lets 
you assign more than one variable with a single assignment statement. Try typing the following 
into the interactive shell: 



¬ª&gt; spam, 
¬ª&gt; spam 
42 


eggs 


= 42, 'Hello' 




¬ª&gt; eggs 
'Hello' 

&gt;¬ª a, b, 


c, d 


= ['Alice' , 'Bob' , 'Carol ' , 


' Davi d ' ] 


¬ª&gt; a 
'Alice' 








&gt;¬ª b 
'Bob' 








¬ª&gt; c 
'Carol ' 








¬ª&gt; d 
' Davi d ' 








&gt;¬ª 









The variable names on the left side of the = operator and the values on the right side of the = 
operator are separated by a comma. You can also assign each of the values in a list to its own 
variable, if the number of items in the list is the same as the number of variables on the left side 
of the = operator. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 203 



Be sure to have the same number of variables as you have values, otherwise Python will raise an 
error that says the call needs more or has too many values: 



¬ª&gt; a, b, c = 1, 2 

Traceback (most recent call last): 

File "&lt;pyshell#8&gt;" , line 1, in &lt;module&gt; 
a, b, c = 1, 2 
ValueError: need more than 2 values to unpack 

¬ª&gt; a, b, c = 1, 2, 3, 4, 5, 6 
Traceback (most recent call last): 

File "&lt;pyshell#9&gt;" , line 1, in &lt;module&gt; 
a, b, c = 1, 2, 3, 4, 5, 6 
ValueError: too many values to unpack 
¬ª&gt; 



Swapping Values with the Multiple Assignment Trick 

One of the main uses of the multiple assignment trick is to swap the values in two variables. Try 
typing the following into the interactive shell: 



¬ª&gt; spam = 'hello' 

¬ª&gt; eggs = 'goodbye' 

¬ª&gt; spam, eggs = eggs, spam 

¬ª&gt; spam 

' goodbye ' 

¬ª&gt; eggs 

'hello' 



We will use this swapping trick in our implementation of Euclid's algorithm. 

Euclid's Algorithm for Finding the GCD of Two Numbers 

Figuring out the GCD of two numbers will be important for doing the multiplicative and affine 
ciphers. It seems simple enough: just look at the numbers and write down any factors you can 
think of, then compare the lists and find the largest number that is in both of them. 

But to program a computer to do it, we'll need to be more precise. We need an algorithm (that is, 
a specific series of steps we execute) to find the GCD of two numbers. 

A mathematician who lived 2,000 years ago named Euclid came up with an algorithm for finding 
the greatest common divisor of two numbers. Here's a statue of Euclid at Oxford University: 



204 http://inventwithpython.com/hacking 




Figure 14-7. Euclid may or may not have looked like this. 

Of course since no likeness or description of Euclid exists in any historical document, no one 
knows what he actually looked like at all. (Artists and sculptors just make it up.) This statue could 
also be called, "Statue of Some Guy with a Beard". 

Euclid's GCD algorithm is short. Here's a function that implements his algorithm as Python code, 
which returns the GCD of integers a and b: 



def gcd(a, b) : 
while a != 0: 

a, b = b % a, a 
return b 

If you call this function from the interactive shell and pass it 2 4 and 3 0 for the a and b 
parameters, the function will return 6. You could have done this yourself with pencil and paper. 
But since you've programmed a computer to do this, it can easily handle very large numbers: 



¬ª&gt; gcd(24, 30) 
6 

¬ª&gt; gcd(409119243, 87780243) 
6837 

¬ª&gt; 



How Euclid's algorithm works is beyond the scope of this book, but you can rely on this function 
to return the GCD of the two integers you pass it. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 205 



"Relatively Prime" 

Relatively prime numbers are used for the multiplicative and affine ciphers. We say that two 
numbers are relatively prime if their greatest common divisor is 1. That is, the numbers a and b 
are relatively prime to each other if gcd ( a , b) == 1. 

Practice Exercises, Chapter 14, Set C 

Practice exercises can be found at ht^://invpxAQn^^J^^ra(^cel4C. 

The Multiplicative Cipher 

In the Caesar cipher, encrypting and decrypting symbols involved converting them to numbers, 
adding or subtracting the key, and then converting the new number back to a symbol. 

What if instead of adding the key to do the encryption, we use multiplication? There would be a 
"wrap-around" issue, but the mod operator would solve that. For example, let's use the symbol 
set of just uppercase letters and the key 7. Here's a list of the letters and their numbers: 

0123456789 10 11 12 
ABCDEFGHIJ K L M 



13 14 15 16 17 18 19 20 21 22 23 24 25 
NOPQRSTUVWXYZ 

To find what the symbol F encrypts to with key 7, multiply its number (5) by 7 and mod by 26 (to 
handle the "wrap-around" with our 26-symbol set). Then use that number's symbol. (5 x 7) mod 
26 = 9, and 9 is the number for the symbol J. So F encrypts to J in the multiplicative cipher with 
key 7. Do the same with all of the letters: 



206 http://inventwithpython.com/hacking 

Table 14-1. Encrypting each letter with the multiplicative cipher with key 7. 



Plaintext 
Symbol 


Number 


Encryption with 
Key 7 


CiDhertext 
Symbol 


A 


o 


(0 * 7) % 26 = 


- 0 


A 


B 


1 


(1 * 7) % 26 - 


= 7 


H 


c 


2 


(2 * 7) % 26 - 


- 14 


o 


D 


3 


(3 * 7) % 26 = 


= 21 


V 


E 


4 


(4 * 7) % 26 = 


z 2 


c 


F 


5 


(5 * 7) % 26 - 


= 9 


J 


G 


6 


(6 * 7) % 26 = 


= 16 


o 


H 


7 


(7 * 7) % 26 - 


- 23 


X 


I 


8 


(8 * 7) % 26 = 


= 4 


E 


J 


9 


(9 * 7) % 26 = 


= 11 


L 


K 


10 


(10 * 7) % 26 


= 18 


s 


L 


11 


(11*7) % 26 


= 25 


Y 


M 


12 


(12 * 7) % 26 


= 6 


G 


N 


13 


(13 * 7) % 26 


= 13 


N 


o 


14 


(14 * 7) % 26 


= 20 


u 


p 


15 


(15 * 7) % 26 


= 1 


B 


o 


16 


(16 * 7) % 26 


= 8 


I 


R 


17 


(17 * 7) % 26 


= 15 


p 


s 


18 


(18* 7)% 26 


= 22 


W 


T 


19 


(19 * 7) % 26 


= 3 


D 


U 


20 


(20 * 7) % 26 


= 10 


K 


V 


21 


(21 * 7) % 26 


= 17 


R 


w 


22 


(22 * 7) % 26 


= 24 


Y 


X 


23 


(23 * 7) % 26 


= 5 


F 


Y 


24 


(24 * 7) % 26 


= 12 


M 


Z 


25 


(25 * 7) % 26 


= 19 


T 



You will end up with this mapping for the key 7: to encrypt you replace the top letter with the 
letter under it, and vice versa to decrypt: 

ABCDEFGHI J KLMNOPQRS TUVWXYZ 
AHOVCJ QXELS YGNUB I PWDKRYFMT 

It wouldn't take long for an attacker to brute -force through the first 7 keys. But the good thing 
about the multiplicative cipher is that it can work with very large keys, like 8,953,851 (which has 
the letters of the alphabet map to the letters AXUROLIFCZWTQNKHEB YVSPMJGD) . It would 
take quite some time for a computer to brute -force through nearly nine million keys. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 207 



Practice Exercises, Chapter 14, Set D 

Practice exercises can be found at http://invp_y_.c_o_rn/hacto 

Multiplicative Cipher + Caesar Cipher = The Affine Cipher 

One downside to the multiplicative cipher is that the letter A always maps to the letter A. This is 
because A's number is 0, and 0 multiplied by anything will always be 0. We can fix this by 
adding a second key that performs a Caesar cipher encryption after the multiplicative cipher's 
multiplication and modding is done. 

This is called the affine cipher. The affine cipher has two keys. "Key A" is the integer that the 
letter's number is multiplied by. After modding this number by 26, "Key B" is the integer that is 
added to the number. This sum is also modded by 26, just like in the original Caesar cipher. 

This means that the affine cipher has 26 times as many possible keys as the multiplicative cipher. 
It also ensures that the letter A does not always encrypt to the letter A. 

Encryption . Multiply . Add &gt; Mod by . 

Process: Plaintext by Key A Key B symbol Ciphertext 

' * V se t size ~ 

Decryption , Mod by &gt; Multiply . Subtract . 

Process: Plaintext ^psymbol by mod Key B Ciphertext 

set size inverse 
of Key A 

Figure 14-8. The encryption and decryption are mirrors of each other. 

The First Affine Key Problem 

There are two problems with the multiplicative cipher's key and affine cipher's Key A. You 
cannot just use any number for Key A. For example, if you chose the key 8, here is the mapping 
you would end up with: 

ABCDEFGHI JKLMNOPQRSTUVWXYZ 
AI QYGOWEMUCKS AI QYGOWEMU CKS 



This mapping doesn't work at all! Both the letters C and P encrypt to Q. When we encounter a Q 
in the ciphertext, how do we know which it decrypts to? ! The same problem exists for encrypting 
A and N, F and S, and many others. 



208 http://inventwithpython.com/hacking 

So some keys will work in the affine cipher while others will not. The secret to determining 
which key numbers will work is this: 

In the affine cipher, the Key A number and the size of the symbol set must be relatively 
prime to each other. That is, gcd(key, size of symbol set) == 1. 

We can use the gcd ( ) function we wrote earlier to test this. The key 7 works as an affine cipher 
key because gcd (7 , 2 6) returns 1. The larger key 8,953,851 will also work because 
gcd ( 8 9 5 3 8 5 1 , 26) also returns 1 . However, the key 8 did not work because gcd ( 8 , 2 6) 
is 2. If the GCD of the key and the symbol set size is not 1, then they are not relatively prime and 
the key won't work. 

The math we learned earlier sure is coming in handy now. We need to know how mod works 
because it is part of the GCD and affine cipher algorithms. And we need to know how GCD 
works because that will tell us if a pair of numbers is relatively prime. And we need to know if a 
pair of numbers is relatively prime or not in order to choose valid keys for the affine cipher. 

The second problem with affine cipher's key is discussed in the next chapter. 

Decrypting with the Affine Cipher 

In the Caesar cipher, we used addition to encrypt and subtraction to decrypt. In the affine cipher, 
we use multiplication to encrypt. You might think that we need to divide to decrypt with the 
affine cipher. But if you try this yourself, you'll quickly see that it doesn't work. To decrypt with 
the affine cipher, we need to multiply by the key's modular inverse. 

A modular inverse (which we will call i) of two numbers (which we will call a and m) is such 
that (a * i) % m == 1. For example, let's find the modular inverse of "5 mod 7". There is 
some number i where (5 * i) % 7 will equal "1". We will have to brute-force this 
calculation: 

‚Ä¢ 1 isn't the modular inverse of 5 mod 7, because (5 * 1) % 7 = 5. 

‚Ä¢ 2 isn't the modular inverse of 5 mod 7, because (5 * 2) % 7 = 3. 

‚Ä¢ 3 is the modular inverse of 5 mod 7, because (5 * 3) % 7 = 1. 

The encryption key and decryption keys for the affine cipher are two different numbers. The 
encryption key can be anything we choose as long as it is relatively prime to 26 (which is the size 
of our symbol set). If we have chosen the key 7 for encrypting with the affine cipher, the 
decryption key will be the modular inverse of 7 mod 26: 

‚Ä¢ 1 is not the modular inverse of 7 mod 26, because (7 * 1) % 26 = 7. 

‚Ä¢ 2 is not the modular inverse of 7 mod 26, because (7 * 2) % 26 = 14. 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 209 

‚Ä¢ 3 is not the modular inverse of 7 mod 26, because (7 * 3) % 26 = 21. 

‚Ä¢ 4 is not the modular inverse of 7 mod 26, because (7 * 4) % 26 = 2. 

‚Ä¢ 5 is not the modular inverse of 7 mod 26, because (7 * 5) % 26 = 9. 

‚Ä¢ 6 is not the modular inverse of 7 mod 26, because (7 * 6) % 26 = 16. 

‚Ä¢ 7 is not the modular inverse of 7 mod 26, because (7 * 7) % 26 = 23. 

‚Ä¢ 8 is not the modular inverse of 7 mod 26, because (7 * 8) % 26 = 4. 

‚Ä¢ 9 is not the modular inverse of 7 mod 26, because (7 * 9) % 26 = 1 1 . 

‚Ä¢ 10 is not the modular inverse of 7 mod 26, because (7 * 10) % 26 = 18. 

‚Ä¢ 1 1 is not the modular inverse of 7 mod 26, because (7 * 1 1) % 26 = 25. 

‚Ä¢ 12 is not the modular inverse of 7 mod 26, because (7 * 12) % 26 = 6. 

‚Ä¢ 13 is not the modular inverse of 7 mod 26, because (7 * 13) % 26 = 13. 

‚Ä¢ 14 is not the modular inverse of 7 mod 26, because (7 * 14) % 26 = 20. 

‚Ä¢ 15 is the modular inverse of 7 mod 26, because (7 * 15) % 26 = 1. 

So the affine cipher decryption key is 15. To decrypt a ciphertext letter, we take that letter's 
number and multiply it by 15, and then mod 26. This will be the number of the original 
plaintext's letter. 

Finding Modular Inverses 

In order to calculate the modular inverse to get the decryption key, we could take a brute -force 
approach and start testing the integer 1, and then 2, and then 3, and so on like we did above. But 
this will be very time-consuming for large keys like 8,953,851. 

There is an algorithm for finding the modular inverse just like there was for finding the Greatest 
Common Divisor. Euclid's Extended Algorithm can be used to find the modular inverse of a 
number: 



def f i ndModInverse(a, m) : 
if gcd(a, m) != 1: 

return None # no mod inverse exists if a &amp; m aren't relatively prime 
ul, u2, u3 = 1, 0, a 
vl, v2, v3 = 0, 1, m 
while v3 != 0: 

q = u3 // v3 # // is the integer division operator 

vl, v2, v3, ul, u2, u3 = (ul - q * vl) , (u2 - q * v2) , (u3 - q * v3) , 
vl, v2 , v3 

return ul % m 

You don't have to understand how Euclid's Extended Algorithm works in order to make use of it. 
We're just going to have our programs call this function. If you'd like to learn more about how it 
works, you can read http;//inypy.coirV.euclid. 



210 http://inventwithpython.com/hacking 



The // Integer Division Operator 

You may have noticed the / / operator used in the f indModlnverse ( ) function above. This 
is the integer division operator. It divides two numbers and rounds down. Try typing the 
following into the interactive shell: 



¬ª&gt; 41 // 7 
5 

¬ª&gt; 41/7 
5.857142857142857 

¬ª&gt; 10 // 5 
2 

¬ª&gt; 10 / 5 
2.0 

¬ª&gt; 



Notice that an expression with the / / integer division operator always evaluates to an int, not a 
float. 

Source Code of the cryptomath Module 

The gcd ( ) and f indModlnverse ( ) functions will be used by more than one of our cipher 
programs later in this book, so we should put this code into a separate module. In the file editor, 
type in the following code and save it as cryptomath.py: 







Source code for cryptomath.py 


1. 


# Cryptomath Module 


2. 
3. 


# http://inventwithpython.com/hacknng (BSD Licensed) 


4. 


def 


gcd(a, b) : 


5. 




# Return the GCD of a and b using Euclid's Algorithm 


6. 




while a != 0: 


7. 




a, b = b % a, a 


8. 
9. 




return b 


10. 






11. 


def 


f i ndModInverse(a, m) : 


12. 




# Returns the modular inverse of a % m, which is 


13. 




# the number x such that a*x % m = 1 


14. 






15. 




if gcd(a, m) != 1: 


16. 




return None # no mod inverse if a &amp; m aren't relatively prime 


17. 






18. 




# Calculate using the Extended Euclidean Algorithm: 



Email questions to the author: al@inventwithpython.com 



Chapter 14 - Modular Arithmetic and the Multiplicative Cipher 211 



19. 


ul, u2, u3 = 1, 0, 


a 




20. 


vl, v2, v3 = 0, 1, 


m 




21. 


while v3 != 0: 






22. 


q = u3 // v3 # 


// is the 


integer division operator 


23. 


vl, v2 , v3, ul 


u2, u3 = 


(ul - q * vl), (u2 - q * v2) , (u3 - q * 


v3), 


vl, v2 , v3 






24. 


return ul % m 







The GCD algorithm is described earlier in this chapter. The f indModlnverse ( ) function 
implements an algorithm called Euclid's Extended Algorithm. How these functions work is 
beyond the scope of this book, but you don't have to know how the code works in order to make 
use of it. 



From the interactive shell, you can try out these functions after importing the module. Try typing 
the following into the interactive shell: 



¬ª&gt; import cryptomath 

¬ª&gt; cryptomath. gcd (24, 32) 

8 

¬ª&gt; cryptomath. gcd (37, 41) 
1 

¬ª&gt; cryptomath . fi ndModInverse(7 , 26) 
15 

¬ª&gt; cryptomath. findModInverse(8953851, 26) 
17 

¬ª&gt; 



Practice Exercises, Chapter 14, Set E 

Practice exercises can be found at http://inypy.co^^ 

Summary 

Since the multiplicative cipher is the same thing as the affine cipher except using Key B of 0, we 
won't have a separate program for the multiplicative cipher. And since it is just a less secure 
version of the affine cipher, you shouldn't use it anyway. The source code to our affine cipher 
program will be presented in the next chapter. 

The math presented in this chapter isn't so hard to understand. Modding with the % operator finds 
the "remainder" between two numbers. The Greatest Common Divisor function returns the 
largest number that can divide two numbers. If the GCD of two numbers is 1, we say that those 
numbers are "relatively prime" to each other. The most useful algorithm to find the GCD of two 
numbers is Euclid's Algorithm. 



212 http://inventwithpython.com/hacking 



The affine cipher is sort of like the Caesar cipher, except it uses multiplication instead of addition 
to encrypt letters. Not all numbers will work as keys though. The key number and the size of the 
symbol set must be relatively prime towards each other. 

To decrypt with the affine cipher we also use multiplication. To decrypt, the modular inverse of 
the key is the number that is multiplied. The modular inverse of "a mod m" is a number i such 
that (a * i) % m == 1 . To write a function that finds the modular inverse of a number, we 
use Euclid's Extended Algorithm. 

Once we understand these math concepts, we can write a program for the affine cipher in the next 
chapter. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 5 - The Affine Cipher 2 1 3 



Chapter 15 



The Affine Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The Affine Cipher 

‚Ä¢ Generating random keys 

‚Ä¢ How many different keys can the affine cipher have? 



"I should be able to whisper something in your ear, 
even if your ear is 1000 miles away, and the 
government disagrees with that." 

Philip Zimmermann, creator of Pretty Good Privacy (PGP), the 
most widely used email encryption software in the world. 

This chapter's programs implement the multiplicative and affine ciphers. The multiplicative 
cipher is like the Caesar cipher from Chapter 6, except it uses multiplication instead of addition. 
The affine cipher is the multiplicative cipher, which is then encrypted by the Caesar cipher on top 
of that. The affine cipher needs two keys: one for the multiplicative cipher multiplication and the 
other for the Caesar cipher addition. 

For the affine cipher program, we will use a single integer for the key. We will use some simple 
math to split this key into the two keys, which we will call Key A and Key B. 




214 http://inventwithpython.com/hacking 



Source Code of the Affine Cipher Program 

How the affine cipher works was covered in the last chapter. Here is the source code for a Python 
program that implements the affine cipher. Open a new file editor window by clicking on File ‚ñ∫ 
New Window. Type in the following code into the file editor, and then save it as ajfineCipher.py . 
Press F5 to run the program. Note that first you will need to download the pyperclip.py module 
and place this file in the same directory as the ajfineCipher.py file. You can download this file 
from http://inypy.co 



Source code for aff i neCi pher . py 

1. # Affi ne Ci pher 

2. # http://inventwithpython.com/hacklng (BSD Licensed) 
3. 

4. import sys, pyperclip, cryptomath, random 

5. SYMBOLS = """ !"#$%&amp;'()*+,-. /0123456789: ; &lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\] 
A_'abcdefghi jklmnopqrstuvwxyz{ | }~ # note the space at the front 

6. 
7. 

8. def main() : 

9. myMessage = """"a computer would deserve to be called intelligent if it 
could deceive a human into believing that it was human." -Alan Turing""" 

10. myKey = 2023 

11. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 
12. 

13. if myMode == 'encrypt': 

14. translated = encryptMessage(myKey , myMessage) 

15. el if myMode == 'decrypt': 

16. translated = decryptMessage(myKey , myMessage) 

17. print('Key: %s ' % (myKey)) 

18. print('%sed text:' % (myMode. title())) 

19. pri nt(transl ated) 

20. pyperclip. copy (transl ated) 

21. print('Full %sed text copied to clipboard.' % (myMode)) 
22. 

23. 

24. def getKeyParts(key) : 

25. keyA = key // 1 en (SYMBOLS) 

26. keyB = key % 1 en (SYMBOLS) 

27. return (keyA, keyB) 
28. 

29. 

30. def checkKeys(keyA, keyB, mode): 

31. if keyA == 1 and mode == 'encrypt': 

32. sys .exit( 'The affine cipher becomes incredibly weak when key A is 
set to 1. Choose a different key.') 



Email questions to the author: al@inventwithpython.com 



Chapter 1 5 - The Affine Cipher 2 1 5 



33. if keyB == 0 and mode == 'encrypt': 

34. sys .exit ( 'The affine cipher becomes incredibly weak when key B is 
set to 0. Choose a different key.') 

35. if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; 1 en (SYMBOLS) - 1: 

36. sys.exit('Key A must be greater than 0 and Key B must be between 0 
and %s.' % (1 en (SYMBOLS) - 1)) 

37. if cryptomath.gcd(keyA, 1 en (SYMBOLS)) != 1: 

38. sys.exit('Key A (%s) and the symbol set size (%s) are not 



relatively prime. Choose a different key.' % (keyA, len(SYMBOLS))) 



39. 
40. 

41. def encryptMessage(key , message): 

42. keyA, keyB = getKeyParts(key) 

43. checkKeys(keyA, keyB, 'encrypt') 

44. ci phertext = ' ' 

45. for symbol in message: 

46. if symbol in SYMBOLS: 

47. # encrypt this symbol 

48. symlndex = SYMBOLS. find (symbol) 

49. ciphertext += SYMBOLS [(symlndex * keyA + keyB) % 1 en (SYMBOLS)] 

50. else: 

51. ciphertext += symbol # just append this symbol unencrypted 

52. return ciphertext 
53. 

54. 

55. def decryptMessage(key, message): 

56. keyA, keyB = getKeyParts(key) 

57. checkKeys(keyA, keyB, 'decrypt') 

58. plaintext = ' ' 

59. modlnverseOfKeyA = cryptomath . f i ndModInverse(keyA, len(SYMBOLS)) 

60. 

61. for symbol in message: 

62. if symbol in SYMBOLS: 

63. # decrypt this symbol 

64. symlndex = SYMBOLS. find (symbol) 

65. plaintext += SYMBOLS [(symlndex - keyB) * modlnverseOfKeyA % 
1 en (SYMBOLS)] 

66. else: 

67. plaintext += symbol # just append this symbol undecrypted 

68. return plaintext 
69. 

70. 

71. def getRandomKeyO : 

72 . whi 1 e True : 

73. keyA = random. randint(2 , len(SYMBOLS)) 

74. keyB = random. randint(2 , 1 en (SYMBOLS)) 



216 


http://inventwithpython.com/hacking 


75. 


-if cryptomath.gcdCkeyA, 1 en (SYMBOLS)) == 1: 


76. 


return keyA * Ten (SYMBOLS) + keyB 


77. 




78. 




79. 


# If affineCipher.py is run (instead of imported as a module) call 


80. 


# the main() function. 


81. 


if name == 1 main ': 


82. 


mainQ 



Sample Run of the Affine Cipher Program 

When you press F5 from the file editor to run this program, the output will look like this: 



Key: 2023 
Encrypted text: 

f X&lt;* h&gt;} ( rTH&lt;Rh () ?&lt;?T] TH=T&lt;rh&lt;tT&lt;*_))T?&lt;ISrT) ) I~TS r&lt;Ii &lt;I r&lt;* h () ?&lt;?T*TI=T&lt;_&lt;4 (&gt;_S&lt; 

ISrh&lt;tT)IT=IS~&lt;r4_r&lt;Ir&lt;R_]&lt;4(&gt;_SEf&lt;0X)_S&lt; 

k(HIS~ 

Full encrypted text copied to clipboard. 

The message ""A computer would deserve to be called intelligent if it could deceive a human into 
believing that it was human." -Alan Turing" gets encrypted with the key 2023 into the above 
ciphertext. 

To decrypt, paste this text as the new value to be stored in myMes sage and change myMode to 
the string 'decrypt ' . 

Practice Exercises, Chapter 15, Set A 

Practice exercises can be found at http://inypy.co^ 

How the Program Works 

affineCipher.py 

1. # Affi ne Ci pher 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import sys, pyperclip, cryptomath, random 

5. SYMBOLS = """ !"#$%&amp;'()*+,-./0123456789: ; &lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\] 
A_'abcdefghi jklmnopqrstuvwxyz{ | }~ # note the space at the front 

Lines 1 and 2 are the usual comments describing what the program is. There is also an import 
statement for the modules used in this program. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 5 - The Affine Cipher 2 1 7 



‚Ä¢ The sys module is imported for the exit ( ) function. 

‚Ä¢ The pyperclip module is imported for the copy ( ) clipboard function. 

‚Ä¢ The crypto math module that we created in the last chapter is imported for the gcd ( ) 

and f indModlnverse ( ) function. 

In our program, the string stored in the SYMBOLS variable is the symbol set. The symbol set is 
the list of all characters that can be encrypted. Any characters in the message to be encrypted that 
don't appear in SYMBOLS will be added to the ciphertext unencrypted. 



affineCipher.py 

8. def mainO : 

9. myMessage = """"A computer would deserve to be called intelligent if it 
could deceive a human into believing that it was human." -Alan Turing""" 

10. myKey = 2023 

11. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 



The main ( ) function is almost exactly the same as the one from the transposition cipher 
programs. The message, key, and mode are stored in variables on lines 9, 10, and 11. 









affineCipher.py 


13. 


if myMode == 'encrypt': 






14. 


translated = encryptMessage(myKey , 


myMessage) 




15. 


elif myMode == 'decrypt': 






16. 


translated = decryptMessage(myKey , 


myMessage) 





If myMode is set to ' encrypt ' , then line 14 will be executed and the return value of 
encryptMessage ( ) is stored in translated. Or else, if myMode is set to ' decrypt ' , 
then decryptMessage ( ) is called on line 16 and the return value is stored in translated. 



Either way, after the execution has passed line 16, the translated variable will have the 
encrypted or decrypted version of the message in myMes sage. 









affineCipher.py 


17. 


printC'Key: %s' % (myKey)) 






18. 


print('%sed text:' % (myMode. titleO)) 






19. 


pri nt(transl ated) 






20. 


pypercl i p . copy (transl ated) 






21. 


pri nt(' Full %sed text copied to clipboard.' 


% (myMode)) 





The string in translated (which is the encrypted or decrypted version of the string in 
myMessage) is displayed on the screen on line 19 and copied to the clipboard on line 20. 



218 http://inventwithpython.com/hacking 



Splitting One Key into Two Keys 







affineCipher.py 


24. 


def getKeyParts(key) : 




25. 


keyA = key // 1 en (SYMBOLS) 




26. 


keyB = key % 1 en (SYMBOLS) 




27. 


return (keyA, keyB) 





The affine cipher is like the Caesar cipher, except that it uses multiplication and addition (with 
two integer keys, which we called Key A and Key B) instead of just addition (with one key). It's 
easier to remember just one number, so we will use a mathematical trick to convert between two 
keys and one key. 



The getKeyParts ( ) function splits a single integer key into two integers for Key A and Key 
B. The single key (which is in the parameter key) is divided by the size of the symbol set, and 
Key A is the quotient and Key B is the remainder. The quotient part (without any remainder) can 
be calculated using the / / integer division operator, which is what line 25 does. The remainder 
part (without the quotient) can be calculated using the % mod operator, which is what line 26 
does. 

It is assumed that the symbol set, as well as the size of the symbol set, is publicly known along 
with the rest of the source code. 

For example, with 2 023 as the key parameter and a SYMBOLS string of 95 characters, Key A 
wouldbe 2023 // 95 or 21 and Key B would be 2023 % 95 or 28. 

To combine Key A and Key B back into the single key, multiply Key A by the size of the symbol 
set and add KeyB: (21 * 95) + 2 8 evaluates to 2 0 2 3 . 



The Tuple Data Type 







affineCipher.py 


27. 


return (keyA, keyB) 





A tuple value is similar to a list: it is a value that can store other values, which can be accessed 
with indexes or slices. However, the values in a tuple cannot be modified. There is no 
append ( ) method for tuple values. A tuple is written using parentheses instead of square 
brackets. The value returned on line 27 is a tuple. 



For technical reasons beyond the scope of this book, the Python interpreter can execute code 
faster if it uses tuples compared to code that uses lists. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 5 - The Affine Cipher 2 1 9 



Input Validation on the Keys 







affineCipher.py 


30. 


def checkKeys(keyA, keyB, mode): 




31. 


if keyA == 1 and mode == 'encrypt': 




32. 


sys .exit ( 'The affine cipher becomes 


incredibly weak when key A is 


set 


to 1. Choose a different key.') 




33. 


if keyB == 0 and mode == 'encrypt': 




34. 


sys.exit('The affine cipher becomes 


incredibly weak when key B is 


set 


to 0. Choose a different key.') 





Encrypting with the affine cipher involves a character's index in SYMBOLS being multiplied by 
Key A and added to Key B. But if keyA is 1, the encrypted text will be very weak because 
multiplying the index by 1 does not change it. Similarly, if keyB is 0, the encrypted text will be 
weak because adding the index to 0 does not change it. And if both keyA was 1 and keyB was 
0, the "encrypted" message would be the exact same as the original message. It wouldn't be 
encrypted at all! 

The if statements on line 31 and 33 check for these "weak key" conditions, and exit the program 
with a message telling the user what was wrong. Notice on lines 32 and 34, a string is being 
passed to the sys . exit ( ) call. The sys . exit ( ) function has an optional parameter of a 
string that will be printed to the screen before terminating the program. This can be used to 
display an error message on the screen before the program quits. 

Of course, these checks only apply to prevent you from encrypting with weak keys. If mode is set 
to ' decrypt ' , then the checks on lines 3 1 and 33 don't apply. 



affineCipher.py 

35. if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; 1 en (SYMBOLS) - 1: 

36. sys.exit('Key A must be greater than 0 and Key B must be between 0 
and %s.' % (1 en (SYMBOLS) - 1)) 

The condition on line 35 checks if keyA is a negative number (that is, it is greater than 0) or if 
keyB is greater than 0 or less than the size of the symbol set minus one. (The reason the Key B 
check has this range is described later in the "How Many Keys Does the Affine Cipher Have?" 
section.) If any of these things are True, the keys are invalid and the program exits. 



affineCipher.py 

37. if cryptomath.gcd(keyA, 1 en (SYMBOLS)) != 1: 

38. sys.exit('Key A (%s) and the symbol set size (%s) are not 
relatively prime. Choose a different key.' % (keyA, len(SYMBOLS))) 



220 http://inventwithpython.com/hacking 



Finally, Key A must be relatively prime with the symbol set size. This means that the greatest 
common divisor of keyA and len (SYMBOLS ) must be equal to 1. Line 37's if statement 
checks for this and exits the program if they are not relatively prime. 

If all of the conditions in the checkKeys ( ) function were False, there is nothing wrong with 
the key and the program will not exit. Line 38 is the last line in the function, so the program 
execution next returns to the line that originally called checkKeys ( ) . 



The Affine Cipher Encryption Function 







affineCipher.py 


41. 


def encryptMessage(key, message): 




42. 


keyA, keyB = getKeyParts(key) 




43. 


checkKeys(keyA, keyB, 'encrypt') 





First we get the integer values for Key A and Key B from the getKeyParts ( ) function. These 
values are checked if they are valid keys or not by passing them to the checkKeys ( ) function. 
If the checkKeys ( ) function does not cause the program to exit, then the rest of the code in the 
encryptMessage ( ) function after line 43 can assume that the keys are valid. 







affineCipher.py 


44. 


ci phertext = ' ' 




45. 


for symbol "in message: 





The ciphertext variable will eventually hold the encrypted string, but starts off as a blank 
string. The for loop that begins on line 45 will iterate through each of the characters in 
message, and then add the encrypted character to ciphertext. By the time the for loop is 
done looping, the ciphertext variable will have the complete string of the encrypted message. 







affineCipher.py 


46. 


-if symbol in SYMBOLS: 




47. 


# encrypt this symbol 




48. 


symlndex = SYMBOLS. find (symbol) 




49. 


ciphertext += SYMBOLS [(symlndex * keyA + keyB) 


% I en (SYMBOLS)] 


50. 


else: 




51. 


ciphertext += symbol # just append this symbol 


unencrypted 



On each iteration of the loop, the symbol variable is assigned the single character from 
message. If this character exists in SYMBOLS (that is, our symbol set), then the index in 
SYMBOLS is found and assigned to symlndex. The value in symlndex is the "number" 
version of the character. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 5 - The Affine Cipher 22 1 



To encrypt it, we need to calculate the index of the encrypted letter. We multiply this sym Index 
by keyA and add keyB, and mod the number by the size of the symbol set (that is, the 
expression len ( SYMBOLS ) ). We mod by len ( SYMBOLS ) because the affine cipher has a 
similar "wrap-around" issue that the Caesar cipher had. Modding by len ( SYMBOLS ) handles 
the "wrap-around" by ensuring the calculated index is always between 0 up to (but not including) 
len ( SYMBOLS ) . The number that we calculate will be the index in SYMBOLS of the encrypted 
character, which is concatenated to the end of the string in ciphertext. 

Everything that happens in the above paragraph was done on line 49. 



If symbol was not in our symbol set, then symbol is concatenated to the end of the 
ciphertext string on line 51. 







affineCipher.py 


52. 


return ciphertext 





Once we have iterated through each character in the message string, the ciphertext variable 
should contain the full encrypted string. This string is returned from encryptMessage ( ) . 



The Affine Cipher Decryption Function 







affineCipher.py 


55. 


def decryptMessage(key , message): 




56. 


keyA, keyB = getKeyParts(key) 




57. 


checkKeys(keyA, keyB, 'decrypt') 




58. 


pi ai ntext = ' ' 




59. 


modlnverseOfKeyA = cryptomath . fi ndMod!nverse(keyA, 


Ten (SYMBOLS)) 



The decryptMessage ( ) function is almost the same as the encryptMessage ( ) . Lines 56 
to 58 are equivalent to lines 44 to 46. 



However, instead of multiplying by Key A, the decryption process needs to multiply by the 

modular inverse of Key A. The mod inverse can be calculated by calling 

cryptomath . f indModlnverse ( ) . This function was explained in the previous chapter. 





affineCipher.py 


61. for symbol in message: 




62. if symbol in SYMBOLS: 




63. # decrypt this symbol 




64. symlndex = SYMBOLS . fi nd(symbol ) 




65. plaintext += SYMBOLS [(symlndex - 


keyB) * modlnverseOfKeyA % 


len (SYMBOLS)] 





222 http://inventwithpython.com/hacking 



66. else: 

67. plaintext += symbol # just append this symbol undecrypted 

68. return plaintext 

Lines 61 to 68 are almost identical to the encryptMessage ( ) function's lines 45 to 52. The 
only difference is on line 65. In the encryptMessage ( ) function, the symbol index was 
multiplied by Key A and then had Key B added to it. In decryptMessage ( ) 's line 65, the 
symbol index first has Key B subtracted from it, and then is multiplied by the modular inverse. 
Then this number is modded by the size of the symbol set, len (SYMBOLS ) . This is how the 
decryption process undoes the encryption. 

Generating Random Keys 

It can be difficult to come up with a valid key for the affine cipher, so we will create a 
getRandomKey ( ) function that generates a random (but valid) key for the user to use. To use 
this, the user simply has to change line 10 to store the return value of getRandomKey ( ) in the 
myKey variable: 







affineCipher.py 


10. 


myKey = getRandomKey () 





Now the key that is used to encrypt is randomly selected for us. It will be printed to the screen 
when line 17 is executed. 











affineCipher.py 


71. 


def getRandomKeyO : 








72. 


while True: 








73. 


keyA = random 


randi nt(2 , 


len (SYMBOLS)) 




74. 


keyB = random 


randi nt(2 , 


len (SYMBOLS)) 





The code in getRandomKey ( ) enters a while loop on line 72 where the condition is True. 
This is called an infinite loop, because the loop's condition is never False. If your program 
gets stuck in an infinite loop, you can terminate it by pressing Ctrl-C or Ctrl-D. 



The code on lines 73 and 74 determine random numbers between 2 and the size of the symbol set 
for keyA and for keyB. This way there is no chance that Key A or Key B are equal to the invalid 
values 0 or 1. 







affineCipher.py 


75. 


if cryptomath.gcd(keyA, len (SYMBOLS)) == 1: 




76. 


return keyA * len (SYMBOLS) + keyB 





Email questions to the author: al@inventwithpython.com 



Chapter 15 - The Affine Cipher 223 



The if statement on line 75 checks to make sure that keyA is relatively prime with the size of 
the symbol set by calling the gcd ( ) function in the cryptomath module. If it is, then these 
two keys are combined into a single key by multiplying keyA by the symbol set size and adding 
keyB. (This is the opposite of what the getKeyParts ( ) function does.) This value is returned 
from the getRandomKey ( ) function. 



If the condition on line 75 was False, then the code loops back to the start of the while loop 
on line 73 and picks random numbers for keyA and keyB again. The infinite loop ensures that 
the program keeps looping again and again until it finds random numbers that are valid keys. 







affi neCipher.py 


79. 


# If affi neCi pher. py is run 


("instead of imported as a module) call 


80. 


# the mainO function. 




81. 


"if name == ' main ': 




82. 


mai n() 





Lines 81 and 82 call the main ( ) function if this program was run by itself, rather than imported 
by another program. 



The Second Affine Key Problem: How Many Keys Can the Affine 
Cipher Have? 

Key B of the affine cipher is limited to the size of the symbol set (in the case of affineCipher.py, 
len ( SYMBOLS ) is 95). But it seems like Key A could be as large as we want it to be (as long as 
it is relatively prime to the symbol set size). Therefore the affine cipher should have an infinite 
number of keys and therefore cannot be brute -forced. 

As it turns out, no. Remember how large keys in the Caesar cipher ended up being the same as 
smaller keys due to the "wrap-around" effect. With a symbol set size of 26, the key 2 7 in the 
Caesar cipher would produce the same encrypted text as the key 1 . The affine cipher also "wraps 
around". 

Since the Key B part of the affine cipher is the same as the Caesar cipher, we know it is limited 
from 1 to the size of the symbol set. But to find out if the affine cipher's Key A is also limited, we 
can write a small program to encrypt a message with several different integers for Key A and see 
what the ciphertext looks like. 

Open a new file editor window and type the following source code. Save this file as 
qffineKeyTest.py, and then press F5 to run it. 



224 http://inventwithpython.com/hacking 



Source code for affi neKeyTest . py 

1. # This program proves that the keyspace of the affine cipher is limited 

2. # to 1 en (SYMBOLS) a 2. 
3. 

4. import affi neCi pher , cryptomath 
5. 

6. message = 'Make things as simple as possible, but not simpler.' 

7. for keyA in range(2, 100): 

8. key = keyA * 1 en (affineCi pher. SYMBOLS) + 1 
9. 

10. if cryptomath.gcd(keyA, 1 en (affi neCi pher . SYMBOLS)) == 1: 

11. print(keyA, affineCipher.encryptMessage(key, message)) 



This is a fairly simple program. It imports the affineCi pher module for its 
encryptMessage ( ) function and the cryptomath module for its gcd ( ) function. We will 
always encrypt the string stored in the message variable. The for loop will range between 2 
(since 0 and 1 are not allowed as valid Key A integers) and 10 0. 

On each iteration of the loop, we calculate the key from the current keyA value and always use 1 
for Key B (this is why 1 is added on line 8). Remember that it is not valid to use a Key A that is 
not relatively prime with the symbol set size. So if the greatest common divisor of the key and the 
symbol set size is not equal to 1, the if statement on line 10 will skip the call to 
encryptMessage ( ) online 11. 

Basically, this program will print out the same message encrypted with several different integers 
for Key A. The output of this program will look like this: 



2 {DXL ! j RTAPh ! Dh ! hT\bZL ! Dh ! b ' hhTFZL9 ! Fl j ! A ' j \ hT\bZLf = 

3 I&amp;D2!_;&gt;M8\!&amp;\!\&gt;lSG2!&amp;\!SP\\&gt;)C2E!)b_!MP_!\&gt;:SC2YK 

4 vg0w!T$(&lt; P! gP! P(8D4w! gP! D@PP(k4wQ! kXT! &lt;@T! P(8D4wLY 
6 q+gC!&gt;U[y08!+8!8[s&amp;mC!+8!&amp; 88 [lmCi ! 1D&gt; ! y &gt;!8[s&amp;mC2u 

. . .skipped for brevity. . . 



92 


X{]o 


Bf cTi E 


{ElEcWNZo 


{E 


NQEEcxZo\ 


x?B!TQB 


EcWNZoHV 


93 


&amp;]IU 


70MCQ9 


]9!9ME?CU 


19 


?A99M[CUh 


[57ICA7 


9ME?GU;d 


94 


S?5; 


,8729- 


?-!-7304; 


?- 


01‚Äî 7&gt;4;t 


&gt;+,!21, 


-7304; .r 


96 


Nblf 


ui joht 


bt ! tjnqmf 


bt 


qpttjcmf- 


cvu !opu 


tjnqmf s/ 


97 


{DXL 


j RTAPh 


Dh ! hT\bZL 


Dh 


b'hhTFZL9 


FT j ! A j 


hT\bZLf= 


98 


I&amp;D2 


_;&gt;M8\ 


&amp;\!\&gt;:SG2 


&amp;\ 


SP\\&gt;)G2E 


)b_!MP_ 


\&gt;IISG2YK 


99 


vgOw 


T$(&lt; P 


gP!P(8D4w 


gP 


D@PP(k4wQ 


kXT ! &lt;@T 


P(8D4wLY 



Email questions to the author: al@inventwithpython.com 



Chapter 15 - The Affine Cipher 225 



Look carefully at the output. You'll notice that the ciphertext for Key A of 2 is the exact same as 
the ciphertext for Key A of 97 ! In fact, the ciphertext from keys 3 and 98 are the same, as are the 
ciphertext from keys 4 and 9 9 ! 

Notice that 97 - 95 is 2. This is why a Key A of 9 7 does the same thing as a Key A of 2 : the 
encrypted output repeats itself (that is, "wraps around") every 95 keys. The affine cipher has the 
same "wrap-around" for the Key A as it does for Key B! It seems like it is limited to the symbol 
set size. 

95 possible Key A keys multiplied by 95 possible Key B keys means there are 9,025 possible 
combinations. If you subtract the integers that can't be used for Key A (because they are not 
relatively prime with 95), this number drops to 7,125 possible keys. 

Summary 

7,125 is about the same number of keys that's possible with most transposition cipher messages, 
and we've already learned how to program a computer to hack that number of keys with brute- 
force. This means that we'll have to toss the affine cipher onto the heap of weak ciphers that are 
easily hacked. 

The affine cipher isn't any more secure than the previous ciphers we've looked at. The 
transposition cipher can have more possible keys, but the number of possible keys is limited to 
the size of the message. For a message with only 20 characters, the transposition cipher can only 
have at most 18 keys (the keys 2 to 19). The affine cipher can be used to encrypt short messages 
with more security than the Caesar cipher provided, since its number of possible keys is based on 
the symbol set. 

But we did learn some new mathematical concepts that we will use later on. The concepts of 
modular arithmetic, greatest common divisor, and modular inverses will help us in the RSA 
cipher at the end of this book. 

But enough about how the affine cipher is weak in theory. Let's write a brute-force program that 
can actually break affine cipher encrypted messages! 



226 http://inventwithpython.com/hacking 




Chapter 16 



Hacking the Affine Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The * * Exponent Operator 

‚Ä¢ The continue Statement 



We know that the affine cipher is limited to only a few thousand keys. This means it is trivial to 
perform a brute-force attack against it. Open a new File Editor and type in the following code. 
Save the file as affineHacker.py . 

Source Code of the Affine Cipher Hacker Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as affineHacker.py. Press F5 to run the program. Note that 
first you will need to download the pyperclip.py module and place this file in the same directory 
as the affineHacker.py file. You can download this file from http://inypy,cor^pyperclip,py. 

Typing the string for the myMes sage variable might be tricky, but you can copy and paste it 
from \Mvy!!\^^l^^-^^^^^^yi-^- to save time. 



Source Code for affineHacker.py 

1. # Affine Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip, aff i neCi pher , detectEngl i sh , cryptomath 

5. 

6. SILENT_MODE = False 
7. 



Email questions to the author: al@inventwithpython.com 



Chapter 1 6 - Hacking the Affine Cipher 227 



8. def main() : 

9. # You might want to copy &amp; paste this text from the source code at 
10. # http://invpy.com/affineHacker.py 

myMessage = "" "U&amp; 1 &lt;3dJAGjx ' -3AMS ' SjOjxu j ' C3 ' %j 1 &lt;mMMjS 1 g{GjMMg9j {C ' g" ' gC 
' &lt;3AMS ' Sj&lt;jgu j ' m' PAdm{ ' g{G3 '%jMgjug{9 ' CPmC ' gG ' -mO ' PAdm{LU ' 5&amp;Mm{ '_A X g{9 
12. 

13. hackedMessage = hackAffi ne(myMessage) 
14. 

15. if hackedMessage != None: 

16. # The plaintext is displayed on the screen. For the convenience of 

17. # the user, we copy the text of the code to the clipboard. 

18. printC'Copying hacked message to clipboard:') 

19. pri nt(hackedMessage) 

20 . pypercl i p . copy(hackedMessage) 

21. else: 

22. pri nt( 1 Fai 1 ed to hack encryption. 1 ) 
23. 

24. 

25. def hackAffi ne (message) : 

26. print('Hacking. . . ') 
27. 

28. # Python programs can be stopped at any time by pressing Ctrl-C (on 

29. # Windows) or Ctrl-D (on Mac and Linux) 

30. printC (Press Ctrl-C or Ctrl-D to quit at any time.)') 
31. 

32. # brute-force by looping through every possible key 

33. for key in ranged en (affineCipher. SYMBOLS) ** 2): 

34. keyA = affineCipher. getKeyParts(key) [0] 

35. if cryptomath.gcd(keyA, 1 en(affi neCi pher . SYMBOLS)) != 1: 

36. continue 
37. 

38. decryptedText = affineCipher. decryptMessage(key, message) 

39. if not SILENT_M0DE : 

print('Tried Key%s... (%s) ' % (key, decryptedText[:40])) 

41. 

42. if detectEnglish.isEnglish(decryptedText) : 

43. # Check with the user if the decrypted key has been found. 

44. printO 

45. pri nt( ' Possi bl e encryption hack:') 

46. print('Key: %s' % (key)) 

47. pri nt(' Decrypted message: ' + decryptedText [: 200]) 

48. print() 

49. print('Enter D for done, or just press Enter to continue 
hacking: ') 

50. response = input('&gt; ') 
51. 



228 


http://inventwithpython.com/hacking 


52. 


if response. stripO .upperO .startswith('D') : 


53. 


return decryptedText 


54. 


return None 


55. 




56. 




57. 


# If af f i neHacker . py is run (instead of imported as a module) call 


58. 


# the main() function. 


59. 


if name == ' main ': 


60. 


mainQ 



Sample Run of the Affine Cipher Hacker Program 

When you press F5 from the file editor to run this program, the output will look like this: 



Hacki ng . . . 

(Press Ctrl-C or Ctrl-D to quit at any time.) 
Tried Key 95... (U&amp; 1 &lt;3dJAGjx ' -3AMS 1 SjOjxu j 1 G3 '%j 1 &lt;mMMjS ' g) 
Tried Key 96... (T%&amp;; 2cl] Fi w&amp;, 2] LR&amp;Ri/iwti&amp;F2&amp;$i&amp;; 1 LLi R&amp;f ) 
Tried Key 97... (S$%: lbH\Ehv%+l\KQ%Qh . hvsh%El%#h%: kKKhQ%e) 

. . .skipped for brevity. . . 

Tried Key 2190... (?a= ! -+. 32#0=5-3*"="#l#04#=2-= #=!-**#"=') 
Tried Key 2191... C ABNLOTSDQAVNTKCACDRDQUDASNAADAB@KKDCAH) 
Tried Key 2192... ("A computer would deserve to be called i) 

Possible encryption hack: 
Key: 2192 

Decrypted message: "A computer would deserve to be called intelligent if it 
could deceive a human into believing that it was human." -Alan Turing 

Enter D for done, or just press Enter to continue hacking: 
&gt; d 

Copying hacked message to clipboard: 

"A computer would deserve to be called intelligent if it could deceive a human 
into believing that it was human." -Alan Turing 



How the Program Works 







affi neHacker. py 


1. 


# Affine Cipher Hacker 




2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 

5. 


import pyperclip, aff i neCi pher , detectEngl i sh , cryptomath 





Email questions to the author: al@inventwithpython.com 



Chapter 1 6 - Hacking the Affine Cipher 229 



6. SILENT_MODE = False 

Our affine cipher hacking program fits in 60 lines of code because we've already written much of 
the code it uses. 

When you run the hacker program, you can see that this program produces a lot of output as it 
works its way through all the possible decryptions. However, printing out this input does slow 
down the program. If you change line 6 to set the S ILENT_MODE variable to True, the program 
will be silenced and not print out all these messages. This will speed up the program immensely. 

But showing all that text while your hacking program runs makes it look cool. (And if you want 
your programs to look cool by printing out text slowly one character at a time for a "typewriter" 
effect, check out the typewriter.py module at http://inyp^ 



affineHacker.py 

8. def mainO : 



9. # You might want to copy &amp; paste this text from the source code at 

10. # http://invpy.com/affineHacker.py 

11. myMessage = """U&amp;'&lt;3d:ACjx ' -3AMS ' SjOjxuj 'C3 '%j ' &lt;mMMjS ' g{GjMMg9j {C ' g" ' gC 
' &lt;3AMS ' Sj&lt;jgu j ' m ' PAdm{ ' g{C3 ' %jMg j ug{9 ' CPmC ' gC ' -mO ' PAdm{LU ' 5&amp;Mm{ '_A X g{9" " " 

12. 

13. hackedMessage = hackAffi ne(myMessage) 

14. 

15. if hackedMessage != None: 

16. # The plaintext is displayed on the screen. For the convenience of 

17. # the user, we copy the text of the code to the clipboard. 

18. printC'Copying hacked message to clipboard:') 

19. pri nt(hackedMessage) 

20 . pypercl i p . copy(hackedMessage) 

21. else: 

22. pri nt(' Failed to hack encryption.') 



The ciphertext to be hacked is stored as a string in myMes sage, and this string is passed to the 
hackAf f ine ( ) function (described next). The return value from this call is either a string of 
the original message (if the ciphertext was hacked) or the None value (if the hacking failed). 

The code on lines 15 to 22 will check if hackedMessage was set to None or not. If 
hackedMessage is not equal to None, then the message will be printed to the screen on line 
19 and copied to the clipboard on line 20. Otherwise, the program will simply print that it was 
unable to hack the message. 



230 http://inventwithpython.com/hacking 

The Affine Cipher Hacking Function 

affineHacker.py 

25. def hackAffi ne (message) : 

26. pri nt(' Hacking. .. ') 
27. 

28. # Python programs can be stopped at any time by pressing Ctrl-C (on 

29. # Windows) or Ctrl-D (on Mac and Linux) 

30. pri nt( 1 (Press Ctrl-C or Ctrl-D to quit at any time.)') 

The hackAf f ine ( ) function has the code that does the decryption. This can take a while, so if 
the user wants to exit the program early, she can press Ctrl-C (on Windows) or Ctrl-D (on OS X 
and Linux). 

The ** Exponent Operator 

There is another math operator besides the basic +, -, *, /, and // operators. The ** operator is 
Python's exponent operator. This does "to the power of math on two numbers. For example, 
"two to the power of five" would be 2 * * 5 in Python code. This is equivalent to two 
multiplied by itself five times: 2 * 2 * 2 * 2 * 2 . Both the expressions 2 ** 5 and 2 * 
2 * 2 * 2 * 2 evaluate to the integer 32. 

Try typing the following into the interactive shell: 



¬ª&gt; 2 ** 6 
64 

¬ª&gt; 4** 2 
16 

¬ª&gt; 2** 4 
16 

¬ª&gt; 12 3* *10 
792594609605189126649 

¬ª&gt; 







affineHacker.py 


32. 


# brute-force by looping through every possible key 




33. 


for key in range(len(affineCipher. SYMBOLS) ** 2): 




34. 


keyA = affineCipher.getKeyParts(key) [0] 





The range of integers for the keys used to brute -force the ciphertext will range from 0 to the size 
of the symbol set to the second power. The expression: 



len (affineCipher. SYMBOLS) ** 2 



Email questions to the author: al@inventwithpython.com 



Chapter 16 - Hacking the Affine Cipher 23 1 



...is the same as: 

len (affineCipher. SYMBOLS) * len (af f ineCipher . SYMBOLS ) 

We multiply this because there are at most len (affineCipher . SYMBOLS ) possible integers 
for Key A and len (affineCipher . SYMBOLS ) possible integers for Key B. To get the 
entire range of possible keys, we multiply these values together. 

Line 34 calls the getKeyParts ( ) function that we made in affineCipher. py to get the Key A 
part of the key we are testing. Remember that the return value of this function call is a tuple of 
two integers (one for Key A and one for Key B). Since hackAf f ine ( ) only needs Key A, the 
[ 0 ] after the function call works on the return value to evaluate to just the first integer in the 
returned tuple. 

That is, affineCipher . getKeyParts (key) [0] will evaluate to (for example), the tuple 
(42, 2 2 ) [ 0 ] , which will then evaluate to 4 2 . This is how we can get just the Key A part of 
the return value. The Key B part (that is, the second value in the returned tuple) is just ignored 
because we don't need Key B to calculate if Key A is valid. 

The continue Statement 

The continue statement is simply the continue keyword by itself. A continue statement 
is found inside the block of a while or for loop. When a continue statement is executed, the 
program execution immediately jumps to the start of the loop for the next iteration. 

This is exactly the same thing that happens when the program execution reaches the end of the 
loop's block. But a continue statement makes the program execution jump back to the start of 
the loop early. 

Try typing the following into the interactive shell: 



&gt;¬ª for i in range(3): 
print(i) 
printC Hello! ') 

0 

Hello! 
1 

Hello! 
2 

Hello! 

¬ª&gt; 



232 http://inventwithpython.com/hacking 



This is pretty obvious. The for loop will loop through the range object, and the value in i 
becomes each integer between 0 and 4. Also on each iteration, the print (' Hello !' ) 
function call will display "Hello!" on the screen. 

Try typing in this code, which adds a continue statement before the print ( ' Hello ! ' ) 
line: 



¬ª&gt; for i in range(3): 
print(i) 
conti nue 
pn'ntC'Hello! ') 

0 
1 
2 

¬ª&gt; 

Notice that "Hello!" never appears, because the continue statement causes the program 
execution to jump back to the start of the for loop for the next iteration. So the execution never 
reaches the print ( ' Hello ! ' ) line. 

A continue statement is often put inside an if statement's block so that execution will 
continue at the beginning of the loop based on some condition. 



affineHacker.py 

35. if cryptomath.gcdCkeyA, 1 en(aff i neCi pher . SYMBOLS)) != 1: 

36. continue 

With the Key A integer stored in the variable keyA, line 35 uses the gcd ( ) function in our 
cryptomath module to determine if Key A is not relatively prime with the symbol set size. 
Remember, two numbers are relatively prime if their GCD (greatest common divisor) is one. 

If Key A and the symbol set size are not relatively prime, then the condition on line 35 is True 
and the continue statement on line 36 is executed. This will cause the program execution to 
jump back to the start of the loop for the next iteration. This way, the program will skip line 38's 
call to decryptMes sage ( ) if the key is invalid, and continue to the next key. 



affineHacker.py 

38. decryptedText = affineCipher.decryptMessage(key, message) 

39. if not SILENT_MODE : 

40. printC'Tried Key%s... (%s) ' % (key, decryptedText[:40])) 



Email questions to the author: al@inventwithpython.com 



Chapter 16 - Hacking the Affine Cipher 233 



The message is then decrypted with the key by calling decryptMessage ( ) . If 
S I LENT_MODE is False the "Tried Key" message will be printed on the screen. If 
SILENTJMODE was set to True, the print ( ) call on line 40 will be skipped. 





affineHacker.py 


42. 


if detectEnglish.isEnglish(decryptedText) : 


43. 


# Check with the user if the decrypted key has been found. 


44. 


printO 


45. 


printC Possible encryption hack:') 


46. 


printC'Key: %s' % (key)) 


47. 


printC Decrypted message: ' + decryptedText[:200]) 


48. 


printO 



Next, we use the isEnglish ( ) function from our detectEnglish module to check if the 
decrypted message is recognized as English. If the wrong decryption key was used, then the 
decrypted message will look like random characters and isEnglish ( ) will return False. 



But if the decrypted message is recognized as readable English (by the isEnglish ( ) function 
anyway), then we will display this to the user. 







affineHacker.py 


49. 


printC'Enter D for done, or 


just press Enter to continue 


hacki ng : ' ) 






50. 


response = input('&gt; ') 




51. 






52. 


if response. stripC) .upperC) 


startswith('D') : 


53. 


return decryptedText 





The program might not have found the correct key, but rather a key that produces gibberish that 
the isEnglish ( ) function mistakenly thinks is English. To prevent false positives, the 
decrypted text is printed on the screen for the user to read. If the user decides that this is the 
correct decryption, she can type in D and press Enter. Otherwise, she can just press Enter (which 
returns a blank string from the input ( ) call) and the hack Af fine ( ) function will continue 
trying more keys. 







affineHacker.py 


54. 


return None 





From the indentation of line 54, you can see that this is line is executed after the for loop on line 
33 has completed. If this loop has finished, then it has gone through every possible decryption 



234 http://inventwithpython.com/hacking 



key without finding the correct key. (If the program had found the correct key, then the execution 
would have previously returned from the function on line 53.) 



But at this point, the hackAf f ine ( ) function returns the None value to signal that it was 
unsuccessful at hacking the ciphertext. 







affi neHacker. py 


57. 


# If aff i neHacker . py is run 


(instead of imported as a module) call 


58. 


# the mainO function. 




59. 


if name == ' main ': 




60. 


main() 





Just like the other programs, we want the affineHacker.py file to be run on its own or be imported 

as a module. If affineHacker.py is run as a program, then the special name variable will be 

set to the string ' main ' (instead of ' af f ineHacker ' ). In this case, we want to call the 

main ( ) function. 



Practice Exercises, Chapter 16, Set A 

Practice exercises can be found at ht^://invpxAQn^^J^^ra^cel6A. 

Summary 

This chapter was fairly short because it hasn't introduced any new hacking techniques. As long as 
the number of possible keys is less than a million or so, it won't take long for our computers to 
brute-force through every possible key and use i sEngl i sh ( ) to check if it has found the right 
key. 

And a lot of the code we use for the affine cipher hacker has already been written in 
affineCipher.py, detectEnglish.py , cryptomath.py, and pyperclip.py. The main ( ) function trick 
is really helpful in making the code in our programs reusable. 

The * * exponent operator can be used to raise a number to the power of another number. The 
continue statement sends the program execution back to the beginning of the loop (instead of 
waiting until the execution reaches the end of the block). 

In the next chapter, we will learn a new cipher that cannot be brute -forced by our computers. The 
number of possible keys is more than a trillion trillion! A single laptop couldn't possible go 
through a fraction of those keys in our life time. This makes it immune to brute-forcing. Let's 
learn about the simple substitution cipher. 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 235 



Chapter 17 

The Simple Substitution 
Cipher 

Topics Covered In This Chapter: 

‚Ä¢ The sort ( ) list method 

‚Ä¢ Getting rid of duplicate characters from a string 

‚Ä¢ The is upper ( ) and is lower ( ) string methods 

‚Ä¢ Wrapper functions 



"In my role as Wikileaks editor, I've been involved 
in fighting off many legal attacks. To do that, and 
keep our sources safe, we have had to spread 
assets, encrypt everything, and move 
telecommunications and people around the world 
to activate protective laws in different national 
jurisdictions." 

Julian Assange, editor-in-chief of Wikileaks 




236 http://inventwithpython.com/hacking 

The transposition and affine ciphers have thousands of possible keys, but a computer can still 
brute-force through all of them easily. We'll need a cipher that has so many possible keys, no 
computer can possibly brute -force through them all. 

The simple substitution cipher is effectively invulnerable to a brute-force attack. Even if your 
computer could try out a trillion keys every second, it would still take twelve million years for it 
to try out every key. 

The Simple Substitution Cipher with Paper and Pencil 

To implement the simple substitution cipher, choose a random letter to encrypt each letter of the 
alphabet. Use each letter once and only once. The key will end up being a string of 26 letters of 
the alphabet in random order. There are 403,291,461,126,605,635,584,000,000 possible orderings 
for keys. (To see how this number was calculated, see http://inypy.com/factori 

Let's do the simple substitution cipher with paper and pencil first. For example, let's encrypt the 
message, "Attack at dawn." with the key VJZBGNFEPLITMXDWKQUCRYAHSO. First write 
out the letters of the alphabet and then write the key underneath it. 

ABCDEF GHI J KLMNOP QRS TUVWXYZ 
VJ ZBGNFEPLI TMXDWKQUCRYAHS O 

To encrypt a message, find the letter from the plaintext in the top row and substitute it with the 
letter in the bottom row. A encrypts to V, and T encrypts to C, C encrypts to Z, and so on. So the 
message "Attack at dawn." encrypts to "Vccvzi vc bvax." 

To decrypt, find the letter from the ciphertext in the bottom row and replace it with the letter from 
the top row. V decrypts to A, C decrypts to T, Z decrypts to C, and so on. 

This is very similar to how the Caesar cipher works with the St. Cyr slide, except the bottom row 
is scrambled instead of in alphabetical order and just shifted over. The advantage of the simple 
substitution cipher is that there are far more possible keys. The disadvantage is that the key is 26 
characters long and harder to memorize. If you write down the key, make sure that this key is 
never read by anyone else! 

Practice Exercises, Chapter 17, Set A 

Practice exercises can be found at http://inypy.TO 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 237 



Source Code of the Simple Substitution Cipher 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as simpleSubCipher.py. Press F5 to run the program. Note that 
first you will need to download the pyperclip.py module and place this file in the same directory 
as the simpleSubCipher.py file. You can download this file from http://irrypy.c^ 



Source code for simpleSubCipher.py 

1. # Simple Substitution Cipher 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip, sys, random 

5. 

6. 

7. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 
8. 

9. def main() : 

10. myMessage = 'If a man is offered a fact which goes against his 
instincts, he will scrutinize it closely, and unless the evidence is 
overwhelming, he will refuse to believe it. If, on the other hand, he is 
offered something which affords a reason for acting in accordance to his 
instincts, he will accept it even on the slightest evidence. The origin of 
myths is explained in this way. -Bertrand Russell 1 

11. myKey = 1 LFWOAYUISVKMNXPBDCRJTQEGHZ ' 

12. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 
13. 

14. checkValidKey(myKey) 
15. 

16. if myMode == 'encrypt': 

17. translated = encryptMessage(myKey , myMessage) 

18. el if myMode == 'decrypt': 

19. translated = decryptMessage(myKey , myMessage) 

20. printC Using key %s' % (myKey)) 

21. print('The %sed message is:' % (myMode)) 

22. pri nt(transl ated) 

23. pyperclip. copy (transl ated) 

24. printO 

25. print('This message has been copied to the clipboard.') 

26. 
27. 

28. def checkValidKey(key) : 

29. keyList = list(key) 

30. lettersList = 1 i st(LETTERS) 

31. keyLi st . sort() 

32. lettersList. sort() 



238 http://inventwithpython.com/hacking 



33. 




if keyList != lettersList: 


34. 




sys .exit ( 'There is an error in the key or symbol set.') 


35. 






36. 






37. 


def 


encryptMessage(key, message): 


38. 




return translateMessage(key, message, 'encrypt') 


39. 






40. 






41. 


def 


decryptMessage(key , message): 


42. 




return translateMessage(key, message, 'decrypt') 


43. 






44. 






45. 


def 


translateMessage(key, message, mode): 


46. 




translated = ' ' 


47. 




charsA = LETTERS 


48. 




charsB = key 


49. 




if mode == 'decrypt' : 


50. 




# For decrypting, we can use the same code as encrypting. We 


51. 




# just need to swap where the key and LETTERS strings are used. 


52. 




charsA, charsB = charsB, charsA 


53. 






54. 




# loop through each symbol in the message 


55. 




for symbol in message: 


56. 




if symbol . upper () in charsA: 


57. 




# encrypt/decrypt the symbol 


58. 




symlndex = charsA. fi nd(symbol . upperO) 


59. 




if symbol . i supper () : 


60. 




translated += charsB [symlndex] . upperO 


61. 




else: 


62. 




translated += charsB [symlndex] . 1 ower() 


63. 




el se : 


64. 




# symbol is not in LETTERS, just add it 


65. 




translated += symbol 


66. 






67. 




return translated 


68. 






69. 






70. 


def 


getRandomKeyO : 


71. 




key = list (LETTERS) 


72. 




random . shuf fl e(key) 


73. 




return 1 ' .join (key) 


74. 






75. 






76. 


-if . 


name == ' main ': 


77. 




mainQ 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 239 



Sample Run of the Simple Substitution Cipher Program 

When you run this program, the output will look like this: 



Using key LFWOAYUISVKMNXPBDCRJTQEGHZ 
The encrypted message is: 

Sy 1 nix sr pyyacao 1 ylwj eiswi upar lulsxrj isr sxrjsxwjr, la esmm rwctjsxsza 
sj wmpramh, Ixo txmarr jia aqsoaxwa sr pqacei amnsxu , ia esmm caytra jp famsaqa 
sj . Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor 1 cal rpx ypc 
Iwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia rmsuijarj 
aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr e"lh. -Facjclxo Ctrramm 

This message has been copied to the clipboard. 

Notice that if the letter in the plaintext was lowercase, it will be lowercase in the ciphertext. If the 
letter was uppercase in the plaintext, it will be uppercase in the ciphertext. The simple 
substitution cipher does not encrypt spaces or punctuation marks. (Although the end of this 
chapter explains how to modify the program to encrypt those characters too.) 

To decrypt this ciphertext, paste it as the value for the myMessage variable on line 10 and 
change myMode to the string ' decrypt ' . Then run the program again. The output will look 
like this: 



Using key LFWOAYUISVKMNXPBDCRJTQEGHZ 
The decrypted message is: 

If a man is offered a fact which goes against his instincts, he will scrutinize 
it closely, and unless the evidence is overwhelming, he will refuse to believe 
it. If, on the other hand, he is offered something which affords a reason for 
acting in accordance to his instincts, he will accept it even on the slightest 
evidence. The origin of myths is explained in this way. -Bertrand Russell 

This message has been copied to the clipboard. 



How the Program Works 

simp! eSubCi pher . py 

1. # Simple Substitution Cipher 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip, sys, random 

5. 

6. 

7. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 



240 http://inventwithpython.com/hacking 

The first few lines are comments describing the program. Then the pyperclip, sys, and 
random modules are imported. Finally, the LETTERS constant variable is set to a string of all 
the uppercase letters. The LETTERS string will be our symbol set for the simple substitution 
cipher program. 

The Program's main ( ) Function 

simpleSubCi pher . py 

9. def main() : 

10. myMessage = 'If a man is offered a fact which goes against his 
instincts, he will scrutinize it closely, and unless the evidence is 
overwhelming, he will refuse to believe it. If, on the other hand, he is 
offered something which affords a reason for acting in accordance to his 
instincts, he will accept it even on the slightest evidence. The origin of 
myths is explained in this way. -Bertrand Russell' 

11. myKey = ' LFWOAYUISVKMNXPBDCRJTQEGHZ' 

12. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 



The main ( ) function is similar to the main ( ) function of cipher programs in the previous 
chapters. It contains the variables that store the message, key, and mode that will be used for 
the program. 







simpl eSubCi pher . py 


14. 


checkVal i dKey(myKey) 





The keys for simple substitution ciphers are easy to get wrong. For example, the key might not 
have every letter of the alphabet. Or the key may have the same letter twice. The 
checkVal idKey ( ) function (which is explained later) makes sure the key is usable by the 
encryption and decryption functions, and will exit the program with an error message if they are 
not. 









simpl eSubCi pher. py 


16. 


if myMode == 'encrypt': 






17. 


translated = encryptMessage(myKey , 


myMessage) 




18. 


el if myMode == 'decrypt': 






19. 


translated = decryptMessage(myKey , 


myMessage) 





If the program execution returns from checkVal idKey ( ) instead of terminating, we can 
assume the key is valid. Lines 16 through 19 check whether the myMode variable is set to 
'encrypt' or 'decrypt' and calls either encryptMessage ( ) or 

decryptMessage ( ) . The return value of encryptMessage ( ) and decryptMessage ( ) 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 241 



(which is explained later) will be a string of the encrypted (or decrypted) message. This string 
will be stored in the translated variable. 





simpl eSubCi pher . py 


20. 


printC Using key %s' % (myKey)) 


21. 


print('The %sed message is:' % (myMode)) 


22. 


pri nt(transl ated) 


23. 


pypercl i p . copy (trans! ated) 


24. 


pri nt() 


25. 


print('This message has been copied to the clipboard.') 



The key that was used is printed to the screen on line 20. The encrypted (or decrypted) message is 
printed on the screen and also copied to the clipboard. Line 25 is the last line of code in the 
main ( ) function, so the program execution returns after line 25. Since the main ( ) call is done 
at the last line of the program, the program will then exit. 



The sort ( ) List Method 







simpl eSubCi pher . py 


28. 


def checkValidKey(key) : 




29. 


keyList = list (key) 




30. 


lettersList = 1 i st (LETTERS) 




31. 


keyLi st . sort() 




32. 


1 ettersLi st . sort() 





A simple substitution key string value is only valid if it has each of the characters in the symbol 
set with no duplicate or missing letters. We can check if a string value is a valid key by sorting it 
and the symbol set into alphabetical order and checking if they are equal. (Although LETTERS is 
already in alphabetical order, we still need to sort it since it could be expanded to contain other 
characters.) 



On line 29 the string in key is passed to li st ( ) . The list value returned is stored in a variable 
named keyList. On line 30, the LETTERS constant variable (which, remember, is the string 
' ABCDEFGHI JKLMNOPQRSTUVWXYZ ' ) is passed to list ( ) which returns the list [ ' A ' , 
'B', 'C, 'D', 'E', ' F ' , ' G ' , 'H', 'I', 'J', 'K', 'L', 'M', ' N ' , 
'0', 'P', 'Q\ 'R', 'S', 'T', 'U', 'V, 'W\ 'X', 'Y\ 'Z']. 

The sort ( ) list method will rearrange the order of items in the list into alphabetical order. The 
lists in keyList and lettersList are then sorted in alphabetical order by calling the 
sort ( ) list method on them. Note that just like the append ( ) list method, the sort ( ) list 
method modifies the list in place and does not have a return value. You want your code to look 
like this: 



242 http://inventwithpython.com/hacking 

keyList . sort ( ) 



...and not look like this: 



keyList = keyList . sort ( ) 







simpl eSubCi pher. py 


33. 


if keyList != lettersList: 




34. 


sys .exit( 'There is an error in the key or symbol 


set. ') 



Once sorted, the keyList and lettersList values should be the same, since keyList was 
just the characters in LETTERS with the order scrambled. If keyList and lettersList are 
equal, we also know that keyList (and, therefore, the key parameter) does not have any 
duplicates in it, since LETTERS does not have any duplicates in it. 



However, if the condition on line 33 is True, then the value in myKey was set to an invalid 
value and the program will exit by calling sys . exit () . 



Wrapper Functions 











simpl eSubCi pher . py 


37. 


def 


encryptMessage(key , message): 






38. 




return translateMessage(key, message, 


1 encrypt ' ) 




39. 










40. 










41. 


def 


decryptMessage(key , message): 






42. 




return trans1ateMessage(key, message, 


'decrypt') 




43. 










44. 










45. 


def 


translateMessage(key, message, mode): 







The code for encrypting and the code for decrypting are almost exactly the same. It's always a 
good idea to put code into a function and call it twice rather than type out the code twice. First, 
this saves you some typing. But second, if there's ever a bug in the duplicate code, you only have 
to fix the bug in one place instead of multiple places. It is (usually) much more reasonable to 
replace duplicate code with a single function that has the code. 



Wrapper functions simply wrap the code of another function, and return the value the wrapped 
function returns. Often the wrapper function might make a slight change to the arguments or 
return value of wrapped function (otherwise you would just call the wrapped function directly.) In 
this case, encryptMessage ( ) and decryptMessage ( ) (the wrapper functions) calls 

Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 243 



translateMessage ( ) (the wrapped function) and returns the value 

translateMessage ( ) returns. 

On line 45 notice that translateMessage ( ) has the parameters key and message, but also 
a third parameter named mode. When it calls translate Me ssage ( ) , the call in 
encryptMessage ( ) function passes 'encrypt ' for the mode parameter, and the call in 
decryptMe ssage ( ) function passes 'decrypt ' . This is how the 

translateMes sage ( ) function knows whether it should encrypt or decrypt the message it is 
passed. 

With these wrapper functions, someone who imports the simpleSubCipher.py program can call 
functions named encryptMessage ( ) and decryptMessage ( ) like they do with all the 
other cipher programs in this book. They might create a program that encrypts with various 
ciphers, like below: 



import affineCipher, simpleSubCipher, transpositionCipher 




. . . some other 


code here. . . 




ciphertextl = 


affineCi pher . encryptMessage(encKeyl, 


'Hello! ') 


ciphertext2 = 


transposi tionCi pher .encryptMessage (encKey2 , 


'Hello! ') 


ciphertext3 = 


simpleSubCi pher .encryptMessage (encKey3 , 


'Hello! ') 



The wrapper functions give the simple substitution cipher program function names that are 
consistent with the other cipher programs. Consistent names are very helpful, because it makes it 
easier for someone familiar with one of the cipher programs in this book to already be familiar 
with the other cipher programs. (You can even see that the first parameter was always made the 
key and the second parameter is always the message.) This is the reason we have these wrapper 
functions, because making the programmer call the translateMessage ( ) function would be 
inconsistent with the other programs. 



The Program's translateMessage () Function 









simpl eSubCi pher. py 


45. 


def translateMessage(key, message, mode): 






46. 


translated = ' ' 






47. 


charsA = LETTERS 






48. 


charsB = key 






49. 


if mode == 'decrypt' : 






50. 


# For decrypting, we can use the same 


code as 


encrypting. We 


51. 


# just need to swap where the key and 


LETTERS 


strings are used. 


52. 


charsA, charsB = charsB, charsA 







244 http://inventwithpython.com/hacking 



The translateMessage ( ) function does the encryption (or decryption, if the mode 
parameter is set to the string ' decrypt ' ). The encryption process is very simple: for each letter 
in the message parameter, we look up its index in LETTERS and replace it with the letter at that 
same index in the key parameter. To decrypt we do the opposite: we look up the index in key 
and replace it with the letter at the same index in the LETTERS. 

The table below shows why using the same index will encrypt or decrypt the letter. The top row 
shows the characters in charsA (which is set to LETTERS on line 47), the middle row shows 
the characters in charsB (which is set to key on line 48), and the bottom row are the integer 
indexes (for our own reference in this example). 



A 


B 


c 


D 


E 


F 


G 


H 


I 


J 


K 


L 


M 


I 


t 


I 


t 


X 


X 


X 


X 


X 


I 


I 


I 


X 


V 


J 


z 


B 


G 


N 


F 


E 


p 


L 


I 


T 


M 


0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


10 


11 


12 



NOPQRSTUVWXYZ 

XDWKQUCRYAHS O 
13 14 15 16 17 18 19 20 21 22 23 24 25 



The code in translateMessage ( ) will always look up the message character's index in 
charsA and replace it with the character at that index in charsB. 

So to encrypt, we can just leave charsA and charsB as they are. This will replace the character 
in LETTERS with the character in key, because charsA is set to LETTERS and charsB is set 
to key. 

When decrypting, the values in charsA and charsB (that is, LETTERS and key) are swapped 
on line 52, so the table would look like this: 



V 


J 


Z 


B 


G 


N 


F 


E 


P 


L 


I 


T 


M 


I 


I 


I 


I 


I 


X 


I 


I 


X 


X 


X 


I 


X 


A 


B 


c 


D 


E 


F 


G 


H 


1 


J 


K 


L 


M 


0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


10 


11 


12 



X 


D 


W 


K 


Q 


U 


C 


R 


Y 


A 


H 


S 


O 


X 


X 


X 


I 


I 


X 


X 


X 


X 


X 


X 


X 


I 


N 


0 


p 


Q 


R 


s 


T 


u 


V 


w 


X 


Y 


z 


13 


14 


15 


16 


17 


18 


19 


20 


21 


22 


23 


24 


25 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 245 



Remember, our code in translateMessage ( ) always replaces the character in charsA (the 
top row) with the character at that same index in charsB (the middle row). So when lines 47 and 
48 will swap the values in charsA and charsB, the code in translateMessage ( ) will be 
doing the decryption process instead of the encryption process. 







simpl eSubCi pher . py 


54. 


# loop through each symbol in the message 




55. 


for symbol in message: 




56. 


if symbol . upper () in charsA: 




57. 


# encrypt/decrypt the symbol 




58. 


symlndex = charsA. fi nd(symbol . upperQ) 





The for loop on line 55 will set the symbol variable to a character in the message string on 
each iteration through the loop. If the uppercase form of this symbol exists in charsA 
(remember that both the key and LETTERS only have uppercase characters in them), then we 
will find the index of the uppercase form of symbol in charsA. This index will be stored in a 
variable named symlndex. 



We already know that the f ind ( ) method will never return -1 (remember, a -1 from the 
f ind ( ) method means the argument could not be found the string) because the if statement on 
line 56 guarantees that symbol . upper ( ) will exist in charsA. Otherwise line 58 wouldn't 
have been executed in the first place. 

The isupper ( ) and islower ( ) String Methods 

The isupper ( ) string method returns True if: 

1 . The string has at least one uppercase letter. 

2. The string does not have any lowercase letters in it. 

The islower ( ) string method returns True if: 

1 . The string has at least one lowercase letter. 

2. The string does not have any uppercase letters in it. 

Non-letter characters in the string do not affect whether these methods return True or False. 
Try typing the following into the interactive shell: 



¬ª&gt; 'HELLO' .isupperO 
True 



246 http://inventwithpython.com/hacking 



¬ª&gt; 'HELLO WORLD 123 ' . i supperO 
True 

¬ª&gt; 'hELLO' .-isupperC) 
False 

¬ª&gt; 'hELLO' .i slowerO 
False 

¬ª&gt; ' hello' . i slowerO 
True 

¬ª&gt; '123' .isupperO 
False 

¬ª&gt; ' ' . "i slowerO 
Fal se 

¬ª&gt; 









simpl eSubCi pher . py 


59. 


"if symbol . i supper () : 






60. 


translated += charsB [symlndex] 


upperO 




61. 


else: 






62. 


translated += charsB [symlndex] 


lowerQ 





If symbol is an uppercase letter, than we want to concatenate the uppercase version of the 
character at charsB [ symlndex] to translated. Otherwise we will concatenate the 
lowercase version of the character at charsB [ symlndex] to translated. 



If symbol was a number or punctuation mark like ' 5 ' or ' ? ' , then the condition on line 59 
would be Fal se (since those strings don't have at least one uppercase letter in them) and line 62 
would have been executed. In this case, line 62's lower ( ) method call would have no effect on 
the string since it has no letters in it. Try typing the following into the interactive shell: 



¬ª&gt; ' 5 ' . lower () 
'5' 

¬ª&gt; '?' .lowerO 
'?' 

¬ª&gt; 



So line 62 in the e 1 s e block takes care of translating any lowercase characters and non-letter 
characters. 







simpl eSubCi pher . py 


63. 


else: 




64. 


# symbol is not in LETTERS, just add it 




65. 


translated += symbol 





Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 247 



By looking at the indentation, you can tell that the else statement on line 63 is paired with the 
if statement on line 56. The code in the block that follows (that is, line 65) is executed if 
symbol is not in LETTERS. This means that we cannot encrypt (or decrypt) the character in 
symbol, so we will just concatenate it to the end of translated as is. 







simpl eSubCi pher . py 


67. 


return translated 





At the end of the translateMessage ( ) function we return the value in the translated 
variable, which will contain the encrypted or decrypted message. 



Practice Exercises, Chapter 17, Set B 

Practice exercises can be found at http://inypy.con^^ 



Generating a Random Key 







simpl eSubCi pher . py 


70. 


def getRandomKeyO : 




71. 


key = list (LETTERS) 




72. 


random . shuf fl e(key) 




73. 


return 1 1 . join(key) 





Typing up a string that contains each letter of the alphabet once and only once can be difficult. To 
aid the user, the getRandomKey ( ) function will return a valid key to use. Lines 71 to 73 do 
this by randomly scrambling the characters in the LETTERS constant. See the "Randomly 
Scrambling a String" section in Chapter 10 for an explanation of how to scramble a string using 

list () , random. shuffle ( ) , and join ( ) . 



To use the getRandomKey ( ) function, line 11 can be changed to this: 



11. myKey = getRandomKeyO 



Remember that our cipher program will print out the key being used on line 20. This is how the 
user can find out what key the getRandomKey ( ) function returned. 









simpl eSubCi pher . py 


76. 


if name == 


= ' mai n ' : 




77. 


mainQ 







248 http://inventwithpython.com/hacking 



Lines 76 and 77 are at the bottom of the program, and call main ( ) if simpleSubCipher.py is 
being run as a program instead of imported as a module by another program. 

Encrypting Spaces and Punctuation 

The simple substitution cipher in this chapter only encrypts the letters in the plaintext. This 
artificial limitation is here because the hacking program in the next chapter only works if the 
letters alone have been substituted. 

If you want the simple substitution program to encrypt more than just the letter characters, make 
the following changes: 



simpl eSubCi pher . py 

7. LETTERS = r !"#$%&amp;' ()*+,- ./0123456789: ; &lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXY 
Z[\]A_"abcdefghi jklmnopqrstuvwxyz{ I }-""" 

Line 7's value stored in the LETTERS constant is changed to a string of all the characters Using a 
triple -quotes raw string so you do not have to escape the quotes and \ slash character makes 
typing this easier. 

The key used must also have all of these characters, so line 1 1 changes to something like this: 



simpl eSubCi pher. py 

11. myKey = r /{9@6hUf :q?_)A e Ti |Wl,NLD7xk(- 
SF&gt;IzOE=d;Bu#c]w~'VvHKmpJ+}s8y&amp; XtP43.b[OA!"\Q&lt;M%$ZgC52YloaRCn"&gt;j 



The code that differentiates between upper and lowercase letters on lines 58 to 62 can be replaced 
with these two lines: 







simpl eSubCi pher. py 


58. 


symlndex - charsA. fi nd(symbo1 . upper 0) 




59. 


if symbol . i supperC) : 




60. 


translated +- charsB [symlndex] . upper 0 




61. 


else: 




62. 


translated +- charsB [symlndex] .lowerO 




58. 


symlndex = charsA. fi nd (symbol ) 




59. 


translated += charsB [symlndex] 





Now when you run the simple substitution cipher program, the ciphertext looks much more like 
random gibberish: 



Email questions to the author: al@inventwithpython.com 



Chapter 17 - The Simple Substitution Cipher 249 



Using key /{9@6hUf : q?_)A e Ti |Wl,NLD7xk(-SF&gt;IzOE=d;Bu#c]w~'VvHKmp]+}s8y&amp; 
XtP43 . b [OA ! *\Q&lt;M%$ZgC52Yl oaRCn" ' r j 
The encrypted message is: 

#A/3/%3$/\2/ZAA050[/3/A3bY/a*\b*/!Z02/3!3\$2Y/*\2/\$2Y\$bY2)/*0/a\MM/2b51Y\$\nO 
/\Y/bMZ20MC)/3$[/l$M022/Y*0/Oo\[0$bO/\2/Zo05a*OM%\$!)/*0/a\MM/50A120/YZ/.OM\OoO 
/\Ye/#A)/Z$/Y"0/ZY*05/*3$[)/*0/\2/ZAA050[/2Z%OY"\$!/a ! -\b ! V3AAZ5[2/3/5032Z$/AZ5/ 
3bY\$!/\$/3bbZ5[3$bO/YZ/*\2/\$2Y\$bY2)/*0/a\MM/3bbOgY/\Y/OoO$/Z$/Y*0/2M\!*Y02Y/ 
0o\ [0$b0e/p*0/Z5\ ! \$/ZA/%CY*2/\2/ORgM3\$0 [/\$/Y*\2/a3Ce/A0O5Y53$ [/Kl 220MM 

This message has been copied to the clipboard. 



Practice Exercises, Chapter 17, Set C 

Practice exercises can be found at http://invpy.con^^ 

Summary 

In this chapter, we have learned about the new "set" data type. In many of our programs, lists are 
much easier to use than sets, but sets are a simple way to get rid of duplicate values from lists or 
strings. 

The is upper ( ) and is lower ( ) string methods can tell us if a string value is made up of only 
uppercase or lowercase letters. And the sort ( ) list method is very useful at putting the items in 
a list in order. 

The simple substitution cipher has far too many possible keys to brute-force through. This makes 
it impervious to the techniques that our previous cipher hacking programs have used. We are 
going to have to make smarter programs in order to break this code. 

In the next chapter, we will learn how to hack the simple substitution cipher. Instead of brute- 
forcing through all the keys, we will use a much more intelligent and sophisticated algorithm. 



250 http://inventwithpython.com/hacking 




Chapter 18 



Hacking the Simple 
Substitution Cipher 

Topics Covered In This Chapter: 

‚Ä¢ Word patterns, candidates, potential decryption letters, and cipherletter mappings. 

‚Ä¢ The pprint . pprint ( ) and pprint . pf ormat ( ) functions 

‚Ä¢ Building strings using the list-append-join process 

‚Ä¢ Regular expressions 

‚Ä¢ The sub ( ) regex method 



"Cypherpunks deplore regulations on cryptography, 
for encryption is fundamentally a private act. The 
act of encryption, in fact, removes information from 
the public realm. Even laws against cryptography 
reach only so far as a nation's border and the arm of 
its violence." 

Eric Hughes, "A Cypherpunk's Manifesto", 1993 
http://inypy,conVcypherj)unk 



Email questions to the author: al@inventwithpython.com 



Chapter 1 8 - Hacking the Simple Substitution Cipher 25 1 



Computing Word Patterns 

There are too many possible keys to brute -force a simple substitution cipher-encrypted message. 
We need to employ a more intelligent attack if we want to crack a substitution ciphertext. Let's 
examine one possible word from an example ciphertext: 



HGHHU 



Think about what we can learn from this one word of ciphertext (which we will call a 
cipherword in this book). We can tell that whatever the original plaintext word is, it must: 

1. Be five letters long. 

2. Have the first, third, and fourth letters be the same. 

3. Have exactly three different letters in the word, where the first, second, and fifth letters in 
the word are all different from each other. 

What words in the English language fit this pattern? "Puppy" is one word that fits this pattern. It 
is five letters long (P, U, P, P, Y) using three different letters (P, U, Y) in that same pattern (P for 
the first, third, and fourth letter and U for the second letter and Y for the fifth letter). "Mommy", 
"Bobby", "lulls", "nanny", and "lilly" fit the pattern too. ("Lilly" is a name, not to be confused 
with "Lily" the flower. But since "Lilly" can appear in an Engish message it is a possible word 
that fits the pattern.) If we had a lot of time on our hands, we could go through an entire 
dictionary and find all the words that fit this pattern. Even better, we could have a computer go 
through a dictionary file for us. 

In this book a word pattern will be a set of numbers with periods in between the numbers that 
tells us the pattern of letters for a word, in either ciphertext or plaintext. 

Creating word patterns for cipherwords is easy: the first letter gets the number 0 and the first 
occurrence of each different letter after that gets the next number. For example: 



The word pattern for "cat" is 0.1.2. 
The word pattern for "catty" is 0.1.2.2.3. 
The word pattern for "roofer" is 0.1.1.2.3.0. 
The word pattern for "blimp" is 0.1.2.3.4. 

The word pattern for "classification" is 0.1.2.3.3.4.5.4.0.2.6.4.7.8. 



A plaintext word and its cipherword will always have the same word pattern, no matter 
which simple substitution key was used to do the encryption. 



252 http://inventwithpython.com/hacking 



Getting a List of Candidates for a Cipherword 

To take a guess at what HGHHU could decrypt to, we can go through the dictionary file and find 
all of the words that also have a word pattern of 0.1.0.0.2. In this book, we will call these 
plaintext words (that have the same word pattern as the cipherword) the candidates for that 
cipherword: 

Ciphertext word: HGHHU 
Word pattern: 0.1.0.0.2 



p 


u 


P 


P 


y 


m 


0 


m 


m 


y 


b 


0 


b 


b 


y 


1 


u 


1 


1 


s 


n 


a 


n 


n 


y 


1 


i 


1 


1 


y 



So if we look at the letters in the cipherword (which will be called cipherletters in this book), 
we can guess which letters they may decrypt to (we will call these letters the cipherletter's 
potential decryption letters in this book): 



Cipherletters: H 



U 



Potential decryption letters: 



P 
m 
b 
1 
n 
1 



u 
o 
o 
u 
a 
i 



y 
y 
y 

s 

y 

_y_ 



From this table we can create a cipherletter mapping: 

‚Ä¢ The cipher letter H has the potential decryption letters P, M, B, L, and N 

‚Ä¢ The cipher letter G has the potential decryption letters U, O, A, and I 

‚Ä¢ The cipher letter U has the potential decryption letters Y and S 

‚Ä¢ All of the other cipher letters besides H, G, and U will have no potential decryption letters. 
When we represent a cipherletter mapping in Python code, we will use a dictionary value: 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 253 



{'A' : 


[], 


'B': [], 'C: [], 


'D' : 


[], 


'E' : 




'F': [], 


'C: ['U', '0', 'A', 


'I'], 


1 H 1 


: ['P\ 'B', 'L\ 


'N'], 


'I' 


: [], 


' 3 1 


[], 'K' 


: [], ' L 1 : [], 'M' : [] , 


'N' : 


[] , 


'0': [], 'P': [], 


'Q': 


[], 


'R' : 


[], 


S': [], 


'T': [], 'U': ['Y', 'S'], 


'V : 


[] , 


"W: [], 'X': [], 


'Y' : 


[], 


‚Ä¢Z' : 


[]} 







In our program, a cipherletter mapping dictionary will have 26 keys, one for each letter. The 
mapping above has potential decryption letters for ' H ' , ' G ' , and ' U ' above. The other keys 
have no potential decryption letters, which is why they have empty lists for values. 



If we reduce the number of potential decryption letters for a cipherletter to just one letter, then we 
have solved what that cipherletter decrypts to. Even if we do not solve all 26 cipher letters, we 
might be able to hack most of the ciphertext's cipherletters. 

But first we must find the pattern for every word in the dictionary file and sort them in a list so it 
will be easy to get a list of all the candidates for a given cipherword's word pattern. We can use 
the same dictionary file from Chapter 12, which you can download from 
http://inypy,co^^^ 

(Note that the terms "word pattern", "candidate", and "cipherletter mapping" are terms I came up 
with to describe things in this particular hacking program. These are not general cryptography 
terms.) 

Practice Exercises, Chapter 18, Set A 

Practice exercises can be found at http://inyj?y.^ 

Source Code of the Word Pattern Module 

Since the word patterns for words never change, we can just calculate the word pattern for every 
word in a dictionary file once and store them in another file. Our makeWordPatterns.py program 
creates a file named wordPatterns.py that will contain a dictionary value with the word pattern for 
every word in the dictionary file. Our hacking program can then just import wordPatternsto 
look up the candidates for a certain word pattern. 



Source code for makeWordPatterns.py 

1. # Makes the wordPatterns.py File 

2. # http://inventwithpython.com/hacknng (BSD Licensed) 
3. 

4. # Creates wordPatterns.py based on the words in our dictionary 

5. # text file, dictionary.txt. (Download this file from 

6. # http://invpy.com/dictionary.txt) 
7. 

8. import pprint 



254 http://inventwithpython.com/hacking 



9. 
10. 






11. 


def 


getWordPattern(word) : 


12. 




# Returns a string of the pattern form of the given word. 


13. 




# e.g. '0.1.2.3.4.1.2.3.5.6' for 'DUSTBUSTER' 


14. 




word = word. upper () 


15. 




nextNum = 0 


16. 




letterNums = {} 


17. 




wordPattern = [] 


18. 






19. 




for letter in word: 


20. 




if letter not in letterNutns: 


21. 




letterNums [letter] = str (nextNum) 


22. 




nextNum += 1 


23. 




wordPattern .append (1 etterNums [letter] ) 


24. 




return ' . ' . joi n(wordPattern) 


25. 






26. 






27. 


def 


main() : 


28. 




all Patterns = {} 


29. 






30. 




fo = open ('dictionary.txt') 


31. 




wordList = fo. read() .split('\n') 


32. 




fo.closeO 


33. 






34. 




for word in wordList: 


35. 




# Get the pattern for each string in wordList. 


36. 




pattern = getWordPattern(word) 


37. 






38. 




if pattern not in all Patterns: 


39. 




all Patterns [pattern] = [word] 


40. 




else: 


41. 




al 1 Patterns [pattern] . append(word) 


42. 






43. 




# This is code that writes code. The wordPatterns . py file contains 


44. 




# one very, very large assignment statement. 


45. 




fo = open('wordPatterns.py' , 'w') 


46. 




fo.writeC'allPatterns = ') 


47. 




fo . wri teCppri nt . pformat (al 1 Patterns)) 


48. 




fo.closeO 


49. 






50. 






51. 


-if . 


name == ' main ': 


52. 




main() 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 255 



Sample Run of the Word Pattern Module 

Running this program doesn't print anything out to the screen. Instead it silently creates a file 
named wordPatterns.py in the same folder as makeWordPatterns.py. Open this file in IDLE's file 
editor, and you will see it looks like this: 



allPatterns = {'0.0.1' : ['EEL'], 
'0.0.1.2': ['EELS', 'OOZE'], 
'0.0.1.2.0': ['EERIE'], 

'0.0.1.2.3': ['AARON', 'LLOYD', 'OOZED'], 
...the rest has been cut for brevity... 



The makeWordPatterns.py program creates wordPatterns.py. Our Python program creates a 
Python program! The entire wordPatterns.py program is just one (very big) assignment statement 
for a variable named allPatterns. Even though this assignment statement stretches over 
many lines in the file, it is considered one "line of code" because Python knows that if a line ends 
with a comma but it is currently in the middle of a dictionary value, it ignores the indentation of 
the next line and just considers it part of the previous line. (This is a rare exception for Python's 
significant indentation rules.) 

The allPatterns variable contains a dictionary value where the keys are all the word patterns 
made from the English words in the dictionary file. The keys' values are lists of strings of English 
words with that pattern. When wordPatterns.py is imported as a module, our program will be able 
to look up all the English words for any given word pattern. 

After running the makeWordPatterns.py program to create the wordPatterns.py file, try typing the 
following into the interactive shell: 



¬ª&gt; import wordPatterns 

¬ª&gt; wo rdPatte rns . al 1 Patte rns ['0.1. 2. 1.1. 3. 4'] 
[ ' BAZAARS ' , ' BESEECH ' , ' REDEEMS ' , ' STUTTER ' ] 

¬ª&gt; 

¬ª&gt; wordPatterns . al 1 Patterns ['0.1.2.2.3.2.4.1.5.5'] 
['CANN0NBALL'] 

¬ª&gt; 

¬ª&gt; wo rdPatte rns . al 1 Patte rns['0. 1.0. 1.0.1'] 
Traceback (most recent call last): 

File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
KeyError: '0.1.0.1.0.1' 

&gt;¬ª 

¬ª&gt; '0.1.0.1.0.1' in wordPatterns. all Patterns 
Fal se 

¬ª&gt; 



256 http://inventwithpython.com/hacking 



The pattern '0.1.0.1.0.1' does not exist in the dictionary. This is why the expression 
wordPatterns . allPatterns ['0.1.0.1.0.1'] causes an error (because there is no 
'0.1.0.1.0.1' key in allPatterns) and why '0.1.0.1.0.1' in 

wordPatterns . allPatterns evaluates to False. 

How the Program Works 

makeWordPatterns . py 

1. # Makes the wordPatterns . py File 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. # Creates wordPatterns . py based on the words in our dictionary 

5. # text file, dictionary.txt. (Download this file from 

6. # http://invpy.com/dictionary.txt) 

The top part of this file has the usual comments describing what the program is. 



Thepprint.pprint () and pprint .pf ormat () Functions 





makeWordPatterns . py 


8. import pprint 





The pprint module has functions for pretty printing values, which is useful for printing 
dictionary and list values on the screen. The print ( ) function simply prints these values going 
left to right: 



¬ª&gt; print(someListOfListsVar)) 

[['ant'], ['baboon', 'badger', 'bat', 'bear', 'beaver'], ['camel', 'cat', 
'clam', 'cobra', 'cougar', 'coyote', 'crow'], ['deer', 'dog', 'donkey', 
'duck'], ['eagle'], ['ferret', 'fox', 'frog'], ['goat']] 



The pprint module has a function named pprint ( ) . The value passed to 
pprint . pprint ( ) will be "pretty printed" to the screen so that it is easier to read: 



¬ª&gt; import pprint 




¬ª&gt; ppri nt . ppri nt (someLi stOf Li stsVar)) 




[['ant'], 




['baboon', 'badger', 'bat', 'bear', 'beaver'], 




['camel', 'cat', 'clam', 'cobra', 'cougar', 'coyote', 


'crow'] , 


['deer', 'dog', 'donkey', 'duck'], 




['eagle'], 




['ferret', 'fox', 'frog'], 




['goat']] 





Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 257 



However, if you want to have this "prettified" text as a string value instead of displaying it on the 
screen, you can use the pprint . pf ormat ( ) function, which returns the prettified string: 



¬ª&gt; "import pprint 

¬ª&gt; prettifiedString = ppri nt . pformat(someLi stOf Li stsVar) 

¬ª&gt; print(prettifiedString) 

[['ant'], 

['baboon', 'badger', 'bat', 'bear', 'beaver'], 

['camel 1 , 'cat 1 , 'clam 1 , 'cobra', 'cougar', 'coyote', 'crow'], 

['deer', 'dog', 'donkey', 'duck'], 

['eagle'], 

['ferret', 'fox', 'frog'], 
['goat']] 

¬ª&gt; 

When we write the value of allPatterns to the wordPatterns.py file, we will use the 
pprint module to prevent it from being printed crammed together all on one line. 

Building Strings in Python with Lists 

Almost all of our programs have done some form of "building a string" code. That is, a variable 
will start as a blank string and then new characters are added with string concatenation. (We've 
done this in many previous cipher programs with the translated variable.) This is usually 
done with the + operator to do string concatenation, as in the following short program: 



# The slow way to build a string using string concatenation. 

building = ' ' 

for c in 'Hello world!': 

building += c 
print(building) 

The above program loops through each character in the string 'Hello world!' and 
concatenates it to the end of the string stored in building. At the end of the loop, building 
holds the complete string. 

This seems like a straightforward way to do this. However, it is very inefficient for Python to 
concatenate strings. The reasons are technical and beyond the scope of this book, but it is much 
faster to start with a blank list instead of a blank string, and then use the append ( ) list 
method instead of string concatenation. After you are done building the list of strings, you can 
convert the list of strings to a single string value with the j o i n ( ) method. The following short 
program does exactly the same thing as the previous example, but faster: 



258 http://inventwithpython.com/hacking 



# The fast way to build a string using a list, appendO, and join(). 

building = [] 

for c in 'Hello world!': 

bui 1 di ng . append(c) 
building = ' ' . join(building) 
print(building) 

Using this approach for building up strings in your code will result in much faster programs. We 
will be using this list-append-join process to build strings in the remaining programs of this book. 



Calculating the Word Pattern 







makeWordPatterns . py 


11. 


def getWordPattern(word) : 




12. 


# Returns a string of the 


pattern form of the given word. 


13. 


# e.g. '0.1.2.3.4.1.2.3.5 


6' for 'DUSTBUSTER' 


14. 


word = word. upper () 




15. 


nextNum = 0 




16. 


letterNums = {} 




17. 


wordPattern = [] 





The getWordPattern ( ) function takes one string argument and returns a string of that 
word's pattern. For example, if getWordPattern ( ) were passed the string 'Buffoon' as 
an argument then getWordPattern ( ) would return the string '0.1.2.2.3.3.4'. 



First, in order to make sure all the letters have the same case, line 14 changes the word parameter 
to an uppercase version of itself. We then need three variables: 

‚Ä¢ nextNum stores the next number used when a new letter is found. 

‚Ä¢ letterNums stores a dictionary with keys of single -letter strings of single letters, and 
values of the integer number for that letter. As we find new letters in the word, the letter and 
its number are stored in letterNums. 

‚Ä¢ wordPattern will be the string that is returned from this function. But we will be building 
this string one character at a time, so we will use the list-append-join process to do this. This 
is why wordPattern starts as a blank list instead of a blank string. 







‚Ä¢ makeWordPatterns . py 


19. 


for letter in word: 




20. 


if letter not in letterNums: 




21. 


letterNums [letter] = str(nextNum) 




22. 


nextNum += 1 





Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 259 



Line 19's for loop will loop through each character in the word parameter, assigning each 
character to a variable named letter. 

Line 20 checks if letter has not been seen before by checking that letter does not exist as a 
key in the letterNums dictionary. (On the first iteration of the loop, the condition on line 20 
will always be True because letterNums will be a blank dictionary that doesn't have 
anything in it.) 

If we have not seen this letter before, line 21 adds this letter as the key and the string form of 
nextNum as the key's value to the letterNums dictionary. For the next new letter we find we 
want to use the next integer after the one currently in nextNum anymore, so line 22 increments 
the integer in nextNum by 1. 







makeWordPatterns . py 


23. 


wo rdPattern .append (letterNums [letter]) 





On line 23 , 1 e 1 1 e r Nums [letter] evaluates to the integer used for the letter in the letter 
variable, so this is appended to the end of wordPattern. The letterNums dictionary is 
guaranteed to have letter for a key, because if it hadn't, then lines 20 to 22 would have 
handled adding it to letterNums before line 23. 









makeWordPatterns . py 


24. 


return 1 


' . joi n (wordPattern) 





After the for loop on line 19 is finished looping, the wordPattern list will contain all the 
strings of the complete word pattern. Our word patterns have periods separating the integers, so 
that we could tell the difference between "1.12" and "1 1.2". To put these periods in between each 
of the strings in the wordPattern list, line 24 calls the j oin ( ) method on the string ' . ' . 
This will evaluate to a string such as '0.1.2.2.3.3.4'. The completely-built string that 
j oin ( ) returns will be the return value of getWordPattern ( ) . 



The Word Pattern Program's main ( ) Function 







makeWordPatterns . py 


27. 


def main() : 




28. 


all Patterns = {} 





The value stored in allPatterns is what we will write to the wordPatterns.py file. It is a 
dictionary whose keys are strings of word patterns (such as '0.1.2.3.0.4.5' or 



260 http://inventwithpython.com/hacking 



'0.1.1.2') and the keys' values are a list of strings of English words that match that pattern. 
For example, here's one of the key-value pairs that will end up in allPatterns: 



'0.1.0.2.3.1.4': ['DEDUCER', 'DEDUCES', 'GIGABIT', ' RARITAN ' ] 



But at the beginning of the main ( ) function on line 28, the allPatterns variable will start 
off as a blank dictionary value. 







makeWordPatterns . py 


30. 


fo = open ('dictionary.txt') 




31. 


wordList = fo.read0.split('\n') 




32. 


fo.closeQ 





Lines 30 to 32 read in the contents of the dictionary file into wordLi st. Chapter 1 1 covered 
these file -related functions in more detail. Line 30 opens the dictionary.txt file in "reading" mode 
and returns a file object. Line 31 calls the file object's read ( ) method which returns a string of 
all text from this file. The rest of line 31 splits it up whenever there is a \n newline character, and 
returns a list of strings: one string per line in the file. This list value returned from spl it ( ) is 
stored in the wordList variable. At this point we are done reading the file, so line 34 calls the 
file object's close ( ) method. 



The wordList variable will contain a list of tens of thousands of strings. Since the 
dictionary.txt file has one English word per line of text, each string in the wordList variable 
will be one English word. 







makeWordPatterns . py 


34. 


for word in wordList: 




35. 


# Get the pattern for each string in wordList. 




36. 


pattern = getWord Pattern (word) 





The for loop on line 34 will iterate over each string in the wordList list and store it in the 
word variable. The word variable is passed to the getWordPattern ( ) function, which 
returns a word pattern string for the string in word. The word pattern string is stored in a variable 
named pattern. 







makeWordPatterns . py 


38. 


if pattern not in allPatterns: 




39. 


all Patterns [pattern] = [word] 




40. 


else: 




41. 


al 1 Patterns [pattern] . append(word) 





Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 261 



There must be a value for the pattern key first before we can append word to 
allPatterns [pattern] , otherwise this would cause an error. So, first line 38 will check if 
the pattern is not already in allPatterns. If pattern is not a key in allPatterns yet, 
line 39 creates a list with word in it to store in allPatterns [pattern] . 

If the pattern already is in allPatterns, we do not have to create the list. Line 41 will just 
append the word to the list value that is already there. 

By the time the for loop that started on line 34 finishes, the allPatterns dictionary will 
contain the word pattern of each English word that was in wordLi st as its keys. Each of these 
keys has a value that is a list of the words that produce the word pattern. With our data organized 
this way, given a word pattern we can easily look up all the English words that produce that 
particular pattern. 





makeWordPatterns . py 


43. 


# This is code that writes code. The wordPatterns . py file contains 


44. 


# one very, very large assignment statement. 


45. 


fo = open('wordPatterns.py' , 'w') 


46. 


fo.writeC all Patterns = ') 


47. 


fo.wri teCppri nt . pformat(al 1 Patterns)) 


48. 


fo.closeC) 



Now that we have this very large dictionary in allPatterns, we want to save it to a file on the 
hard drive. The last part of the main ( ) function will create a file called wordPatterns. py which 
will just have one huge assignment statement in it. 



Line 45 creates a new file by passing the ' wordPatterns . py ' string for the filename and 
' w ' to indicate that this file will be opened in "write" mode. If there is already a file with the 
name ' wordPatterns . py ' , opening it in write mode will cause the file to be deleted to make 
way for the new file we are creating. 



Line 46 starts the file off with 'allPatterns = ', which is the first part of the assignment 
statement. Line 47 finishes it by writing a prettified version of allPatterns to the file. Line 
48 closes the file since we are done writing to it. 









makeWordPatterns . py 


51. 


if name == 


= ' mai n ' : 




52. 


mainQ 







262 http://inventwithpython.com/hacking 



Lines 51 and 52 call the main ( ) function if this program was run by itself (to create the 
wordPattern.py file) rather than imported by another program that wants to use its 
getWordPattern ( ) function. 

Hacking the Simple Substitution Cipher 

The hacking program uses the abstract concepts of "word patterns" and "cipherletter mappings". 
But don't worry, in our Python program "word patterns" are represented by string values and 
"cipherletter mappings" are represented with dictionary values. The previous sections explained 
what word patterns are and how to generate them from a string. Cipherletter mappings are used in 
the hacking program to keep track of the possible letters that each of the 26 cipherletters could 
decrypt to. Go ahead and type in the source code for the simpleSubHacker.py program. 

Source Code of the Simple Substitution Hacking Program 



Source code for simpleSubHacker.py 

1. # Simple Substitution Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import os, re, copy, pprint, pyperclip, simpleSubCipher, makeWordPatterns 

5. 

6. if not os.path.exists('wordPatterns.py') : 

7. makeWordPatterns .mai n() # create the wordPatterns . py file 

8. import wordPatterns 
9. 

10. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

11. nonLettersOrSpacePattern = re . compi 1 e( ' [AA-Z\s] 1 ) 
12. 

13. def main() : 

14. message = ' Sy 1 nix sr pyyacao 1 ylwj eiswi upar lulsxrj isr 
sxrjsxwjr, ia esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr 
pqacei amnsxu , ia esmm caytra jp famsaqa sj . Sy, px jia pjiac ilxo, ia sr 
pyyacao rpnajisxu eiswi lyypcor 1 cal rpx ypc lwjsxu sx Iwwpcolxwa jp isr 
sxrjsxwjr, ia esmm Iwwabj sj aqax px jia rmsuijarj aqsoaxwa. Jia pcsusx py 
nhjir sr agbmlsxao sx jisr elh. -Facjclxo Ctrramm 1 

15. 

16. # Determine the possible valid ciphertext translations. 

17. pri nt( 1 Hacki ng . . . ' ) 

18. letterMapping = hackSimpl eSub(message) 

19. 

20. # Display the results to the user. 

21. pri nt(' Mapping: ') 

22 . ppri nt . ppri nt (1 etterMappi ng) 

23. print() 

24. printC'Original ciphertext:') 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 263 



25. pri nt(message) 

26. printO 

27. pri nt(' Copying hacked message to clipboard:') 

28. hackedMessage = decryptWithCipherletterMappingCmessage, letterMappi ng) 

29 . pypercl i p . copy (hackedMessage) 

30. print(hackedMessage) 
31. 

32. 

33. def getBlankCipherletterMappingO : 

34. # Returns a dictionary value that is a blank cipherletter mapping. 

35. return {'A': [] , 'B': [] , 'C: [] , 'D': [] , 'E': [] , 'F': [] , 'C : [] , 
"h": [], 'I': [], [] , 1 K' : [] , 'L': [] , 'M' : [] , 'N': [] , '0': [] , 'P': 



[], 'Q': [], 'R': [] , 'S': [] , 'T' : [] , 'U': [] , 'V: [] , 'W : [] , 'X': [] , 



'Y': [], 'Z': []} 
36. 
37. 

38. def addLettersToMappingCletterMapping, cipherword, candidate): 

39. # The 1 etterMappi ng parameter is a "cipherletter mapping" dictionary 

40. # value that the return value of this function starts as a copy of. 

41. # The cipherword parameter is a string value of the ciphertext word. 

42. # The candidate parameter is a possible English word that the 

43. # cipherword could decrypt to. 
44. 

45. # This function adds the letters of the candidate as potential 

46. # decryption letters for the ci pherl etters in the cipherletter 

47. # mapping. 
48. 

49. 1 etterMappi ng = copy. deepcopyO etterMappi ng) 

50. for i in range(len(cipherword)) : 

51. if candidate[i] not in letterMapping[cipherword[i]] : 

52. 1 etterMappi ng [ci pherword [i ] ] .append(candidate[i]) 

53. return letterMappi ng 

54. 
55. 

56. def i ntersectMappi ngs(mapA, mapB) : 

57. # To intersect two maps, create a blank map, and then add only the 

58. # potential decryption letters if they exist in BOTH maps. 

59. i ntersectedMappi ng = getBlankCipherletterMappingO 

60. for letter in LETTERS: 
61. 

62. # An empty list means "any letter is possible". In this case just 

63. # copy the other map entirely. 

64. if mapA[letter] == [] : 

65. intersectedMapping[letter] = copy.deepcopy(mapB[letter]) 

66. elif mapB[letter] == [] : 

67. i ntersectedMappi ng [letter] = copy.deepcopy(mapA[letter]) 



264 http://inventwithpython.com/hacking 



68. else: 

69. # If a letter in mapA[l etter] exists in mapB[letter] , add 

70. # that letter to i ntersectedMappi ng [1 etter] . 

71. for mapped Letter in mapA[letter] : 

72. if mappedLetter in mapB [1 etter] : 

73. i ntersectedMappi ng [letter] . append(mappedLetter) 

74. 

75. return i ntersectedMappi ng 

76. 

77. 

78. def removeSolvedLettersFromMapping(letterMapping) : 

79. # Cipher letters in the mapping that map to only one letter are 

80. # "solved" and can be removed from the other letters. 

81. # For example, if 'A' maps to potential letters [ 'M' , 'N'], and 'B' 

82. # maps to ['N'], then we know that 'B' must map to ' N', so we can 

83. # remove 'N' from the list of what 'A' could map to. So 'A' then maps 

84. # to ['M']. Note that now that 'A' maps to only one letter, we can 

85. # remove 'M' from the list of letters for every other 

86. # letter. (This is why there is a loop that keeps reducing the map.) 

87. letterMapping = copy.deepcopy(letterMapping) 

88. loopAgain = True 

89. while loopAgain: 

90. # First assume that we will not loop again: 

91. loopAgain = False 
92. 

93. # sol vedLetters will be a list of uppercase letters that have one 

94. # and only one possible mapping in letterMapping 

95. sol vedLetters = [] 

96. for cipherl etter in LETTERS: 

97. if len(letterMapping[cipherletter]) == 1: 

98 . sol vedLetters . append (1 etterMappi ng [ci pherl etter] [0] ) 
99. 

100. # If a letter is solved, than it cannot possibly be a potential 

101. # decryption letter for a different ciphertext letter, so we 

102. # should remove it from those other lists. 

103. for cipherl etter in LETTERS: 

104. for s in sol vedLetters : 

105. if len(letterMapping[cipherletter]) != 1 and s in 
letterMapping[cipherletter] : 



106. letterMapping[cipherletter] . remove(s) 

107. if len(letterMapping[cipherletter]) == 1: 

108. # A new letter is now solved, so loop again. 

109. loopAgain = True 



110. return letterMapping 

111. 

112. 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 265 



113. 


def hackSimpleSub(message) : 




114. 




i nicrbccicdridp = geiZD i an kli pne r i exize rriappi ng ^ 




115. 




ci pnerworuLi sr ‚Äî nonLerrersuropaceramern . suu^ , 




message . 


upperO) .split() 




1 1 ¬£ 




for ci pherword "in ci pherwordLi st : 




11/ . 




# Get a new ci pherl etter mapping for each ciphertext word. 




llO . 




newMap = getBl ankCi pherl etterMappi ngO 




1 1 Q 

iiy . 








1 ~)A 

l^U . 




wordPattern = makeWordPatterns . getWordPattern(ci pherword) 




1^1 . 




if wordPattern not in wordPatterns . al 1 Patterns : 








continue # This word was not in our dictionary, so continue. 










1 ~) A 
1^4 . 




# Add the letters of each candidate to the mapping. 




lor 
1*1 !!) . 




for candidate in wordPatterns . al 1 Patterns [wordPattern] : 




l^O . 




newMap = addLettersToMapping (newMap, ci pherword, candidate) 


l¬£ / . 








1 TO 

l^O . 




# Intersect the new mapping with the existing intersected mapping. 


1 ~)Q 




intersectedMap = intersectMappings(intersectedMap, newMap) 




1 30 

1 JU . 








1 31 
131 . 




# Remove any solved letters from the other lists. 




13*} 
13Z . 




return removeSol vedLettersFromMappi ng(i ntersectedMap) 




13 3 
133 . 








1 3yl 
134 . 








i or 
13 j . 


uer 


decryptWi thCi pherl etterMappi ng (ci phertext , 1 etterMappi ng) : 




1 3¬£ 
130 . 




# Return a string of the ciphertext decrypted with the letter mapping, 


13 7 
13/ . 




# with any ambiguous decrypted letters replaced with an _ underscore. 


1 3 Q 

13o . 








1 3Q 




# First create a simple sub key from the 1 etterMappi ng mapping. 




1 A O 

14U . 




key = ['x'] * 1 en (LETTERS) 




1^1 
141 . 




for ci pherl etter in LETTERS: 




1 A~&gt; 




if len(letterMapping[cipherletter]) == 1: 




1/3 
143 . 




# If there's only one letter, add it to the key. 




1 A A 

144 . 




keylndex = LETTERS. find(letterMapping[cipherletter] [0]) 




1 A c; 
14D . 




key [keylndex] = cipherletter 




146. 




else: 




147. 




ciphertext = ciphertext. replace(cipherletter.lower() , '_ 


') 


148. 




ciphertext = ci phertext . repl ace(ci pherl etter . upper() , '_ 


') 


149. 




key = ' ' .join (key) 




150. 








151. 




# With the key we've created, decrypt the ciphertext. 




152. 




return simpleSubCipher.decryptMessage(key, ciphertext) 




153. 








154. 








155. 


if 


name == ' main ': 




156. 




mai n() 





266 http://inventwithpython.com/hacking 



Hacking the Simple Substitution Cipher (in Theory) 

Hacking the simple substitution cipher is pretty easy. The five steps are: 

1 . Find the word pattern for each cipherword in the ciphertext. 

2. Find the list of English word candidates that each cipherword could decrypt to. 

3. Create one cipherletter mapping for each cipherword using the cipherword' s list of 
candidates. (A cipherletter mapping is just a dictionary value.) 

4. Intersect each of the cipherletter mappings into a single intersected cipherletter mapping. 

5. Remove any solved letters from the intersected cipherletter mapping. 

The more cipher words that are in the ciphertext, the more cipherletter mappings we have that can 
be intersected. The more cipherletter mappings we intersect together, the fewer the number of 
potential decryption letters there will be for each cipher letter. This means that the longer the 
ciphertext message, the more likely we are to hack and decrypt it. 

Explore the Hacking Functions with the Interactive Shell 

We've already described the steps used to hack a simple substitution encrypted message by using 
word patterns. Before we learn how the code in these functions works, let's use the interactive 
shell to call them and see what values they return depending on what arguments we pass them. 

Here is the example we will hack: OLQIHXIRCKGNZ PLQRZKBZB MPBKSSIPLC 

The getBlankCipherletterMapping ( ) function returns a cipherletter mapping. A 
cipherletter mapping is just a dictionary with 26 keys of uppercase single-letter strings and 
values of lists of single-letter uppercase strings like 'A' or 'Q'. We will store this blank 
cipherletter mapping in a variable named letterMappingl. Try typing the following into the 
interactive shell: 



¬ª&gt; 


letterMappingl = simpleSubHacker 


. getBlankCi pherl etterMappi ng() 




¬ª&gt; 


1 etterMappi ngl 






{'A' 


: [], ‚Ä¢C: [], 'B': [] , 'E': [] , 


'D': [], 'C: [], 'F': [] , 'I': [] , 


' H 1 : 


[], 


'K': [], 1 J 1 : [], 'M' : [] , 'L': 


[], '0': [], 'N': [], 'Q': [] , 'P': 


[], 


'S' : 


[], 'R': [], 'U': [], 'T': [] , 


'W: [], 'V: [], 'Y': [] , 'X': [] , 


'Z' : 


[]} 








¬ª&gt; 









Let's start hacking the first cipherword, OLQIHXIRCKGNZ. First we will need to get the word 
pattern for this cipherword by calling the makeWordPattern module's 
getWordPattern ( ) function. Try typing the following into the interactive shell: 



&gt;¬ª import makeWordPatterns 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 267 



¬ª&gt; wordPat = makeWordPatterns.getwordPattern(' OLQIHXIRCKGNZ') 
¬ª&gt; wordPat 

0.1.2.3.4.5.3.6.7.8.9.10.11 

¬ª&gt; 



To figure out which English words in the dictionary have the word pattern 
0.1.2.3.4.5.3.6.7.8.9.10.11 (that is, to figure out the candidates for the cipherword 
OLQIHXIRCKGNZ) we will import the wordPatterns module and look up this pattern. Try 
typing the following into the interactive shell: 



¬ª&gt; "import wordPatterns 

¬ª&gt; candidates = wordPatterns . al 1 Patterns [ ' 0 . 1. 2 . 3 . 4 . 5 . 3 . 6 . 7 . 8 . 9 . 10 . 11' ] 
¬ª&gt; candidates 

[ ' UNCOMFORTABLE 1 , 'UNCOMFORTABLY'] 

¬ª&gt; 



There are two English words that OLQIHXIRCKGNZ could decrypt to (that is, only two English 
words that have the same word pattern that OLQIHXIRCKGNZ does): UNCOMFORTABLE and 
UNCOMFORTABLY. (It's also possible that the cipherword decrypts to a word that does not 
exist in our dictionary, but we will just have to assume that's not the case.) We need to create a 
cipherletter mapping that has the cipherletters in OLQIHXIRCKGNZ map to letters in 
UNCOMFORTABLE and UNCOMFORTABLY as potential decryption letters. That is, O maps 
to U, L maps to N, Q maps to C, and so on. Z will map to two different letters: E and Y. 

We can do this with the addLettersToMapping ( ) function. We will need to pass it our 
(currently blank) cipherletter mapping in letterMappingl, the string ' OLQIHXIRCKGNZ ' , 
and the string ' UNCOMFORTABLE ' (which is the first string in the candidates list). Try 
typing the following into the interactive shell: 



¬ª&gt; letterMappingl = simpleSubHacker.addLettersToMapping(letterMappingl, 
'OLQIHXIRCKGNZ', candi dates [0] ) 
&gt;¬ª letterMappingl 

{'A': [], 'C: ['T'], 'B': [] , 'E': [] , ' D' : [] , 'C : ['B'], 'F': [] , 'I': 
['0'], 'H': [ 'M' ] , 'K': ['A'], ':': [] , 'M' : [] , 'L': ['N'], '0': ['U'], 'N': 
['L'], 'Q': ['C'], 'P': [] , 'S': [] , 'R': ['R'], 'U': [] , 'T' : [] , 'W : [] , 
'V: [], 'Y': [], 'X': ['F'], 'Z': ['E']} 

¬ª&gt; 

From the letterMappingl value, you can see that the letters in OLQIHXIRCKGNZ map to 
the letters in UNCOMFORTABLE: ' O ' maps to [ ' U ' ] , ' L ' maps to [ ' N ' ] , ' Q ' maps to 
[ ' C ' ] , and so on. 



268 http://inventwithpython.com/hacking 



But since the letters in OLQIHXIRCKGNZ could also possibly decrypt to UNCOMFORTABLY, 
we also need to add UNCOMFORTABLY to the cipherletter mapping. Try typing the following 
into the interactive shell: 



¬ª&gt; letterMappingl = simpleSubHacker.addLettersToMapping(letterMappingl, 
' OLQIHXIRCKGNZ ' , candi dates [1] ) 
&gt;¬ª letterMappingl 

{'A': [], 'C: ['T'], 'B': [] , 'E': [] , 'D': [] , 'C : ['B'], 'F': [] , 'I': 
['0'], 'H': ['M'], 'K': ['A'], [] , 'M' : [] , 'L': ['N'], '0': ['U'], 'N': 

['L'] , 'Q': ['C'], 'P': [], 'S': [] , 'R': ['R'], 'U': [] , 'T' : [] , 'W : [] , 
'V: [], 'Y': [], 'X': [ ' F' ] , 'Z': ['E', 'Y']} 

¬ª&gt; 



You'll notice that not much has changed in letterMappingl. The cipherletter mapping in 
letterMappingl now has ' Z ' map to both ' E ' and ' Y ' . That's because the candidates for 
OLQIHXIRCKGNZ (that is, UNCOMFORTABLE and UNCOMFORTABLY) are very similar 
to each other and addLettersToMapping ( ) only adds the letter to the list if the letter is not 
already there. This is why ' 0 ' maps to [ ' U ' ] instead of [ ' U ' , ' U ' ] . 

We now have a cipherletter mapping for the first of the three cipherwords. We need to get a new 
mapping for the second cipherword, PLQRZKBZB. Call 

getBlankCipherletterMapping ( ) and store the returned dictionary value in a variable 
named letterMapping2. Get the word pattern for PLQRZKBZB and use it to look up all the 
candidates in wordPatterns . allPatterns. This is done by typing the following into the 
interactive shell: 



¬ª&gt; letterMapping2 = simpleSubHacker.getBlankCipherletterMappingO 
¬ª&gt; wordPat = makeWordPatterns . getWordPattern( ' PLQRZKBZB ' ) 
¬ª&gt; candidates = wordPatterns . all Patterns [wordPat] 
¬ª&gt; candidates 

['CONVERSES', 'INCREASES', 'PORTENDED', 'UNIVERSES'] 

¬ª&gt; 

Instead of typing out four calls to addLettersToMapping ( ) for each of these four candidate 
words, we can write a for loop that will go through the list in candidates and call 
addLettersToMapping ( ) each time. 



¬ª&gt; for candidate in candidates: 

1etterMapping2 = simpleSubHacker . addLettersToMappi ng(letterMappi ng2 , 
'PLQRZKBZB' , candidate) 

¬ª&gt; letterMapping2 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 269 



{'A': I"! 

L " ‚ñ† L J j 


'C : Tl 'B' ‚ñ† T'S' 'D'l . 


'E' 


n 


'D 


'‚ñ† n 'C: n 

LJ ! ""J ‚ñ† LJ i 


'F' : [] , 'I' : 


[], 'H' : 


[], 'K': ['R', 'A' , 1 N ' ] , 


' J ' : 


[], 


'M' 


: ' L 1 : ['0' 


, 'N'], '0': [], 


'N': [], 


'Q': ['N', 'C\ 'R', 'I'], 


.p. 


['C 


1 

J 


'I', 'P', 'U'], 


'S': [], 'R': 


['V, 'R' 


, 'T'], 'U': [], 'T' : [] , 


'W : 


[], 


'V 


: 'V : [], 


'X': [], 'Z': 


[ ' E 1 ] } 














¬ª&gt; 















This finishes the cipherletter mapping for our second cipherword. Now we need to get the 
intersection of the cipherletter mappings in letterMappingl and letterMapping2 by 
passing them to intersectMappings ( ) . Try typing the following into the interactive shell: 



¬ª&gt; i ntersectedMappi ng = si mpl eSubHacker . IntersectMappings (letterMappingl, 

letterMapping2) 

¬ª&gt; 1 ntersectedMappi ng 

{'A': [], 'C: ['T'], ' B' : ['S', 'D'], ' E' : [] , 'D' : [] , 'C: ['B'], 'F': [] , 
'I': ['0'], 'H': ['M'] , 'K': ['A'], ' 3' : [] , 'M': [] , 'L': ['N'], '0': ['U'], 
‚ñ†N': ['L'], 'Q': ['C'], 'P': ['C, 'I', 'P', 'IT], 'S': [] , 'R': ['R'], 'U': 
[], 'T': [], 'W: [], 'V: [] , 'Y' : [] , 'X': ['F'], 'Z' : ['E']} 

¬ª&gt; 

The intersected mapping is just a cipherletter mapping. The list of potential decryption letters for 
any cipherletter in the intersected mapping will only be the potential decryption letters that were 
in the cipherletter' s list in both letterMappingl and letterMapping2. 

For example, this is why inter sectedMapping's list for the ' Z ' key is just [ ' E ' ] : 
because letterMappingl had [ ' E ' , ' Y ' ] but letterMapping2 had [ ' E ' ] . The 
intersection of [ ' E ' , ' Y ' ] and [ ' E ' ] is just the potential decryption letters that exist in both 
mappings: [ ' E ' ] 

There is an exception. If one of the mapping's lists was blank, then all of the potential decryption 
letters in the other mapping are put into the intersected mapping. This is because in our program a 
blank map represents any possible letter can be used since nothing is known about the mapping. 

Then we do all these steps for the third cipherword, MPBKSSIPLC. Try typing the following into 
the interactive shell: 



¬ª&gt; 1 etterMappi ng3 = simpleSubHacker.getBlankCipherletterMappingO 

¬ª&gt; wordPat = makeWordPatterns.getWordPatternC MPBKSSIPLC) 

¬ª&gt; candidates = wordPatterns . al 1 Patterns [wordPat] 

¬ª&gt; candidates 

['ADMITTEDLY', 'DISAPPOINT'] 

&gt;¬ª for i in range(len(candidates)) : 



270 http://inventwithpython.com/hacking 



TetterMappi ng3 = simpleSubHacker.addLettersToMapping(letterMapping3, 
'MPBKSSIPLC, candi dates [i]) 

¬ª&gt; letterMappi ng3 

{'A': [], 'C: ['Y', 'T'], 'B': ['M' , 'S'], 'E': [] , 1 D 1 : [] , 'C: [] , 'F': [] , 
'I': ['E', '0'], 'H': [] , 'K': ['I', 'A'], 1 J ' : [] , 'M' : ['A', 'D'], 'L': ['L', 
'N'], '0': [], 'N': [] , 'Q' : [] , 'P': [ ' D' , 'I'], 'S': ['T', 'P'], 'R': [] , 
'U': [], 'T': [], 'W: [], 'V: [] , 'Y' : [] , 'X': [] , 'Z' : []} 

We intersect letterMapping3 with intersectedMapping. This also ends up indirectly 
intersecting letterMapping3 with letterMappingl and letterMapping2, since 
intersectedMapping is currently the intersection of letterMappingl and 
letterMapping2. Try typing the following into the interactive shell: 



¬ª&gt; -intersectedMapping = si mpl eSubHacker . i ntersectMappi ngs (-intersectedMapping, 

1 etterMappi ng3) 

¬ª&gt; "intersectedMapping 

{'A': [], 'C: ['T'], 'B': ['S'], "E': [] , -D': [] , 'C: ['B'], 'F': [] , 'I': 
['0'], 'H': ['M'] , 'K': ['A'], [] , 'M' : ['A', 'D'], 'L': ['N'], '0': 

['U'], 'N': ['L'], 'Q': ['C'], 'P': ['I'], 'S': ['T', 'P'], 'R': ['R'], 'U': 
[], 'T': [], 'W: [], 'V: [] , 'Y' : [] , 'X': ['F'], 'Z': ['E']} 

¬ª&gt; 

We can now pass the intersected cipherletter mapping to 

decryptWithCipherletterMapping ( ) to decrypt the ciphertext. Try typing the 
following into the interactive shell: 



¬ª&gt; si mpl eSubHacker . decryptWi thCi pherl etterMappi ng( ' OLQIHXIRCKGNZ PLQRZKBZB 
MPBKSSIPLC , intersectedMapping) 
UNCOMFORTABLE INCREASES _ISA_0INT 

¬ª&gt; 

The intersected mapping is not yet complete. Notice how the intersected mapping has a solution 
for the cipherletter K, because the key ' K ' 's value to a list with just one string in it: [ ' A ' ] . 
Because we know that the K cipherletters will decrypt to A, no other cipherletter can possibly 
decrypt to A. 

In the intersected mapping, the cipherletter M maps to [ ' A' , ' D ' ] . This means that judging 
from the candidates for the cipherwords in our encrypted message, the cipherletter M could 
decrypt to A or D. 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 271 



But since we know K decrypts to A, we can remove A from the list of potential decryption letters 
for cipherletter M. This shortens the list down to just [ ' D ' ] . Because this new list only has one 
string in it, we've also solved the cipherletter M! 

The removeSolvedLettersFromMapping ( ) function takes a cipherletter mapping and 
removes these solved potential decryption letters from the other cipher letters' lists. Try typing the 
following into the interactive shell: 



¬ª&gt; 1 etterMappi ng = removeSolvedLettersFromMapping(letterMapping) 
¬ª&gt; i ntersectedMappi ng 

{'A': [], 'C: ['T'], 'B': ['S'], ' E' : [] , 'D': [] , 'C: ['B'], 'F': [] , 'I': 
['0'], 'H': ['M'] , 'K': ['A'], [] , 'M 

': ['D'], 'L': ['N'], '0': ['U'], 'N': ['L'], 'Q' : ['C'], 'P': ['I'], 'S': 
['P'], 'R': ['R'], 'U': [] , 'T': [] , 'W : [] , 
'V: [], 'Y': [], 'X': ['F'], 'Z' : ['E']} 

¬ª&gt; 

Now when we pass the intersected mapping to decryptWithCipherletterMapping ( ) , it 
gives us the full solution. Try typing the following into the interactive shell: 



¬ª&gt; si mpl eSubHacker . decryptWi thCi pherl etterMappi ng( ' OLQIHXIRCKGNZ PLQRZKBZB 
MPBKSSIPLC, i ntersectedMappi ng) 
UNCOMFORTABLE INCREASES DISAPPOINT 

¬ª&gt; 



The ciphertext OLQIHXIRCKGNZ PLQRZKBZB MPBKSSIPLC decrypts to the message, 
"Uncomfortable increases disappoint". 

This is a rather short ciphertext to hack. Normally the encrypted messages we hack will be much 
longer. (Messages as short as our example usually cannot be hacked with our word pattern 
method.) We'll have to create a cipherletter mapping for each cipherword in these longer 
messages and then intersect them all together, which is exactly what the hackSimpleSub ( ) 
function does. 

Now that we know the basic steps and what each function does, let's learn how the code in these 
functions work. 

How the Program Works 

si mpl eSubHacker. py 

1. # Simple Substitution Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 



272 http://inventwithpython.com/hacking 

The comments at the top of the source code explain what the program is. 

Import All the Things 

simpleSubHacker. py 

4. import os, re, copy, pprint, pyperclip, simpleSubCipher, makeWordPatterns 

Our simple substitution hacking program imports eight different modules, more than any other 
program so far. By reusing the code in these modules, our hacking program becomes much 
shorter and easier to write. 

The re module is a module we haven't seen before. This is the regular expression module which 
lets our code do sophisticated string manipulation. Regular expressions are explained in the next 
section. 



simpleSubHacker. py 

6. if not os . path . exi sts( 1 wordPatterns . py ' ) : 

7. makeWordPatterns .mai n() # create the wordPatterns . py file 

8. import wordPatterns 

The simple substitution cipher also needs the wordPatterns module. The .py file for this 
module is created when the makeWordPatterns . py program is run. But 
makeWordPatterns. py might not have been run before our hacking program has. In this case, our 
hacking program checks if this file exists on line 6 and if it doesn't, the 
makeWordPatterns . main ( ) function is called. 

Remember, the main ( ) function is the function that is run in our programs when they are run as 
programs (rather than just imported with an import statement.) When we imported the 
makeWordPatterns module on line 4, the main ( ) function in makeWordPatterns. py was 
not run. Since main ( ) is the function that creates the wordPatterns. py file, we will call 
makeWordPatterns .main ( ) if wordPatterns. py does not yet exist. 

Either way, by the time the program execution reaches line 8, the wordPatterns module will 
exist and can be imported. 

A Brief Intro to Regular Expressions and the sub() Regex Method 

simpleSubHacker. py 

10. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

11. nonLettersOrSpacePattern = re . compi 1 e( ' [AA-Z\s] ' ) 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 273 



The simple substitution hacking program will have a LETTERS global variable like many of our 
previous cipher programs. 

The re . compile ( ) function is new. This function compiles (that is, creates) a new regular 
expression pattern object, or "regex object" or "pattern object" for short. Regular expressions are 
strings that define a specific pattern that matches certain strings. Regular expressions can do 
many special things with strings that are beyond the scope of this book, but you can learn about 
them at http://inypy.conVregex. 

The string ' [ A A-Za-z\s] ' is a regular expression that matches any character that is not a 
letter from A to Z or a "whitespace" character (e.g. a space, tab, or newline character). The 
pattern object has a sub ( ) method (short for "substitute") that works very similar to the 
replace ( ) string method. The first argument to sub ( ) is the string that replaces any instances 
of the pattern in the second string argument. Try typing the following into the interactive shell: 



¬ª&gt; pat = re.compileC [aa-Z\s] ') 

¬ª&gt; pat.subC'abc' , 'ALL! NON! LETTERS? AND123 NONSPACES. REPLACED') 
' ALLabc NONabcLETTERSabc ANDabcabcabc NONSPACESabc REPLACED' 
¬ª&gt; pat.subC", 'ALL! NON ! LETTERS? AND123 NONSPACES. REPLACED') 
'ALL NONLETTERS AND NONSPACES REPLACED' 

¬ª&gt; 

There are many sophisticated string manipulations you can perform if you learn more about 
regular expressions, but we will only use them in this book to remove characters from a string 
that are not uppercase letters or spaces. 

The Hacking Program's main ( ) Function 

simp! eSubHacker . py 

13. def main() : 

14. message = 'Sy 1 nix sr pyyacao 1 ylwj eiswi upar lulsxrj isr 
sxrjsxwjr, la esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr 
pqacei amnsxu , la esmm caytra jp famsaqa sj . Sy, px jia pjlac Ilxo, ia sr 
pyyacao rpnajisxu eiswi lyypcor 1 cal rpx ypc lwjsxu sx lwwpcolxwa jp isr 
sxrjsxwjr, ia esmm lwwabj sj aqax px jia rmsuijarj aqsoaxwa. Jia pcsusx py 
nhjir sr agbmlsxao sx jisr elh. -Facjclxo Ctrramm' 

15. 

16. # Determine the possible valid ciphertext translations. 

17. pri nt( 1 Hacki ng . . . ' ) 

18. 1 etterMappi ng = hackSimpl eSub(message) 

Like all our previous hacking programs, the main ( ) function will store the ciphertext to be 
hacked in a variable named message. We will pass this variable to the hackSimpleSub ( ) 



274 http://inventwithpython.com/hacking 

function. However, unlike our previous hacking programs, the hacking function will not return a 
string of the decrypted message (or None if it was unable to decrypt it). 

Instead, hackSimpleSub ( ) will return a cipherletter mapping (specifically, an intersected 
cipherletter mapping that had the solved letters removed, like the kind we made in our interactive 
shell exercise). This returned cipherletter mapping will be passed to 
decryptWithCipherletterMapping ( ) to decrypt the ciphertext in message. 



Partially Hacking the Cipher 







si mpl eSubHacke r. py 


20. 


# Display the results to the user. 




21. 


pri nt( 1 Mappi ng : ' ) 




22. 


ppri nt . ppri nt(IetterMappi ng) 




23. 


pri nt() 





Since the cipherletter mapping stored in letterMapping is a dictionary, we can use the 
pprint . ppr int ( ) "pretty print" function to display it on the screen. It will look something 
like this: 



{'A' 


[ ' E' ] , 






'B' 


['B', 




'P'], 


'C 


[ ' R' ] &gt; 






'D' 


[], 






'E' 


['K', 






'F' 


['B', 


‚ñ†P'], 




'C 


['B', 




'X', 


'H' 


['B', 


'K', 


'P', 


'I' 


['H'] , 








['T'], 






'K' 


[], 






'L' 


['A'] , 






'M' 


['L'] &gt; 






'N' 


[ 'M 1 ] , 






'0' 


['D'] , 






‚ñ† p. 


['0'] , 






'Q' 


['V'] , 






'R' 


['S'] , 






'S' 


['I'], 






'T' 


['U'] , 






'U' 


[ 'C ] , 






'V 


[], 






'VI' 


['C'], 






'X' 


['N'] , 







Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 275 



'Y': ['F'], 
'Z': ['Z']} 

In the above example, the cipherletters A, C, I, J, L, M, N, O, P, Q, R, S, T, U, X, Y, and Z all 
have one and only one potential decryption letter. These cipher letters have been solved. The 
decryptWithCipherletterMapping ( ) function, explained later, will print underscores 
for any cipherletters that have not been solved (that is, B, D, E, F, G, H, K, and V.) 







simpl eSubHacker. py 


24. 


printC Original ci phertext : ' ) 




25. 


pri nt(message) 




26. 


pri nt() 





First the original encrypted message is displayed on the screen so the programmer can compare it 
to the decryption. 



simpleSubHacker. py 

27. pri nt( 1 Copyi ng hacked message to clipboard:') 

28. hackedMessage = decryptWi thCi pherl etterMappi ngCmessage , 1 etterMappi ng) 

29 . pypercl i p . copy (hackedMessage) 

30. print(hackedMessage) 

Next the decrypted message is returned from the decryptWithCipherletterMapping ( ) 
function on line 28. This hacked message is copied to the clipboard on line 29 and printed to the 
screen on line 30. 

Next, let's look at all the functions that are called by main ( ) . 



Blank Cipherletter Mappings 











simpl eSubHacker. py 


33. 


def getBlankCipherletterMappingO : 








34. 


# Returns a dictionary value that is a 


blank 


ci ph 


erletter mapping. 


35. 


return {'A' : [] , 'B' : [] , 'C : [] , 'D' : 


[] , 


'E' : 


[], ' F' : [], 'C: [], 


'H' : 


[], 'I': [], ' J ' : [], ' K' : [] , 'L': [] , 'M' 


: [], 


'N' : 


[], '0': [], 'P': 


[], 


'Q': [], 'R': [] , 'S': [] , 'T' : [] , 'U': [] , 


'V : 




'W: [], 'X': [], 


'Y' : 


[], 'Z': []} 









Our program will need a cipherletter mapping for each cipherword in the ciphertext, so we will 
create the getBlankCipherletterMapping ( ) function which can return a new, blank 
mapping when called. 



276 http://inventwithpython.com/hacking 

Adding Letters to a Cipherletter Mapping 

simpleSubHacker. py 

38. def addLettersToMapping(letterMapping, cipherword, candidate): 

The addLettersToMapping ( ) function attempts to make sure that every letter in the 
candidate can be mapped to a letter in the cipherword. It checks over each letter in candidate 
and adds its corresponding letter in cipherword to letterMapping if it wasn't already 
there. 

For example, if ' PUPPY ' is our candidate word for the ' HGHHU ' cipherword, the 
addLettersToMapping ( ) function will change letterMapping so that the key ' H ' has 
' P ' added to its list of potential decryption letters. Then the function will change the key ' G ' so 
that its list has ' U ' appended to it. 

If the letter is already in the list of potential decryption letters, the addLettersToMapping ( ) 
will not add a letter to the list. We can skip adding ' P ' to the ' H ' key the next two times since 
it's already been done. Finally, the function will change the key ' U ' so that it has ' Y ' in its list 
of potential decryption letters. 



The code in this function assumes that len (cipherword) is the same as len (candidate) . 







simpl eSubHacker. py 


49. 


letterMapping = copy.deepcopy(letterMapping) 





To avoid changing the original dictionary value passed for the letterMapping parameter, line 
49 will copy the dictionary in letterMapping and make this copy the new value in 
letterMapping. (We have to do this because letterMapping was passed a copy of a 
dictionary reference value, instead of a copy of the dictionary value. See the "List Reference" 
section in Chapter 10 for an explanation of references.) 







simpl eSubHacker. py 


50. 


for i in range(len(cipherword)) : 





Line 50 will iterate over each index in the string in cipherword. We need the index (which is 
stored in the variable i) because the potential decryption letter to be added will be 
candidate [ i ] for the cipherletter cipherword [ i ] . 



simpleSubHacker. py 

51. if candidate[i] not in letterMapping[cipherword[i]] : 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 277 



52. letterMapping[cipherword[i]] . append (candi date [1]) 

The if statement on line 51 checks that the potential decryption letter is not already in the list of 
potential decryption letters for the cipherletter. This prevents the list of potential decryption 
letters in the cipherletter mapping from having duplicate letters in it. For example, we never want 
the list to be a value like [ ' U ' , ' U ' ] . 



Line 52 adds the new potential decryption letter (that is, candidate [ i ] ) to the list of potential 
decryption letters in the cipherletter mapping (that is, letterMapping [ cipherword [ i ] ] ). 







simpl eSubHacker. py 


53. 


return letterMapping 





After looping through all the indexes in cipherword, the additions to the cipherletter mapping 
are complete and the dictionary in letterMapping is returned. 



Intersecting Two Letter Mappings 



simpleSubHacker. py 

56. def i ntersectMappi ngs(mapA, mapB) : 



57. # To "intersect two maps, create a blank map, and then add only the 

58. # potential decryption letters if they exist in BOTH maps. 

59. i ntersectedMappi ng = getBlankCipherletterMappingO 

60. for letter in LETTERS: 



The intersectMappings ( ) function will return a new cipherletter mapping that is an 
intersection of the two cipherletter mappings passed for the mapA and mapB parameters. Line 59 
creates a new cipherletter mapping by calling getBlankCipherletterMapping ( ) and 
storing the returned value in the intersectedMapping variable. 

The for loop will loop through each of the uppercase letters in the LETTERS constant variable, 
and the letter variable can be used for the keys of the mapA and mapB dictionaries. 



simpleSubHacker. py 

62. # An empty list means "any letter is possible". In this case just 

63. # copy the other map entirely. 

64. if mapA [letter] == [] : 

65. intersectedMapping[letter] = copy.deepcopy(mapB[letter]) 

66. elif mapB[letter] == [] : 

67. intersectedMapping[letter] = copy.deepcopy(mapA[letter]) 



278 http://inventwithpython.com/hacking 



If the list of potential decryption letters for a cipherletter in a cipherletter mapping is blank, this 
means that this cipherletter could potentially decrypt to any letter. In this case, the intersected 
cipherletter mapping will just be a copy of the other mapping's list of potential decryption letters. 

That is, if mapA's list of potential decryption letters is blank, then set the intersected mapping's 
list to be a copy of mapB's list. Or if mapB's list is blank, then set the intersected mapping's list 
to be a copy of mapA's list. 



(If both mappings' lists were blank, then line 65 will simply copy mapB's blank list to the 
intersected mapping. This is the behavior we want: if both lists are blank then the intersected 
mapping will have a blank list.) 





simpl eSubHacker . py 


68. 


else: 


69. 


# If a letter in mapA[l etter] exists in mapB [letter] , add 


70. 


# that letter to i ntersectedMappi ng [1 etter] . 


71. 


for mapped Letter in mapA[letter] : 


72. 


if mappedLetter in mapB [1 etter] : 


73. 


i ntersectedMappi ng [1 etter] . append(mappedLetter) 



The else block handles the case where neither map A nor mapB are blank. In this case, line 71 
loops through the uppercase letter strings in the list at map A [letter ] . Line 72 checks if this 
uppercase letter in map A [letter ] also exists in the list of uppercase letter strings in 
mapB [letter] . If it does, then line 73 will add this common letter to the list of potential 
decryption letters at inter sectedMapping [ letter] . 







simpl eSubHacker . py 


75. 


return i ntersectedMappi ng 





Once the for loop that started on line 60 has finished, the cipherletter mapping in 
intersectedMapping will only have the potential decryption letters that exist in the lists of 
potential decryption letters of both mapA and mapB. This completely intersected cipherletter 
mapping is returned on line 75. 



Removing Solved Letters from the Letter Mapping 



simpleSubHacker. py 

78. def removeSolvedLettersFromMapping(letterMapping) : 



79. # Cipher letters in the mapping that map to only one letter are 

80. # "solved" and can be removed from the other letters. 

81. # For example, if 'A' maps to potential letters [ 'M' , 'N'], and 'B' 

82. # maps to ['N'], then we know that 'B' must map to ' N' , so we can 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 279 



83. # remove 'N' from the list of what 'A' could map to. So 'A' then maps 

84. # to ['M']. Note that now that 'A' maps to only one letter, we can 

85. # remove 'M' from the list of potential letters for every other 

86. # key. (This is why there is a loop that keeps reducing the map.) 

87. letterMapping = copy.deepcopy(letterMapping) 

88. loopAgain = True 



The removeSolvedLettersFromMapping ( ) function searches for any cipherletters in the 
letterMapping parameter which have one and only one potential decryption letter. These 
cipherletters are considered solved: the cipherletter must decrypt to that one potential decryption 
letter. This means that any other cipherletters that have this solved letter can have that letter 
removed from their lists of potential decryption letters. 

This could cause a chain reaction, because when the one potential decryption letter is removed 
from other lists of potential decryption letters, it could result in a new solved cipherletter. In that 
case, the program will loop and perform the solved letter removal over the whole cipherletter 
mapping again. 

The cipherletter mapping in letterMapping is copied on line 87 so that changes made to it in the 
function do not affect the dictionary value outside the function. Line 88 creates loopAgain, 
which is a variable that holds a Boolean value that tells us if the code found a new solved letter 
and needs to loop again. In that case the loopAgain variable is set to True on line 88 so that 
the program execution will enter the while loop on line 89. 







simpl eSubHacker. py 


89. 


while loopAgain: 




90. 


# First assume that we will not loop again: 




91. 


loopAgain = False 





At the very beginning of the loop, line 91 will set loopAgain to False. The code assumes that 
this will be the last iteration through line 89's while loop. The loopAgain variable is only set 
to True if we find a new solved cipherletter during this iteration. 



simpl eSubHacker. py 

93. # sol vedLetters will be a list of uppercase letters that have one 

94. # and only one possible mapping in letterMapping 

95. sol vedLetters = [] 

96. for cipherletter in LETTERS: 

97. if len(letterMapping[cipherletter]) == 1: 

98. sol vedLetters . append(l etterMappi ng [ci pherl etter] [0]) 



280 http://inventwithpython.com/hacking 



The next part of the code creates a list of cipherletters that have exactly one potential decryption 
letter. We will put these cipherletter strings in a list that is in solvedLetters. The 
solvedLetters variable starts off as a blank list on line 95. 

The for loop on line 96 goes through all 26 possible cipherletters and looks at the cipherletter 
mapping's list of potential decryption letters for that cipherletter. (That is, the list is at 

letterMapping [ cipherletter] .) 

If the length of this list is 1 (which is checked on line 97), then we know that there is only one 
letter that the cipherletter could decrypt to and the cipherletter is solved. We will add the letter 
(the potential decryption letter, not the cipherletter) to the solvedLetters list on line 98. The 
solved letter will always be at letterMapping [ cipherletter] [ 0 ] because 
letterMapping [cipherletter] is a list of potential decryption letters that only has one 
string value in it at index 0 of the list. 





simpl eSubHacker . py 


100. 


# If a letter is solved, than it cannot possibly be a potential 


101. 


# decryption letter for a different ciphertext letter, so we 


102. 


# should remove it from those other lists. 


103. 


for cipherletter in LETTERS: 


104. 


for s in solvedLetters: 


105. 


if len(letterMapping[cipherletter]) != 1 and s in 


letterMapping [cipherletter] : 


106. 


1 etterMappi ng [ci pherl etter] . remove(s) 



After the previous for loop that started on line 96 has finished, the solvedLetters variable 
will be a list of all the letters that are solved decryptions of a cipherletter. The for loop on line 
103 loops through all 26 possible cipherletters and looks at the cipherletter mapping's list of 
potential decryption letters. 



For each cipherletter that is examined, the letters in solvedLetters are looped through on 
line 104 to check if each of them exist in the list of potential decryption letters for 
letterMapping [cipherletter]. Line 105 checks if a list of potential decryption letters is 
not solved (that is, if len (letterMapping [cipherletter] ) != 1) and the solved 
letter exists in the list of potential decryption letters. If this condition is True, then the solved 
letter in s is removed from the list of potential decryption letters on line 106. 



simpleSubHacker. py 

107. if len(letterMapping[cipherletter]) == 1: 

108. # A new letter is now solved, so loop again. 

109. loopAgain = True 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 281 



If by chance this removal caused the list of potential decryption letters to now only have one 
letter in it, then the loopAgain variable is set to True on line 109 so that the code will check 
for this new solved letter in the cipherletter mapping on the next iteration. 







simpl eSubHacker . py 


110. 


return letterMappi ng 





After the code in line 89's while loop has gone through a full iteration without loopAgain 
being set to True, the program execution goes past the loop and returns the cipherletter mapping 
stored in letterMapping. 



Hacking the Simple Substitution Cipher 





simpl eSubHacker . py 


113. def hackSimpleSub(message) : 




114. i ntersectedMap = getBlankCipherletterMappingO 





Now that we've created the getBlankCipherletterMapping ( ) , 
addLettersToMapping ( ) , intersectMappings ( ) , and 

removeSolvedLettersFromMapping ( ) functions that can manipulate the cipherletter 
mappings we pass them, we can use them all together to hack a simple substitution message. 



Remember the steps from our interactive shell exercise for hacking a simple substitution cipher 
message: for each cipherword, get all the candidates based on the cipherword's word pattern, then 
add these candidates to a cipherletter mapping. Then take the cipherletter mapping for each 
cipherword and intersect them together. 

The inter sectedMap variable will hold the intersected cipherletter mapping of each 
cipherword's cipherletter mapping. At the beginning of the hackSimpleSub ( ) function, it 
will start as a blank cipherletter mapping. 



simpleSubHacker. py 

115. ci pherwordLi st = nonLettersOrSpacePattern . sub( 1 ' , 
message . upper 0) . spl it() 

The sub ( ) regex method will substitute (that is, replace) any occurrences of the string pattern in 
the second argument (message . upper ( ) ) with the first argument (a blank string). Regular 
expressions and the sub ( ) method were explained earlier in this chapter. 

On line 115, the regex object in nonLettersOrSpacePattern matches any string that is not 
a letter or whitespace character. The sub ( ) method will return a string that is the message 



282 http://inventwithpython.com/hacking 

variable with all non-letter and non-space characters replaced by a blank string. This effectively 
returns a string that has all punctuation and number characters removed from me s sage. 

This string then has the upper ( ) method called on it to return an uppercase version of the 
string, and that string has the split ( ) method called on it to return the individual words in the 
string in a list. To see what each part of line 1 15 does, type the following into the interactive 
shell: 



¬ª&gt; import re 

¬ª&gt; nonLettersOrSpacePattern = re . compi 1 e( ' [AA-Z\s] ' ) 

¬ª&gt; message = 'Hello, this is my 1st test message.' 

¬ª&gt; message = nonLettersOrSpacePattern . sub( ' 1 , message . upperO) 

¬ª&gt; message 

'HELLO THIS IS MY ST TEST MESSAGE' 
¬ª&gt; ci pherwordLi st = message. splitC) 
¬ª&gt; ci pherwordLi st 

['HELLO', 'THIS', 'IS', 'MY', 'ST', 'TEST', 'MESSAGE'] 

After line 115 executes, the cipherwordList variable will contain a list of uppercase strings 
of the individual words that were previously in message. 



simpl eSubHacker . py 

116. for cipherword in cipherwordList: 

117. # Get a new cipherletter mapping for each ciphertext word. 

118. newMap = getBl ankCi pherl etterMappi ngQ 



The for loop on line 116 will assign each string in the message list to the cipherword 
variable. Inside this loop we will get the cipherword' s candidates, add the candidates to a 
cipherletter mapping, and then intersect this mapping with intersectedMap. 

First, line 118 will get a new, blank cipherletter mapping from 
getBlankCipherletterMapping ( ) and store it in the newMap variable. 



simpleSubHacker. py 

120. wordPattern = makeWordPatterns . getWordPattern(ci pherword) 

121. if wordPattern not in wordPatterns . al 1 Patterns : 

122. continue # This word was not in our dictionary, so continue. 



To find the candidates for the current cipherword, we call getWordPattern ( ) in the 
makeWordPatterns module on line 120. If the word pattern of the cipherword does not exist 
in the keys of the wordPatterns . allPatterns dictionary, then whatever the cipherword 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 283 



decrypts to does not exist in our dictionary file. In that case the continue statement on line 122 
will skip back to line 1 16, to the next cipherword in the list. 



simpl eSubHacker. py 

124. # Add the letters of each candidate to the mapping. 

125. for candidate in wordPatterns . al 1 Patterns [wordPattern] : 

126. newMap = addLettersToMappi ng(newMap , cipherword, candidate) 



On line 125, we know the word pattern exists in wordPatterns . allPatterns. The values 
in the allPatterns dictionary are lists of strings of the English words with the pattern in 
wordPattern. Since it is a list, we can use a for loop to iterate over this list. The variable 
candidate will be set to each of these English word strings on each iteration of the loop. 



The only line inside line 125's for loop is the call to addLettersToMapping ( ) on line 126. 
We will use this to update the cipherletter mapping in newMap with the letters in each of the 
candidates. 







simpl eSubHacker. py 


128. 


$ Intersect the 


new mapping with the existing intersected mapping. 


129. 


i ntersectedMap = 


i nte rsectMappi ngs (i ntersectedMap , newMap) 



Once all of the letters in the candidates are added to the cipherletter mapping in newMap, line 
129 will intersect newMap with intersectedMap, and make the return value the new value of 

inter sectedMap. 



At this point the program execution jumps back to the beginning of the for loop on line 116 to 
run the code on the next cipherword in the cipherwordList list. 







simpl eSubHacker . py 


131. 


# Remove any solved letters from the other lists. 




132. 


return removeSol vedLettersFromMappi ng(i ntersectedMap) 





Once we have the final intersected cipherletter mapping, we can remove any solved letters from it 
by passing it to removeSolvedLettersFromMapping ( ) . The cipherletter mapping that is 
returned from the function will be the return value for hackSimpleSubstitution ( ) . 



Creating a Key from a Letter Mapping 

simpleSubHacker. py 

135. def decryptWithCipherletterMapping(ciphertext, letterMappi ng) : 

136. # Return a string of the ciphertext decrypted with the letter mapping, 

137. # with any ambiguous decrypted letters replaced with an _ underscore. 



284 http://inventwithpython.com/hacking 



138. 

139. # First create a simple sub key from the 1 etterMappi ng mapping. 

140. key = ['x'] * Ten (LETTERS) 

Since the simpleSubstitutionCipher . decryptMessage () function only decrypts 
with keys instead of letter mappings, we need the decryptWithCipherletterMapping ( ) 
function to convert a letter mapping into a string key. 

The simple substitution keys are strings of 26 characters. The character at index 0 in the key 
string is the substitution for A, the character at index 1 is the substitution for B, and so on. 

Since the letter mapping might only have solutions for some of the letters, we will start out with a 
key of ['x', ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , ' x ' , 

' x ' ] . This list is created on line 140 by using list replication to replicate the list [ ' x ' ] 26 
times. Since LETTERS is a string of the letters of the alphabet, len (LETTERS) evaluates to 
2 6. When the multiplication operator is used on a list and integer, it does list replication. 

We don't have to use ' x ' , we can use any lowercase letter. The reason we need to use a 
lowercase letter is because it acts as a "placeholder" for the simple substitution key. The way 
simpleSubCipher.py works, since LETTERS only contains uppercase letters, any lowercase letters 
in the key will not be used to decrypt a message. 



The 26-item list in key will be joined together into a 26-character string at the end of the 

decryptWithCipherletterMapping () function. 





simpl eSubHacker . py 


141. 


for cipherletter in LETTERS: 


142. 


if lenOetterMapping [cipherletter]) == 1: 


143. 


# If there's only one letter, add it to the key. 


144. 


keylndex = LETTERS . f i nd (1 etterMappi ng [ci pherl etter] [0] ) 


145. 


key [keylndex] = cipherletter 



The for loop on line 141 will let us go through each of the letters in LETTERS for the 
cipherletter variable, and if the cipherletter is solved (that is, 

letterMapping [ cipherletter ] has only one letter in it) then we can replace an ' x' in 
the key with the letter. 



So on line 144 letterMapping [cipherletter] [ 0 ] is the decryption letter, and 
keylndex is the index of the decryption letter in LETTERS (which is returned from the 
f ind ( ) call). This index in the key list is set to the decryption letter on line 145. 



Email questions to the author: al@inventwithpython.com 



Chapter 18 - Hacking the Simple Substitution Cipher 285 









simpl eSubHacker . py 


146. 


else: 






147. 


ciphertext = ciphertext 


repl ace(ci pherl etter 


lowerO, '_') 


148. 


ciphertext = ciphertext 


repl ace(ci pherl etter 


upperQ, '_') 



Or else, if the cipherletter does not have a solution, then we want to replace everywhere that 
cipherletter appears in the ciphertext with an underscore so the user can tell which characters 
were unsolved. Line 147 handles replacing the lowercase form of cipherletter with an 
underscore and line 148 handles replacing the uppercase form of cipherletter with an 
underscore. 









simpl eSubHacker . py 


149. 


key = 


' .join (key) 




150. 








151. 


# With 


the key we've created, decrypt the 


ci phertext . 


152. 


return 


simpleSubCi pher . decryptMessage(key , 


ci phertext) 



When we have finally replaced all the parts in the list in key with the solved letters, we convert 
the list of strings into a single string with the join ( ) method to create a simple substitution key. 
This string is passed to the decryptMes sage ( ) function in our simpleSubCipher.py program. 



The decrypted message string returned from decryptMes sage ( ) is then returned from 

decryptWithCipherletterMapping ( ) online 152. 









simpl eSubHacker. py 


155. 


if name 


= ' mai n ' : 




156. 


mai n() 







That completes all the functions our hacking program needs. Lines 155 and 156 just call the 
main ( ) function to run the program if simpleSubHacker.py is being run directly, instead of 
being imported as a module by another Python program. 



Couldn't We Just Encrypt the Spaces Too? 

Yes. Our hacking approach only works if the spaces were not encrypted. You can modify the 
simple substitution cipher from the previous chapter to encrypt spaces, numbers, and punctuation 
characters as well as letters, and it would make your encrypted messages harder (but not 
impossible) to hack. However, since the spaces will probably be the most common symbol in the 
ciphertext, you can write a program to replace it back to spaces, and then hack the ciphertext as 
normal. So encrypting the space characters would not offer much more protection. 



286 http://inventwithpython.com/hacking 



Summary 

Whew! This hacking program was fairly complicated. The cipherletter mapping is the main tool 
for modeling the possible letters that each ciphertext letter can decrypt to. By adding letters 
(based on the candidates for each cipherword) to the mapping, and then intersecting mappings 
and removing solved letters from other lists of potential decryption letters, we can narrow down 
the number of possible keys. Instead of trying all 403,291,461,126,605,635,584,000,000 possible 
keys we can use some sophisticated Python code to figure out exactly what most (if not all) of the 
original simple substitution key was. 

The main strength of the simple substitution cipher is the large number of possible keys. But the 
downfall is that it is easy enough to compare the cipherwords to words in a dictionary file to 
slowly figure out which cipherletters decrypt to which letters. The next chapter's cipher is much 
more powerful. For several hundred years, it was considered impossible to break. It is a 
"polyalphabetic" substitution cipher called the Vigenere cipher. 



Email questions to the author: al@inventwithpython.com 



Chapter 19 - The Vigenere Cipher 287 



Chapter 19 



The Vigenere Cipher 



Topics Covered In This Chapter: 
‚Ä¢ Subkeys 



"I believed then, and continue to believe now, that 
the benefits to our security and freedom of widely 
available cryptography far, far outweigh the 
inevitable damage that comes from its use by 
criminals and terrorists... I believed, and continue 
to believe, that the arguments against widely 
available cryptography, while certainly advanced 
by people of good will, did not hold up against the 
cold light of reason and were inconsistent with the 
most basic American values." 

Matt Blaze, AT&amp;T Labs, September 2001 




288 http://inventwithpython.com/hacking 



Le Chiffre Indechiffrable 

The Vigenere cipher is a stronger cipher than the ones we've seen before. There are too many 
possible keys to brute -force, even with English detection. It cannot be broken with the word 
pattern attack that worked on the simple substitution cipher. It was possibly first described in 
1553 by Italian cryptographer Giovan Battista Bellaso (though it has been reinvented many times, 
including by Blaise de Vigenere). It is thought to have remained unbroken until Charles Babbage, 
considered to be the father of computers, broke it in the 19 th century. It was called "le chiffre 
indechiffrable", French for "the indecipherable cipher". 




Figure 19-1. Blaise de Vigenere Figure 19-2. Charles Babbage 

April 5, 1523 - 1596 December 26, 1791 - October 18, 1871 

Multiple "Keys" in the Vigenere Key 

The Vigenere cipher is similar to the Caesar cipher, except with multiple keys. Because it uses 
more than one set of substitutions, it is also called a polyalphabetic substitution cipher. 

Remember that the Caesar cipher had a key from 0 to 25. For the Vigenere cipher, instead of 
using a numeric key, we will use a letter key. The letter A will be used for key 0. The letter B will 
be used for key 1, and so on up to Z for the key 25. 



0 


1 


2 


3 


4 


5 


6 


7 


8 


9 


10 


11 


12 


A 


B 


C 


D 


E 


F 


G 


H 


I 


J 


K 


L 


M 




13 


14 


15 


16 


17 


18 


19 


20 


21 


22 


23 


24 


25 


N 


0 


P 


Q 


R 


S 


T 


U 


V 


W 


X 


Y 


Z 



Email questions to the author: al@inventwithpython.com 



Chapter 19 - The Vigenere Cipher 289 



The key in a Vigenere cipher is a series of letters, such as a single English word. This single 
word key will be split into multiple subkeys. If we use a Vigenere key of "PIZZA", then the 
first subkey is P, the second subkey is I, the third and fourth subkeys are both Z and the fifth 
subkey is A. We will use the first subkey to encrypt the first letter of the plaintext, and the second 
subkey to encrypt the second letter, and so on. When we get to the sixth letter of the plaintext, we 
will go back to using the first subkey. 

The Vigenere cipher is the same as using multiple Caesar ciphers in the same message. 



Figure 19-3. Multiple Caesar ciphers combine to make the Vigenere cipher 

1st 2nd 3rd 4th 5th 

Subkey Subkey Subkey Subkey Subkey 




The following shows which subkey will encrypt which letters in the message, "Common sense is 
not so common." with the Vigenere key, "PIZZA". 



C0MM0NSENSEISN0TS0C0MM0N 
PIZZAPIZZAPIZZAPIZZAPIZZ 



To encrypt the first C with the subkey P, encrypt it with the Caesar cipher using numeric key 15 
(15 is the number for the letter P) which creates the ciphertext R, and so on. Do this for each of 
the letters of the plaintext. The following table shows this process: 



290 http://inventwithpython.com/hacking 



Table 19-1. Numbers of the letters before and after encryption. 



Plaintext Subkey Ciphertext 

Letter Letter 

C(2) P(15) -¬ª R(17) 

0(14) 1(8) -¬ª W(22) 

M(12) Z(25) -¬ª L(ll) 

M(12) Z(25) -¬ª L(ll) 

0(14) A(0) -¬ª 0(14) 

N(13) P(15) -¬ª C(2) 

S (18) 1(8) -¬ª A(0) 

E(4) Z(25) -¬ª D(3) 

N(13) Z(25) -¬ª M(12) 

S (18) A(0) -¬ª S (18) 

E(4) P(15) -¬ª T(19) 

1(8) 1(8) - Q(16) 

S (18) Z(25) -¬ª R(17) 

N(13) Z(25) -¬ª M(12) 

0(14) A(0) -¬ª 0(14) 

T(19) P(15) -¬ª 1(8) 

S (18) 1(8) -¬ª A(0) 

0(14) Z(25) -¬ª N(13) 

C(2) Z(25) -¬ª B(l) 

0(14) A(0) -¬ª 0(14) 

M(12) P(15) -¬ª B(l) 

M(12) 1(8) -¬ª U(20) 

0(14) Z(25) -¬ª N(13) 

N(13) Z(25) -&gt; M(12) 



So using the Vigenere cipher with the key "PIZZA" (which is made up of the subkeys 15, 8, 25, 
25, 0) the plaintext "Common sense is not so common." becomes the ciphertext "Rwlloc admst qr 
moi an bobunm." 

The more letters in the Vigenere key, the stronger the encrypted message will be against a brute- 
force attack. The choice of "PIZZA" is a poor one for a Vigenere key, because it only has five 
letters. A key with only five letters has 11,881,376 possible combinations. (26 A 5 = 26 x 26 x 26 
x 26 x 26 = 1 1,881,376) Eleven million keys is far too many for a human to try out, but a 
computer could try them all in a few hours. It would first try to decrypt the message with the key 
"AAAAA" and check if the resulting decryption was in English. Then it could try "AAAAB", 
then "AAAAC", until it got to "PIZZA". 



Email questions to the author: al@inventwithpython.com 



Chapter 1 9 - The Vigenere Cipher 29 1 



The good news is that for every additional letter the key has, the number of possible keys 
multiplies by 26. Once there are quadrillions of possible keys, it would take a computer years to 
break. Table 19-2 shows how many possible keys there are for each length: 

Table 19-2. Number of possible keys based on Vigenere key length. 
Key Length Equation Possible Keys 



1 
1 


ZD 


‚Äî if, 

‚Äî ZD 


Z 


ZO X ZD 


‚Äî o / o 


3 


676 x 26 


= 17,576 


4 


17,576 x 26 


= 456,976 


5 


456,976 x 26 


= 11,881,376 


6 


11,881,376x26 


= 308,915,776 


7 


308,915,776 x 26 


= 8,031,810,176 


8 


8,031,810,176x26 


= 208,827,064,576 


9 


208,827,064,576 x 26 


= 5,429,503,678,976 


10 


5,429,503,678,976 x 26 


= 141,167,095,653,376 


11 


141,167,095,653,376x26 


= 3,670,344,486,987,776 


12 


3,670,344,486,987,776 x 26 


= 95,428,956,661,682,176 


13 


95,428,956,661,682,176x26 


= 2,481,152,873,203,736,576 


14 


2,481,152,873,203,736,576 x 26 


= 64,509,974,703,297,150,976 



Once we get to keys that are twelve or more letters long, then it becomes impossible for most 
consumer laptops to crack in a reasonable amount of time. 

A Vigenere key does not have to be a word like "PIZZA". It can be any combination of letters, 
such as "DURIWKNMFICK". In fact, it is much better not to use a word that can be found in the 
dictionary. The word "RADIOLOGISTS" is a 12-letter key that is easier to remember than 
"DURIWKNMFICK" even though they have the same number of letters. But a cryptanalyst 
might anticipate that the cryptographer is being lazy by using an English word for the Vigenere 
key. There are 95,428,956,661,682,176 possible 12-letter keys, but there are only about 1,800 12- 
letter words in our dictionary file. If you are using a 12-letter English word, it would be easier to 
brute-force that ciphertext than it would be to brute-force the ciphertext from a 3 -letter random 
key. 

Of course, the cryptographer is helped by the fact that the cryptanalyst does not know how many 
letters long the Vigenere key is. But the cryptanalyst could try all 1 -letter keys, then all 2-letter 
keys, and so on. 

Source Code of Vigenere Cipher Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as vigenereCipher.py . Press F5 to run the program. Note that 



292 http://inventwithpython.com/hacking 



first you will need to download the pyperclip.py module and place this file in the same directory 
as the vigenereCipher.py file. You can download this file from http;//inypy,co.nypyperclip,py. 



Source code for vigenereCipher.py 

1. # Vigenere Cipher (Polyalphabetic Substitution Cipher) 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import pyperclip 
5. 

6. LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 
7. 

8. def main() : 

9. # This text can be copy/pasted from http://invpy.com/vigenereCipher.py 

10. myMessage = """Alan Mathison Turing was a British mathematician, 
logician, cryptanalyst, and computer scientist. He was highly influential in 
the development of computer science, providing a formalisation of the concepts 
of "algorithm" and "computation" with the Turing machine. Turing is widely 
considered to be the father of computer science and artificial intelligence. 
During World War II, Turing worked for the Government Code and Cypher School 
(GCCS) at Bletchley Park, Britain's codebreaking centre. For a time he was head 
of Hut 8, the section responsible for German naval cryptanalysi s . He devised a 
number of techniques for breaking German ciphers, including the method of the 
bombe, an electromechanical machine that could find settings for the Enigma 
machine. After the war he worked at the National Physical Laboratory, where he 
created one of the first designs for a stored-program computer, the ACE. In 
1948 Turing joined Max Newman's Computing Laboratory at Manchester University, 
where he assisted in the development of the Manchester computers and became 
interested in mathematical biology. He wrote a paper on the chemical basis of 
morphogenesis, and predicted oscillating chemical reactions such as the 
Belousov-Zhabotinsky reaction, which were first observed in the 1960s. Turing's 
homosexuality resulted in a criminal prosecution in 1952, when homosexual acts 
were still illegal in the United Kingdom. He accepted treatment with female 
hormones (chemical castration) as an alternative to prison. Turing died in 
1954, just over two weeks before his 42nd birthday, from cyanide poisoning. An 
inquest determined that his death was suicide; his mother and some others 
believed his death was accidental. On 10 September 2009, following an Internet 
campaign, British Prime Minister Gordon Brown made an official public apology 
on behalf of the British government for "the appalling way he was treated." As 
of May 2012 a private member's bill was before the House of Lords which would 
grant Turing a statutory pardon if enacted.""" 

11. myKey = 'ASIMOV 

12. myMode = 'encrypt' # set to 'encrypt' or 'decrypt' 
13. 

14. if myMode == 'encrypt': 

15. translated = encryptMessage(myKey , myMessage) 

16. elif myMode == 'decrypt': 



Email questions to the author: al@inventwithpython.com 



Chapter 19 - The Vigenere Cipher 293 



17. translated = decryptMessage(myKey , myMessage) 

18. 

19. print('%sed message:' % (myMode.title())) 

20. print(translated) 

21. pypercli p. copy (transl ated) 

22. print() 

23. print('The message has been copied to the clipboard.') 
24. 

25. 

26. def encryptMessage(key, message): 

27. return translateMessage(key, message, 'encrypt') 

28. 
29. 

30. def decryptMessage(key, message): 

31. return translateMessage(key, message, 'decrypt') 

32. 
33. 

34. def translateMessage(key, message, mode): 

35. translated = [] # stores the encrypted/decrypted message string 
36. 

37. keylndex = 0 

38. key = key.upperO 
39. 

40. for symbol in message: # loop through each character in message 

41. num = LETTERS. find(symbol .upperO) 

42. if num != -1: # -1 means symbol . upper() was not found in LETTERS 

43. if mode == 'encrypt': 

44. num += LETTERS. find(key[keylndex]) # add if encrypting 

45. el if mode == 'decrypt': 

46. num -= LETTERS . fi nd(key [keylndex] ) # subtract if decrypting 
47. 

48. num %= len(LETTERS) # handle the potential wrap-around 

49. 

50. # add the encrypted/decrypted symbol to the end of translated. 

51. if symbol .i supper () : 

52 . transl ated . append (LETTERS [num] ) 

53. elif symbol .islower() : 

54. transl ated. append (LETTERS [num] .lower()) 
55. 

56. keylndex += 1 # move to the next letter in the key 

57. if keylndex == 1 en (key): 

58. keylndex = 0 

59. else: 

60. # The symbol was not in LETTERS, so add it to translated as is. 

61. transl ated. append(symbol) 
62. 



294 http://inventwithpython.com/hacking 



63. return '' .join (translated) 

64. 

65. 

66. # If vigenereCipher.py is run (instead of imported as a module) call 

67. # the main() function. 

68. if name == 1 main ': 

69. main() 



Sample Run of the Vigenere Cipher Program 

Encrypted message: 

Adiz Avtzqeci Tmzubb wsa m Pmilqev hal pqavtakuoi , lgouqdaf, kdmktsvmztsl , izr 
xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz hce vmhsgohuqbo ox kaakulmd 
gxiwvos, krgdurdny i rcmmstugvtawz ca tzm ocicwxfg jf "stscmilpy" oid 

. . .skipped for brevity. . . 

uiydviyv, Nfdtaat Dmiem Ywiikbqf Bo j lab Wrgez avdw iz cafakuog pmjxwx ahwxcby 
gv nscadn at ohw Jdwoikp scqejvysit xwd "hce sxboglavs kvy zm ion tjmmhzd." Sa 
at Haq 2012 i bfdvsbq azmtmd'g widt ion bwnafz tzm Tcpsw wr Z j rva ivdcz eaigd 
yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd. 

The message has been copied to the clipboard. 



How the Program Works 







vigenereCipher.py 


1. 


# Vigenere Cipher (Polyalphabetic Substitution Cipher) 




2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 
5. 


import pyperclip 




6. 


LETTERS = ' ABCDEFGHI J KLMNOPQRSTUVWXYZ ' 





The beginning of the program has the usual comments to describe the program, an import 
statement for the pyperclip module, and creates a variable called LETTERS with a string of 
every uppercase letter. 







vigenereCipher.py 


8. 


def main() : 




9. 


# This text can be copy/pasted from 


http : //i nvpy . com/vi genereCi pher . py 


10. 


myMessage = """Alan Mathison Turing 


was a British mathematician, 




...skipped for brevity... 





Email questions to the author: al@inventwithpython.com 



Chapter 19 - The Vigenere Cipher 295 



grant Turing a statutory pardon if enacted.""" 


1 1 


illy Ixc y ‚Äî AjiHUV 


1Z ‚ñ† 


rriynuuc ‚Äî encrypt, ff bcL lu encrypt, or ucli yp l 






1 A 


\\ rnyi v ioue ‚Äî encrypr . 


15. 


translated = encryptMessage(myKey , myMessage) 


16. 


elif myMode == 'decrypt': 


17. 


translated = decryptMessage(myKey , myMessage) 


18. 




19. 


print('%sed message:' % (myMode. titleO)) 


20. 


pri nt(transl ated) 


21. 


pypercl i p . copy (trans! ated) 


22. 


print() 


23. 


print('The message has been copied to the clipboard.') 



The main ( ) function for the Vigenere cipher is exactly like the other main ( ) functions in this 
book: there are variables for message, key, and mode. The user sets these variables on lines 
10, 11, and 12 before running the program. The encrypted or decrypted message (depending on 
what myMode is set to) is stored in a variable named translated so that it can be printed to 
the screen (on line 20) and copied to the clipboard (on line 21). 



The code that does the actual encryption and decryption is in translateMessage ( ) , which is 
explained later. 









vigenereCipher.py 


26. 


def encryptMessage(key, message): 






27. 


return translateMessage(key, message, 


'encrypt') 




28. 








29. 








30. 


def decryptMessage(key , message): 






31. 


return translateMessage(key, message, 


1 decrypt ' ) 





Since the encryption and decryption use much of the same code as the other, we put them both in 

translateMessage ( ) . The encryptMessage ( ) and decryptMessage ( ) functions 
are wrapper functions for translateMessage ( ) . (Wrapper functions were covered in 
Chapter 17.) 







vigenereCipher.py 


34. 


def translateMessage(key, message, mode): 




35. 


translated = [] # stores the encrypted/decrypted 


message string 


36. 






37. 


keylndex = 0 





296 http://inventwithpython.com/hacking 



38. key = key.upperO 

In the translateMessage ( ) function, we will slowly build the encrypted (or decrypted) 
string one character at a time. The list in translated will store these characters so that they 
can be joined together once the string building is done. (The reason we use a list instead of just 
appending the characters to a string is explained in the "Building Strings in Python with Lists" 
section in Chapter 18.) 

Remember, the Vigenere cipher is just the Caesar cipher except that a different key is used 
depending on the position of the letter in the message. The keylndex variable keeps track of 
which subkey to use. The keylndex variable starts off as 0, because the letter used to encrypt 
or decrypt the first character of the message will be the one at key [ 0 ] . 

Our code assumes that the key has only uppercase letters. To make sure the key is valid, line 38 
sets the key to be the uppercase version of it. 



vigenereCipher.py 

40. for symbol "in message: # loop through each character in message 

41. num = LETTERS. fi nd (symbol .upperO) 

42. "if num != -1: # -1 means symbol . upperO was not found "in LETTERS 

43. "if mode == 'encrypt': 

44. num += LETTERS. fi nd(key[keylndex]) # add "if encrypting 

45. el if mode == 'decrypt': 

46. num -= LETTERS. fi nd(key[keylndex]) # subtract if decrypting 



The rest of the code in translateMessage ( ) is similar to the Caesar cipher code. The for 
loop on line 40 sets the characters in message to the variable symbol on each iteration of the 
loop. On line 41 we find the index of the uppercase version of this symbol in LETTERS. (This is 
how we translate a letter into a number). 

If num was not set to - 1 on line 41, then the uppercase version of symbol was found in 
LETTERS (meaning that symbol is a letter). The keylndex variable keeps track of which 
subkey to use, and the subkey itself will always be what key [ keylndex] evaluates to. 

Of course, this is just a single letter string. We need to find this letter's index in the LETTERS to 
convert the subkey into an integer. This integer is then added (if encrypting) to the symbol's 
number on line 44 or subtracted (if decrypting) to the symbol's number on line 46. 



vigenereCipher.py 

48. num %= len(LETTERS) # handle the potential wrap-around 



Email questions to the author: al@inventwithpython.com 



Chapter 19 - The Vigenere Cipher 297 



In the Caesar cipher code, we checked if the new value of num was less than 0 (in which case, we 
added len (LETTERS ) to it) or if the new value of num was len (LETTERS ) or greater (in 
which case, we subtracted len ( LETTERS ) from it). This handles the "wrap-around" cases. 

However, there is a simpler way that handles both of these cases. If we mod the integer stored in 
num by len ( LETTERS ) , then this will do the exact same thing except in a single line of code. 

For example, if num was -8 we would want to add 2 6 (that is, len (LETTERS) ) to it to get 18. 
Or if num was 3 1 we would want to subtract 2 6 to get 5 . However - 8 % 2 6 evaluates to 1 8 
and 31 % 2 6 evaluates to 5. The modular arithmetic on line 48 handles both "wrap-around" 
cases for us. 





vigenereCipher.py 


50. 


# add the encrypted/decrypted symbol to the end of translated. 


51. 


"if symbol . 1 supper () : 


52. 


transl ated . append (LETTERS [num] ) 


53. 


elif symbol .1 si owe r() : 


54. 


transl ated . append (LETTERS [num] . 1 ower ()) 



The encrypted (or decrypted) character exists at LETTERS [ num] . However, we want the 
encrypted (or decrypted) character's case to match symbol's original case. So if symbol is an 
uppercase letter, the condition on line 51 will be True and line 52 will append the character at 
LETTERS [num] to translated. (Remember, all the characters in the LETTERS string are 
already uppercase.) 



However, if symbol is a lowercase letter, than the condition on line 53 will be True instead and 
line 54 will append the lowercase form of LETTERS [num] to translated instead. This is 
how we can get the encrypted (or decrypted) message to match the casing of the original 
message. 



vigenereCipher.py 

56. keylndex += 1 # move to the next letter "in the key 

57. "if keylndex == len (key): 

58. keylndex = 0 

Now that we have translated the symbol, we want to make sure that on the next iteration of the 
for loop we use the next subkey. Line 56 increments keylndex by one. This way when the 
next iteration uses key [ key I ndex ] to get the subkey, it will be the index to the next subkey. 



298 http://inventwithpython.com/hacking 

However, if we were on the last subkey in the key, then keylndex would be equal to the length 
of key. Line 57 checks for this condition, and resets keylndex back to 0 on line 58. That way 
key [ keyl ndex ] will point back to the first subkey. 



vigenereCipher.py 

59. else: 

60. # The symbol was not in LETTERS, so add it to translated as is. 

61. translated. append (symbol ) 

From the indentation you can tell that the else statement on line 59 is paired with the i f 
statement on line 42. The code on line 61 executes if the symbol was not found in the LETTERS 
string. This happens if symbol is a number or punctuation mark such as ' 5 ' or ' ? ' . In this 
case, line 61 will just append the symbol untranslated. 









vigenereCipher.py 


63. 


return 1 


' .join (translated) 





Now that we are done building the string in translated, we call the j oin ( ) method on the 
blank string to join together all the strings in translated (with a blank in between them). 







vigenereCipher.py 


66. 


# If vigenereCipher.py is 


run (instead of imported as a module) call 


67. 


# the main() function. 




68. 


if name == ' main ' 




69. 


mainQ 





Lines 68 and 69 call the main ( ) function if this program was run by itself, rather than imported 
by another program that wants to use its encryptMessage ( ) and decryptMessage ( ) 
functions. 



Summary 

We are close to the end of the book, but notice how the Vigenere cipher isn't that much more 
complicated than the second cipher program in this book, the Caesar cipher. With just a few 
changes, we can create a cipher that has exponentially many more possible keys than can be 
brute-forced. 

The Vigenere cipher is not vulnerable to the dictionary word pattern attack that our Simple 
Substitution hacker program uses. The "indecipherable cipher" kept secret messages secret for 
hundreds of years. The attack on the Vigenere cipher was not widely known until the early 20 th 
century. But of course, this cipher too eventually fell. In the next couple of chapters, we will learn 
new "frequency analysis" techniques to hack the Vigenere cipher. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 299 



Chapter 20 

Frequency Analysis 

Topics Covered In This Chapter: 

‚Ä¢ Letter Frequency and ETAOIN 

‚Ä¢ The sort ( ) Method's key and reverse Keyword Arguments 

‚Ä¢ Passing Functions as Values Instead of Calling Functions 

‚Ä¢ Converting Dictionaries to Lists with the keys ( ) , values ( ) , items ( ) Dictionary 
Methods 



The ineffable talent for finding patterns in chaos 
cannot do its thing unless he immerses himself in 
the chaos first. If they do contain patterns, he does 
not see them just now, in any rational way. But 
there may be some subrational part of his mind 
that can go to work, now that the letters have 
passed before his eyes and through his pencil, and 
that may suddenly present him with a gift-wrapped 
clue‚Äî or even a full solution‚Äîa few weeks from 
now while he is shaving or antenna-twiddling. 

"Cryptonomicon" by Neal Stephenson 




300 http://inventwithpython.com/hacking 

A coin has 2 sides, and when you flip a coin, about half the time it will come up heads and half of 
the time it comes up tails. The frequency (that is, how often) that the coin flip ends up heads is 
the same as the frequency that it ends up tails: about one -half or 50%. 

There are 26 letters in the English alphabet, but they don't each appear an equal amount of the 
time in English text. Some letters are used more often than others. For example, if you look at the 
letters in this book you will find that the letters E, T, A and O occur very frequently in English 
words. But the letters J, X, Q, and Z are rarely found in English text. We can use this fact to help 
crack Vigenere -encrypted messages. This technique is called frequency analysis. 

Here are the frequencies of the 26 letters in average English text. This graph is compiled by 
grabbing English text from books, newspapers, and other sources to count often each letter 
appears: 

Figure 20-1. Letter frequency of normal English. 

0.14 - 
0.12 - 
0.1 - 
0.08 - 
0.06 - 
0.04 - 
0.02 - 
0 - 

abcdefgh i j klmnopqrstuvwxyz 

If we sort these in order of greatest frequency to least, we find that E is the most frequent letter, 
followed by T, followed by A, and so on: 




Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 301 



Figure 20-2. Letter frequency of normal English, sorted. 

0.14 -, 
0.12 -I 
0.1 -| 

0.08 
0.06 
0.04 



0.02 
0 

etaoi nshrd I cumwfgypbvkj xqz 

The word "ETAOIN" is a handy way to remember the six most frequent letters. The full list of 
letters ordered by frequency is "ETAOINSHRDLCUMWFGYPBVKJXQZ". 

Think about the transposition cipher: Messages encrypted with the transposition cipher contain all 
the original letters of the original English plaintext, except in a different order. But the frequency 
of each letter in the ciphertext remains the same: E, T, and A should occur much more often than 
Q and Z. Because they are the same letters, the frequencies of these letters in the ciphertext are 
the same as the plaintext. 

The Caesar and simple substitution ciphers have their letters replaced, but you can still count the 
frequency of the letters. The letters may be different but the frequencies are the same. There 
should be letters that occur the most often in the ciphertext. These letters are good candidates for 
being cipherletters for the E, T, or A letters. The letters in the ciphertext that occur least are more 
likely to be X, Q, and Z. 

This counting of letters and how frequently they appear in both plaintexts and ciphertexts is 
called frequency analysis. 

Since the Vigenere cipher is essentially multiple Caesar cipher keys used in the same message, 
we can use frequency analysis to hack each subkey one at a time based on the letter frequency of 
the attempted decryptions. We can't use English word detection, since any word in the ciphertext 
will have been encrypted with multiple subkeys. But we don't need full words, we can analyze 




302 http://inventwithpython.com/hacking 

the letter frequency of each subkey's decrypted text. (This will be explained more in the next 
chapter.) 

Matching Letter Frequencies 

By "matching the letter frequency of regular English" we could try several different algorithms. 
The one used in our hacking program will simply order the letters from most frequent to least 
frequent. We will calculate what we will call in this book a frequency match score for this 
ordering of frequencies. To calculate the frequency match score for a string, the score starts at 0 
and each time one of the letters E, T, A, O, I, N appears among the six most frequent letters of the 
string, we add a point to the score. And each time one of the letters V, K, J, X, Q, or Z appears 
among the six least frequent letters of the string, we add a point to the score. The frequency match 
score for a string will be an integer from 0 (meaning the letter frequency of the string is 
completely unlike regular English's letter frequency) to 12 (meaning it is identical to regular 
English's letter frequency). 

An Example of Calculating Frequency Match Score 

For example, look at this ciphertext which was encrypted with a simple substitution cipher: 

"Sy 1 nix sr pyyacao 1 ylwj eiswi upar "lulsxrj isr sxrjsxwjr, ia esmm 
rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqacei amnsxu , ia esmm caytra 
jp famsaqa sj . Sy, px jia pjiac ilxo, "ia sr pyyacao rpnajisxu eiswi lyypcor 1 
cal rpx ypc Iwjsxu sx Iwwpcolxwa jp isr sxrjsxwjr, ia esmm Iwwabj sj aqax px jia 
rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr e"lh. -Facjclxo 
Ctrramm" 

If we count the frequency of each letter and then arrange them by order of its frequency, we end 
up with this ordering: ASRXJILPWMCYOUEQNTHBFZGKVD. That is, A is the most frequent 
letter, S is the 2 nd most frequent letter, and so on down to the letter D, which appears the least 
frequently. 

The six most frequent letters in this ordering are A, S, R, X, J, and I. Only two of these letters (A 
and I) appear in the ETAOIN set of letters. The six least frequent letters in the ordering are F, Z, 
G, K, V, and D. Only three of these letters (Z, K, and V) appear in the VKJXQZ set of letters. So 
the frequency ordering ASRXJILPWMCYOUEQNTHBFZGKVD (which comes from the above 
ciphertext) has a frequency match score of 5. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 303 



ASRXDI LPWMCYOUEQNTHB FZGKVD^" 5 matches 
(Ignore middle 14) 

ETAOIN SHRDLCUMWFGYPB VKDXQZ 



Figure 20-3. How the frequency match score of AS RXJ I LPW M CYO U EQNTH B FZG KVD is calculated. 

The above ciphertext was encrypted with a simple substitution cipher, which is why the 
frequency match score isn't very high. The letter frequencies of simple substitution ciphertext 
won't match regular English's letter frequencies. 

Another Example of Calculating Frequency Match Score 

For another example, look at this ciphertext which was encrypted with a transposition cipher: 

"I rc ascwuiluhnviwuetnh,osgaa "ice tipeeeee slnatsfietgi tittynecem'sl . e fo f 
fnc "isltn sn o a yrs sd onisli ,1 erglei trhfmwf rogotn , 1 stcofiit.aea 
wesn,lnc ee w,l elh eeehoer ros iol er snh nl oahsts ilasvih tvfeh rti ra id 
thatnie.im ei-dlmf i thszonsi sehroe , aiehcdsanahiec gv gyedsB affcahiecesd d 
lee onsdihsoc nin cethiTi tx eRneahgin r e teom fbiotd n 
ntacscwevhtdhnhpi wru" 

The ordering of most to least frequent letters in the above ciphertext is: 

EISNTHAOCLRFDGWVMUYBPZXQJK. (That is, E is the most frequent letter, I the 2 nd most 
frequent letter, and so on.) 

Of the top and bottom six letters in this ordering, the four letters E, I, N, and T appear in ETAOIN 
and the five letters Z, X, Q, J, and K appear in VKJXQZ. This gives the ordering a frequency 
match score of 9. 



EISNTH AOC L R F DGWVMUYB P ZXQJK ^9 matches 
(Ignore middle 14) 

ETAOIN SHRDLCUMWFGYPB VKDXQZ 




(Bottom 6) 




(Bottom 6) 



Figure 20-4. How the frequency match score of EISNTHAOCLRFDGWVMUYBPZXQJK is calculated. 



304 http://inventwithpython.com/hacking 



The above ciphertext was encrypted with a transposition cipher, so it has all the same letters as 
the original English plaintext (their order has just been switched around.) This is why the 
frequency ordering has a much higher frequency match score. 

Hacking Each Subkey 

When hacking the Vigenere cipher, we try to decrypt the letters for the first subkey with each of 
the 26 possible letters and find out which decrypted ciphertext produces a letter frequency that 
closest matches that of regular English. This is a good indication that we have found the correct 
subkey. 

We can do this same thing for the second, third, fourth, and fifth subkey as well. Since we are 
only doing 26 decryptions for each subkey individually, our computer only has to perform 26 + 
26 + 26 + 26 + 26, or 156, decryptions. This is much easier than trying to do 1 1,881,376 
decryptions ! 

So, hacking the Vigenere cipher sounds simple in theory. Just try all 26 possible subkeys for each 
subkey in the key, and see which one produces decrypted text that has a letter frequency that 
closest matches the letter frequency of English. 

It turns out that there are a few more steps than this, though, but we can cover them when we 
write the hacking program in the next chapter. For this chapter, we will write a module with 
several helpful functions that perform frequency analysis. This module will have these functions: 

‚Ä¢ getLetterCount ( ) - This function will take a string parameter and return a dictionary 
that has the count of how often each letter appears in the string. 

‚Ä¢ getFrequencyOrder ( ) - This function will take a string parameter and return a string of 
the 26 letters ordered from those that appear most frequently to least frequently in the string 
parameter. 

‚Ä¢ englishFreqMatchScore ( ) - This function will take a string parameter and return an 
integer from 0 to 12 of the string's letter frequency match score. 

The Code for Matching Letter Frequencies 

Type in the following code into the file editor, and then save it as freqAnalysis.py. Press F5 to run 
the program. 



Source code for freqAnalysis.py 

1. # Frequency Finder 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 305 



5. 

6. # frequency taken from http://en.wikipedia.org/wiki/Letter_frequency 

7. englishLetterFreq = {'E': 12.70, 'T' : 9.06, 'A': 8.17, '0': 7.51, 'I': 
6.97, 'N': 6.75, 'S': 6.33, 'H': 6.09, ' R' : 5.99, 'D': 4.25, 'L': 4.03, 'C 
2.78, 'IT: 2.76, 'M' : 2.41, 'W : 2.36, 'F': 2.23, 'C: 2.02, 'Y' : 1.97, 'P' 
1.93, 'B': 1.29, 'V: 0.98, 'K': 0.77, ' 3' : 0.15, 'X': 0.15, 'Q' : 0.10, 'Z' 
0.07} 

8. ETAOIN = ' ETAOINSHRDLCUMWFGYPBVKJXQZ ' 

9. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ' 
10. 

11. 

12. 

13. def getLetterCount(message) : 



14. # Returns a dictionary with keys of single letters and values of the 

15. # count of how many times they appear in the message parameter. 
letterCount = {'A': 0, 'B': 0, 'C : 0, 'D': 0, 'E': 0, 'F': 0, 'C: 0, 

'H' : 0, 'I': 0, 1 J ' : 0, 'K': 0, 'L': 0, 'M' : 0, 'N': 0, '0': 0, 'P': 0, 'Q' : 0, 
'R': 0, 'S': 0, 'T' : 0, 'IT: 0, 'V: 0, 'W : 0, 'X': 0, 'Y' : 0, 'Z' : 0} 
17. 

18. for letter in message . upperO : 

19. if letter in LETTERS: 

20. letterCount[letter] += 1 
21. 

22. return letterCount 

23. 

24. 

25. def getltemAtlndexZero(x) : 

26. return x[0] 
27. 

28. 

29. def getFrequencyOrder (message) : 

30. # Returns a string of the alphabet letters arranged in order of most 

31. # frequently occurring in the message parameter. 
32. 

33. # first, get a dictionary of each letter and its frequency count 

34. letterToFreq = getLetterCount(message) 
35. 

36. # second, make a dictionary of each frequency count to each letter(s) 

37. # with that frequency 

38. freqToLetter = {} 

39. for letter in LETTERS: 

40. if 1 etterToFreq [1 etter] not in freqToLetter: 

41. freqToLetter [letterToFreq[letter]] = [letter] 

42. else: 

43. freqToLetter [letterToFreq [letter]] .append(letter) 
44. 



306 http://inventwithpython.com/hacking 



45. # third, put each list of letters "in reverse "ETAOIN" order, and then 

46. # convert it to a string 

47. for freq in f reqToLetter : 

48. f reqToLetter [freq] . sort(key=ETAOIN . find, reverse=True) 

49. f reqToLetter [freq] = ' ' . join(f reqToLetter [f req]) 

50. 

51. # fourth, convert the freqToLetter dictionary to a list of tuple 

52. # pairs (key, value), then sort them 

53. freqPairs = list(freqToLetter.itemsO) 

54. f reqPai rs . sort(key=getItemAtIndexZero , reverse=True) 
55. 

56. # fifth, now that the letters are ordered by frequency, extract all 

57. # the letters for the final string 

58. freqOrder = [] 

59. for freqPair in freqPairs: 

60. freqOrder . append(f reqPai r[l]) 
61. 

62. return 1 1 . joi n(f reqOrder) 

63. 

64. 

65. def englishFreqMatchScore(message) : 

66. # Return the number of matches that the string in the message 

67. # parameter has when its letter frequency is compared to English 

68. # letter frequency. A "match" is how many of its six most frequent 

69. # and six least frequent letters is among the six most frequent and 

70. # six least frequent letters for English. 

71. freqOrder = getFrequencyOrder(message) 
72. 

73. matchScore = 0 

74. # Find how many matches for the six most common letters there are. 

75. for commonLetter in ETAOIN [: 6]: 

76. if commonLetter in f reqOrder [: 6] : 

77. matchScore += 1 

78. # Find how many matches for the six least common letters there are. 

79. for uncommonLetter in ETAOIN [-6:]: 

80. if uncommonLetter in f req0rder[-6:] : 

81. matchScore += 1 
82. 

83. return matchScore 



How the Program Works 



freqAnalysis.py 

1. # Frequency Finder 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 307 



4. 
5. 

6. # frequency taken from http://en.wiknpedia.org/wiki/Letter_frequency 

7. englishLetterFreq = {'E': 12.70, 'T' : 9.06, 'A': 8.17, '0': 7.51, 'I': 
6.97, 'N': 6.75, 'S': 6.33, 'H': 6.09, 'R': 5.99, 'D' : 4.25, 'L': 4.03, 'C: 
2.78, 'IT: 2.76, 'M' : 2.41, 'W : 2.36, 'F': 2.23, 'C: 2.02, 'Y' : 1.97, 'P': 
1.93, 'B': 1.29, 'V: 0.98, 'K': 0.77, 0.15, 'X': 0.15, 'Q' : 0.10, 'Z': 
0.07} 

The englishLetterFreq dictionary will contain strings of the letters of the alphabet as keys 
and a float for their percentage frequency as the value. (These values come from the Wikipedia 
article for letter frequency: https://erw The 
englishLetterFreq value isn't actually used by our program. It is simply here for your 
future reference in case you write a program that needs it. 

The Most Common Letters, "ETAOIN" 

freqAnalysis.py 

8. ETAOIN = ' ETAOINSHRDLCUMWFGYPBVKTXQZ ' 



We will create a variable named ETAOIN on line 8 which will have the 26 letters of the alphabet 
in order of most frequent to least frequent. The word ETAOIN is a handy way to remember the 
six most common letters in English. Of course, this ordering isn't always going to be perfect. You 
could easily find a book that has a set of letter frequencies where Z is used more often than Q, for 
example. Gadsby by Ernest Vicent Wright is a novel that never uses the letter E, which gives it a 
very odd set of letter frequencies. But in most cases, the "ETAOIN order" will be accurate. 



freqAnalysis.py 

9. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

Our module will also need a string of all the uppercase letters of the alphabet for a few different 
functions, so we set the LETTERS constant variable on line 9. 

The Program's getLettersCount ( ) Function 

freqAnalysis.py 

13. def getLetterCount(message) : 

14. # Returns a dictionary with keys of single letters and values of the 

15. # count of how many times they appear in the message parameter. 

16. letterCount = {'A': 0, 'B': 0, 'C : 0, 'D': 0, 'E': 0, 'F': 0, 'C: 0, 
'H': 0, 'I': 0, ' J ' : 0, 'K': 0, 'L': 0, 'M' : 0, 'N': 0, '0': 0, 'P': 0, 'Q' : 0, 
'R': 0, 'S': 0, 'T' : 0, 'U': 0, 'V: 0, 'W : 0, 'X': 0, 'Y' : 0, 'Z' : 0} 



308 http://inventwithpython.com/hacking 



The getLetterCount ( ) function returns a dictionary value where the keys are single 
uppercase letter strings, and the values are an integer showing how many times that letter occurs 
in the message parameter. For example, a certain string value for the message parameter with 
135 A's, 30 B's, and so on will cause getLetterCount ( ) to return { ' A ' : 135, 'B': 30, 
'C':74, 'D':58, 'E':196, 'F':37, 'G':39, 'H':87, 'I': 139, 'J':2, 
'K':8, 'L':62, 'M':58, 'N' : 122, 'O' : 113, 'P':36, 'Q':2, 'R' : 10 6, 
'S':89, 'T':140, 'U':37, 'V : 14, 'W : 30, 'X':3, 'Y':21, 'Z':l} 



Line 16 starts the letterCount variable with a dictionary that has all keys with a value of 0. 







freqAnalysis.py 


18. 


for letter in message . upper () : 




19. 


if letter in LETTERS: 




20. 


letterCount[letter] += 1 





The for loop on line 18 iterates through each character in the uppercase version of message. 
On line 19, if the character exists in the LETTERS string, we know it is an uppercase letter. In 
that case line 20 will increment the value at letterCount [letter]. 







freqAnalysis.py 


22. 


return letterCount 





After the for loop on line 18 finishes, the letterCount dictionary will have a count of how 
often each letter appeared in message. This dictionary is returned from getLetterCount ( ) . 



The Program's getltemAtlndexZero () Function 







freqAnalysis.py 


25. 


def getltemAtlndexZero(x) : 




26. 


return x[0] 





The getltemAtlndexZero ( ) function is very simple: it is passed a tuple and returns the 
items at index 1. This function will be passed as the key keyword argument for the sort ( ) 
method. (The reason for this will be explained later.) 



The Program's getFrequencyOrder ( ) Function 

freqAnalysis.py 

29. def getFrequencyOrder (message) : 

30. # Returns a string of the alphabet letters arranged in order of most 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 309 



31. # frequently occurring "in the message parameter. 
32. 

33. # first, get a dictionary of each letter and its frequency count 

34. letterToFreq = getLetterCount(message) 

The getFrequencyOrder ( ) function will return a string with the 26 uppercase letters of the 
alphabet arranged in order of how frequently they appear in the message parameter. If 
message is readable English instead of random gibberish, this string will most likely be similar 
(if not identical to) the string in the ETAOIN constant. 

For example, if the "Alan Mathison Turing was a British mathematician. . ." text from Chapter 
19's vigenereCipher.py program was passed as a string to getFrequencyOrder ( ) , the 
function would return the string ' ETIANORSHCLMDGFUPBWYVKXQ JZ ' because E is the most 
common letter in that paragraph, followed by T, then I, then A, and so on. 

This function is somewhat complicated, but it breaks down to five simple steps. 

The first step of getFrequencyOrder ( ) , line 34 gets a dictionary value of the letter 
frequency count from getLetterCount ( ) for the string in the message parameter. (The 
getLetterCount ( ) function was described previously.) 

If the "Alan Mathison Turing. . ." text was passed as a string value for the message parameter, 
then line 34 would assign letterToFreq the dictionary value, { 'A' : 135, 'C : 74, 
'B':30, 'E':196, 'D':58, 'G':39, 'F':37, 'I':139, 'H':87, 'K':8, 
'J': 2, 'M':58, 'L':62, '0' : 113, 'N':122, 'Q':2, 'P':36, 'S':89, 
'R':106, 'U':37, 'T':140, 'W : 30, 'V':14, 'Y':21, 'X':3, 'Z':l}. 





freqAnalysis.py 


36. 


# second, make a dictionary of each frequency count to each letter(s) 


37. 


# with that frequency 


38. 


freqToLetter = {} 


39. 


for letter in LETTERS: 


40. 


if letterToFreq [letter] not in freqToLetter: 


41. 


freqToLetter [letterToFreq [letter]] = [letter] 


42. 


else: 


43. 


freqToLetter [1 etterToFreq [1 etter] ] . append (1 etter) 



For the second step of getFrequencyOrder ( ) , while the letterToFreq dictionary has 
keys of each of the 26 letters and values of their frequency count, what we need is a dictionary 
value that maps the opposite: a dictionary where the keys are the frequency count and values are a 
list of letters that appear that many times. While the letterToFreq dictionary maps letter keys 



310 http://inventwithpython.com/hacking 



to frequency values, the f reqToLetter dictionary will map frequency keys to list of letter 
values. 

Line 38 creates a blank dictionary. Line 44 loops over all the letters in LETTERS. The if 
statement on line 40 checks if the letter's frequency (that is, letterToFreq [ letter] ) 
already exists as a key in f reqToLetter. If not, then line 41 adds this key with a list of the 
letter as the value. Or else, line 43 appends the letter to the end of the list that is already at 

letterToFreq [letter] . 

If we continue to use our "Alan Mathison Turing. . ." example value of letterToFreq then 
f reqToLetter would end up looking like this: {1: [ ' Z ' ] , 2: ['J', ' Q ' ] , 3: ['X'], 
135: ['A'], 8: ['K'],139: ['I'], 140: ['T'],14: ['V'],21: ['Y'],30: 
[ 'B' , 'W ] , 36: [ ' P 1 ] , 37: [ 'F' , 'U' ] , 39: [ 'G' ] , 58 : [ 'D' , 'M' ] , 62 : 
['L'],196: ['E'],74: ['C'],87: ['H'],89: ['S'],106: ['R'],113: 
['0' ] , 122: [ ' N ' ] } 

The sort ( ) Method's key and reverse Keyword Arguments 







freqAnalysis.py 


45. 


# third, put each list of letters in reverse "ETAOIN 


' order, and then 


46. 


# convert it to a string 




47. 


for freq in f reqToLetter : 




48. 


f reqToLetter [f req] . sort(key=ETAOIN . f i nd , reverse= 


=True) 


49. 


f reqToLetter [freq] = ' ' . joi n(f reqToLetter [freq]) 





The third step of getFrequencyOrder ( ) to is sort the letter strings in each list in 
f reqToLetter in reverse ETAOIN order (as opposed to alphabetical order). 



Remember that f reqToLetter [freq] will evaluate to a list of letters that have a frequency 
count of freq. A list is used because it's possible that two or more letters have the exact same 
frequency count, in which case this list will have two-or-more-letters strings in it. 

When multiple letters are tied for frequency, we want these tied letters to be sorted in the reverse 
order that they appear in the ETAOIN string. We need this so that we have a consistent way of 
breaking ties. Otherwise messages with the same letter frequencies might produce different return 
values from getFrequencyOrder ( ) ! 

For example, if E appears 15 times, D and W appear 8 times each, and H appears 4 times, we 
would want them to be sorted as ' EWDH ' and not ' EDWH ' . This is because while E is the most 
frequent, D and W have the same frequency count but W comes after D in the ETAOIN string. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 311 



Python's sort ( ) function can do this sorting for us if we pass it a function or method for its 
key keyword argument. Normally the sort ( ) function simply sorts the list it is called on into 
alphabetical (or numeric) order. However, we can change this by passing the f ind ( ) method of 
the ETAOIN string as the key keyword argument. This will sort the items in the 
f reqToLetter [ f req] list by the integer returned from the ETAOIN . find ( ) method, that 
is, the order that they appear in the ETAOIN string. 

Normally the sort ( ) method sorts the values in a list in ascending order (that is, lowest to 
highest or the letter A first and letter Z last). If we pass True for the sort ( ) method's 
reverse keyword argument, it will sort the items in descending order instead. The reason we 
want to sort the letters in reverse ETAOIN order is so that ties result in lower match scores in the 
englishFreqMatchScore ( ) function rather than higher match scores. (This function is 
explained later.) 

If we continue using our "Alan Mathison Turing. . ." example value for f reqToLetter, then 
after the loop finishes the value stored in f reqToLetter would be: {1: 'Z', 2: ' QJ', 3: 
'X', 135: 'A', 8: 'K', 139: 'I', 140: 'T 1 , 14: 'V, 21: 'Y', 30: ' BW , 36: 
'P\ 37: 'FU\ 39: ' G ' , 58: 'MD', 62: 'L\ 196: 'E\ 74: 'C, 87: 'H\ 89: 
'S', 106: 'R', 113: '0', 122: 'N' } 

Notice that the strings for the 3 0 , 3 7 , and 5 8 keys are all sorted in reverse ETAOIN order. 

Passing Functions as Values 

freqAnalysis.py 

48. f reqToLetter [f req] . sort(key=ETA0IN . fi nd , reverse=True) 

If you look on line 47, you'll notice that we are not calling the find ( ) method but instead using 
the find method itself as a value that is passed to the sort ( ) method call. In Python, functions 
themselves are values just like any other values. For example, try typing this into the interactive 
shell: 



¬ª&gt; def foo() : 

printC'HeTIo! ') 

¬ª&gt; bar = foo 
¬ª&gt; bar() 
Hello! 

In the above code, we define a function named f oo ( ) that prints out the string 'Hello ! ' . But 
this is basically defining a function and then storing it in a variable named foo. Then we copy 



312 http://inventwithpython.com/hacking 

the function in f oo to the variable bar. This means we can call bar ( ) just like we can call 
f oo ( ) ! Note that in this assignment statement we do not have parentheses after f oo. If we did, 
we would be calling the function f oo ( ) and setting bar to its return value. Just like spam [ 4 2 ] 
has the [ 42 ] index operating on spam, the parentheses means, "Call the value in f oo as a 
function." 



You can also pass functions as values just like any other value. Try typing the following into the 
interactive shell: 



¬ª&gt; 


def doMath(func) : 




return func(10, 5) 


¬ª&gt; 


def addi ng(a, b) : 




return a + b 


¬ª&gt; 


def subtract! ng(a, b) : 




return a - b 


¬ª&gt; 


doMath(addi ng) 


15 




¬ª&gt; 


doMath (subtract! ng) 


5 




¬ª&gt; 





When the function in adding is passed to the doMath ( ) call, the func (10, 5 ) line is 
calling adding ( ) and passing 1 0 and 5 to it. So the call f unc ( 1 0 , 5 ) is effectively the 
same as the call adding (10 , 5) . This is why doMath (adding) returns 15. 



When subtracting is passed to the doMath ( ) call, func (10, 5 ) is the same as 
subtracting ( 10 , 5 ). This is why doMath ( subtracting) returns 5. 

Passing a function or method to a function or method call is how the sort ( ) method lets you 
implement different sorting behavior. The function or method that is passed to sort ( ) should 
accept a single parameter and returns a value that is used to alphabetically sort the item. 

To put it another way: normally sort ( ) sorts the values in a list by the alphabetical order of the 
list values.. But if we pass a function (or method) for the key keyword argument, then the values 
in the list are sorted by the alphabetical or numeric order of the return value of the function when 
the value in the list is passed to that function. 

You can think of a normal sort ( ) call such as this: 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 313 



someLi stVari abl e . sortO 
. . .as being equivalent to this: 



def func(x) : 

return x # sorting based on the value "itself 
someLi stVari abl e . sort(key=f unc) 

So when the sort ( ) method call is passed ETAOIN . find, instead of sorting the strings like 
' A ' , ' B ' , and ' C ' by the alphabetical order the sort ( ) method sorts them by the numeric 
order of the integers returned from ETAOIN . find ( ' A ' ) , ETAOIN . find ( ' B ' ) , and 
ETAOIN . find ( ' C ' ) : that is, 2, 1 9, and 1 1 respectively. So the ' A ' , ' B ' , and ' C ' strings 
get sorted as ' A ' , ' C ' , and then ' B ' (the order they appear in ETAOIN). 

Converting Dictionaries to Lists with the keysQ, values(), items() 
Dictionary Methods 

If you want to get a list value of all the keys in a dictionary, the keys ( ) method will return a 
dict_keys object that can be passed to list ( ) to get a list of all the keys. There is a similar 
dictionary method named values ( ) that returns a dict_values object. Try typing the following 
into the interactive shell: 



¬ª&gt; spam = {'cats': 10, 'dogs': 3, 'mice': 3} 
¬ª&gt; spam. keys C) 

di ct_keys (['mice', ' cats ' , ' dogs ' ] ) 

&gt;¬ª list(spam.keysO) 

[ 1 mi ce ' , ' cats ' , 1 dogs ' ] 

¬ª&gt; list(spam.valuesO) 

[3, 10, 3] 

¬ª&gt; 

Remember, dictionaries do not have any ordering associated with the key-value pairs they 
contain. When getting a list of the keys or values, they will be in a random order in the list. If you 
want to get the keys and values together, the items ( ) dictionary method returns a dict_items 
object that can be passed to 1 i s t ( ) . The 1 i s t ( ) function will then return a list of tuples 
where the tuples contain a key and value pair of values. Try typing the following into the 
interactive shell: 



¬ª&gt; spam = {'cats': 10, 'dogs': 3, 'mice': 3} 
¬ª&gt; list(spam.itemsO) 



314 http://inventwithpython.com/hacking 



[('mice', 3), ('cats', 10), ('dogs', 3)] 

We will be using the items ( ) method in our getFrequencyOrder ( ) function, but you 
should know about the keys ( ) and values ( ) methods too. Remember, in order to use the 
return values from these methods as lists, they must be passed to the list ( ) function. The 
list () function then returns a list version of the dict_keys, dict_values, or dict_items object. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 315 



Sorting the Items from a Dictionary 









freqAnalysis.py 


51. 


# fourth, 


convert the freqToLetter dictionary to 


a list of tuple 


52. 




cgv V3~l ug") then sort them 




53. 


f reqPai rs 


= list(freqToLetter.itemsO) 





The fourth step of getFrequencyOrder ( ) is to sort the strings from the freqToLetter 
dictionary by the frequency count. Remember that the freqToLetter dictionary has integer 
frequency counts for the keys and lists of single-letter strings for the values. But since dictionaries 
do not have an ordering for the key-value pairs in them, we will call the items ( ) method and 
list () function to create a list of tuples of the dictionary's key-value pairs. This list of tuples 
(stored in a variable named f reqPairs on line 53) is what we will sort. 







freqAnalysis.py 


54. 


f reqPai rs . sort(key=getItemAtIndexZero , reverse=True) 





The sort ( ) method call is passed the getltemAtlndexZero function value itself. This 
means the items in the freqPairs will be sorted by the numeric order of the value at index 0 of 
the tuple value, which is the frequency count integer. Line 54 also passes True for the reverse 
keyword argument so that the tuples are reverse ordered from largest frequency count to smallest. 



If we continue using the previous "Alan Mathison Turing. . ." example, the value of freqPairs 
willbe[(196, ' E ' ) , (140, 'T ' ) , (139, 'I'), (135, ' A ' ) , (122, ' N ' ) , (113, 
'0'), (106, 'R'), (89, 'S'), (87, 'H'), (74, 'C'), (62, 'L'), (58, 
'MD'), (39, 'G'), (37, 'FU'), (36, 'P'), (30, 'BW'), (21, 'Y'), (14, 
'V') , (8, 'K') , (3, 'X') , (2, 'QJ') , (1, 'Z') ] 





freqAnalysis.py 


56. 


# fifth, now that the letters are ordered by frequency, extract all 


57. 


# the letters for the final string 


58. 


freqOrder = [] 


59. 


for f reqPai r in freqPairs: 


60. 


freqOrder. append(f reqPai r[l]) 



The fifth step is to create a list of all the strings from the sorted list in freqPairs. The variable 
freqOrder will start as a blank list on line 58, and the string at index 1 of the tuple in 
freqPairs will be appended to the end of freqOrder. 



If we continue with the "Alan Mathison Turing was a British mathematician..." example from 
before, after this loop has finished, freqOrder will contain the value [ ' E ' , 1 T ' , 'I', 



316 http://inventwithpython.com/hacking 



'A', 


' N ' , '0', 


'R', 'S', 'H', 'C, 'L', 'MD', ' G ' , ' FU ' , 'P', ' BW , 'Y', 


'V, 


'K', 'X', 


'QJ', 'Z'] 






freqAnalysis.py 


62. 


return 


' ' . joi n(f reqOrder) 



Line 62 creates a string from the list of strings in f reqOrder by joining them together with the 
j oin ( ) method. If we continue using the previous example, getFrequencyOrder ( ) will 
return the string ' ETIANORSHCLMDGFUPBWYVKXQ JZ ' . According to this ordering, E is the 
most frequent letter in the "Alan Mathison Turing. . ." example string, T is the second most 
frequent letter, I is the third most frequent, and so on. 



The Program's englishFreqMatchScore () Function 



freqAnalysis.py 

65. def engl i shFreqMatchScore(message) : 



66. # Return the number of matches that the string in the message 

67. # parameter has when its letter frequency is compared to English 

68. # letter frequency. A "match" is how many of its six most frequent 

69. # and six least frequent letters is among the six most frequent and 

70. # six least frequent letters for English. 

71. freqOrder = getFrequencyOrder(message) 



The englishFreqMatchScore ( ) function takes a string for message, and then returns an 
integer between 0 and 12 to show message's frequency match score with readable English's 
letter frequency. The higher the integer, the more that the frequency of the letters in me s sage 
matches the frequency of normal English text. 



The first step in calculating the match score is to get the letter frequency ordering of me s sage 
by calling the getFrequencyOrder ( ) function. 







freqAnalysis.py 


73. 


matchScore = 0 




74. 


# Find how many matches for the six most 


common letters there are. 


75. 


for commonLetter in ETA0IN[:6]: 




76. 


if commonLetter in f reqOrder [: 6] : 




77. 


matchScore += 1 





The matchScore variable starts off at 0 on line 73. The for loop on line 75 goes through each 
of the first 6 letters of the ETAOIN string. Remember that the [ : 6 ] slice is the same thing as 
[ 0 : 6 ] . If one of these E, T, A, O, I, or N letters is in the first six letters in the freqOrder 
string, then line 76's condition is True and line 77 will increment matchScore. 



Email questions to the author: al@inventwithpython.com 



Chapter 20 - Frequency Analysis 317 







freqAnalysis.py 


78. 


$ Fi nd how manv matchi 


?s for the six least common letters there are. 


79. 


for uncommonLetter "in 


ETA0IN[-6:] : 


80. 


if uncommonLetter 


in freq0rder[-6:] : 




matchScore += 


1 



Lines 79 to 81 are much like lines 75 to 77, except the last six letters in ETAOIN (V, K, J, X, Q, 
and Z) are checked to see if they are in the last six letters in the f reqOrder string. If they are, 
then matchScore is incremented. 







freqAnalysis.py 


83. 


return matchScore 





The integer in matchScore is returned on line 83. 



The 14 letters in the middle of the frequency ordering are ignored with our frequency match score 
calculation. This approach to comparing letter frequencies is pretty simple, but it works well 
enough for our hacking program in the next chapter. 

Summary 

The sort ( ) function is useful for sorting the values in a list. Normally sort ( ) will sort them 
in alphabetical or numerical order. But the reverse and key keyword arguments can be used to 
sort them in different orders. This chapter also explains how functions themselves can be passed 
as values in function calls. 

Let's use the frequency analysis module to hack the Vigenere cipher, a cipher that perplexed 
cryptanalysts for hundreds of years! 



318 http://inventwithpython.com/hacking 




Chapter 21 



Hacking the Vigenere Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The extend ( ) list method 

‚Ä¢ The Set data type and set ( ) function 

‚Ä¢ The itertools . product ( ) function 



Alan says, "When we want to sink a convey, we send out an 
observation plane first. It is ostensibly an observation plane. Of 
course, to observe is not its real duty ‚Äî We already know exactly 
where the convoy is. Its real duty is to be observed ‚Äî That is, to fly 
close enough to the convoy that it will be noticed by the lookouts on 
the ships. The ships will then send out a radio message to the effect 
that they have been sighted by an Allied observation plane. Then, 
when we come round and sink them, the Germans will not find it 
suspicious ‚Äî At least, not quite so monstrously suspicious that we 
knew exactly where to go." 

Alan says, "Unless we continue to do stunningly idiotic things like 
sinking convoys in the fog, they will never receive any clear and 
unmistakable indications that we have broken Enigma." 

"Cryptonomicon" by Neal Stephenson 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 319 



There are two different methods to hack the Vigenere cipher. The first is a brute -force attack that 
tries every word in the dictionary file as the Vigenere key. This method will only work if an 
English word like "RAVEN" or "DESK" was used for the key instead of a random key like 
"VUWFE" or "PNFJ". The second is a more sophisticated method that works even if a random 
key was used. The earliest record of its use was by the mathematician Charles Babbage in the 19 th 
century. 

The Dictionary Attack 

If the Vigenere key is an English word it is very easy to memorize. But never use an English 
word for the encryption key. This makes your ciphertext vulnerable to a dictionary attack. 

A dictionary attack is a brute -force technique where a hacker attempts to decrypt the ciphertext 
using the words from a dictionary file as the keys. The dictionary.txt dictionary file available on 
this book's website (at http://inypy.co has about 45,000 English words. It takes 

less than 5 minutes for my computer to run through all of these decryptions for a message the size 
of a long paragraph. 

Source Code for a Vigenere Dictionary Attack Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as vigenereDictionaryHacker.py. Press F5 to run the program. 
Note that first you will need to download the pyperclip.py module and place this file in the same 
directory as the vigenereDictionaryHacker.py file. You can download this file from 
http;//inypy.conVpyperclip.py. 





Source code for vigenereDictionaryHacker.py 


1. 


# Vigenere Cipher Dictionary Hacker 


2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 


4. 
5. 


import detectEngl i sh , vigenereCipher , pyperclip 


6. 


def main() : 


7. 


ciphertext = """Tzx isnz eccjxkg nfq lol mys bbqq I lxcz.""" 


8. 
9. 


hackedMessage = hackVi genere(ci phertext) 


10. 


if hackedMessage != None: 


11. 


printC Copying hacked message to clipboard:') 


12. 


pri nt(hackedMessage) 


13. 


pypercl i p . copy (hackedMessage) 


14. 


el se : 


15. 


printC Failed to hack encryption.') 


16. 





320 http://inventwithpython.com/hacking 



17. 

18. def hackVigenere(ci phertext) : 

19. fo = open ('dictionary.txt') 

20. words = fo. readlinesO 

21. fo.closeO 
22. 

23. for word in words: 

24. word = word.stripO # remove the newline at the end 

25. decryptedText = vi genereCi pher . decryptMessage(word , ci phertext) 

26. "if detectEngl i sh . i sEngl i sh(decryptedText , wordPercentage=40) : 

27. # Check with user to see if the decrypted key has been found. 

28. printO 

29. pri nt( ' Possi bl e encryption break:') 

30. printC'Key ' + str(word) + ': ' + decryptedText [: 100] ) 

31. printO 

32. printC'Enter D for done, or just press Enter to continue 
breaking: ') 

33. response = input('&gt; ') 
34. 

35. if response. upperC) .startswith('D') : 

36. return decryptedText 
37. 

38. if name == 1 main ': 

39. mainO 



Sample Run of the Vigenere Dictionary Hacker Program 

When you run this program the output will look like this: 



Possible encryption break: 

Key ASTROLOGY: The reel yecrets crk not the qnks I tell. 
Enter D for done, or just press Enter to continue breaking: 



Possible encryption break: 

Key ASTRONOMY: The real secrets are not the ones I tell. 

Enter D for done, or just press Enter to continue breaking: 
&gt; d 

Copying hacked message to clipboard: 

The real secrets are not the ones I tell. 



The first keyword it suggests ("ASTROLOGY") doesn't quite work, so the user presses Enter to 
let the hacking program continue until it gets the correct decryption key ("ASTRONOMY"). 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 321 



The readlines ( ) File Object Method 

20. words = fo . readl i nes() 

File objects returned from open ( ) have a readlines ( ) method. Unlike the read ( ) method 
which returns the full contents of the file as a single string, the readlines () method will 
return a list of strings, where each string is a single line from the file. Note that each of the strings 
in the list will end with a \ n newline character (except for possibly the very last string, since the 
file might not have ended with a newline). 

The source code for this program isn't anything we haven't seen in previous hacking programs in 
this book, aside from the new readlines ( ) method. The hackVigenere ( ) function reads 
in the contents of the dictionary file, uses each word in that file to decrypt the ciphertext, and if 
the decrypted text looks like readable English it will prompt the user to quit or continue. 

As such, we won't do a line-by-line explanation for this program, and instead continue on with a 
program that can hack the Vigenere cipher even when the key was not a word that can be found 
in the dictionary. 

The Babbage Attack &amp; Kasiski Examination 

Charles Babbage is known to have broken the Vigenere cipher, but he never published his results. 
Later studies revealed he used a method that was later published by early 20 th -century 
mathematician Friedrich Kasiski. 

"Kasiski Examination" is a process used to determine how long the Vigenere key used to encrypt 
a ciphertext was. After this is determined, frequency analysis can be used to break each of the 
subkeys. 

Kasiski Examination, Step 1 - Find Repeat Sequences 7 Spacings 

The first part of Kasiski Examination is to find every repeated set of letters at least three letters 
long in the ciphertext. These are significant, because they could indicate that they were the same 
letters of plaintext encrypted with the same subkeys of the key. For example, if the ciphertext is 
"Ppqca xqvekg ybnkmazu ybngbal jon i tszm jyim. Vrag voht vrau c tksg. Ddwuo xitlazu vavv 
raz c vkb qp iwpou." and we remove the non-letters, the ciphertext looks like this: 

PPQCAXQVEKGYBNKMAZUYBNGBAL JONITS ZM JYIMVRAGVOHTVRAUCTKSGDDWUOXITLA 
ZUVAWRAZCVKBQPIWPOU 

You can see that the sequences VRA, AZU, and YBN repeat in this ciphertext: 



322 http://inventwithpython.com/hacking 



PPQCAXQVEKGYBNKMAZUYBNGBAL JONITSZM JYIM VRA GVOHT VRA UCTKSGDDWUOXITLA 
Z UVA WRA Z CVKBQ PIWPOU 

PPQCAXQVEKGYBNKMAZUYBNGBAL JONITSZM JYIMVRAGVOHTVRAUCTKSGDDWUOXITLA 
ZUVAWRA ZCVKBQPIWPOU 

PPQCAXQVEKG YBN KMAZU YBN GBAL JONITSZM JYIMVRAGVOHTVRAUCTKSGDDWUOXITLA 
ZUVAWRAZCVKBQPIWPOU 

After finding the repeated sequences, get a count of the spacing between the sequences. If we 
count the number of letters between the start of each of these sequences, we find that: 

‚Ä¢ Between the first and second VRA sequences there are 8 letters. 

‚Ä¢ Between the second and third VRA sequences there are 24 letters. 

‚Ä¢ Between the first and third VRA sequences there are 32 letters. 

‚Ä¢ Between the first and second AZU there are 48 letters. 

‚Ä¢ Between the first and second YBN there are 8 letters. 

Kasiski Examination, Step 2 - Get Factors of Spacings 

So the spacings are 8, 8, 24, 32, and 48. Let's find the factors of each of these numbers (not 
including one): 

‚Ä¢ The factors of 8 are 2, 4, and 8. 

‚Ä¢ The factors of 24 are 2, 4, 6, 8, 12, and 24. 

‚Ä¢ The factors of 32 are 2, 4, 8, and 16. 

‚Ä¢ The factors of 48 are 2, 4, 6, 8, 12, 24, and 48. 

So the spacings of 8, 8, 24, 32, and 48 expand to this list of factors: 2, 2, 2, 2, 4, 4, 4, 4, 6, 6, 8, 8, 
8, 8, 12, 12, 16, 24, 24, and 48. If we do a count of these factors, we get this: 

Table 21-1. Factor count from our "Ppqca xqvekg..." example. 



Factor 


Count 


2 


Appears 4 times. 


4 


Appears 4 times. 


6 


Appears 2 times. 


8 


Appears 4 times. 


12 


Appears 2 times. 


16 


Appears 1 time. 


24 


Appears 2 times. 


48 


Appears 1 time. 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 323 



The factors that have the highest count are the most likely lengths of the Vigenere key. In 

our example above, these are 2, 4, and 8. The Vigenere key is probably 2, 4, or 8 letters long. 

Get Every Nth Letters from a String 

For this example, we will guess that the key length is 4. Next we will want to split up the 
ciphertext into every 4 th letter. This means we want the following underlined letters as a separate 
string: 

Every 4 th letter starting with the first letter: 

PPQCAXQVEKGYBNKMAZUYBNGBAL JONITSZMJY^MVRAGVO 

Every 4 th letter starting with the second letter: 

PPQCAXQVEKGYBNKMAZUYBNGBALJONITSZMJYI^RAGVOHTVRAUCTKS 

Every 4 th letter starting with the third letter: 

PPQCAXQVEKGYBNK^ZUYBNGBALJONITSZMJYIMVM 

Every 4 th letter starting with the fourth lettter: 

PPQCAXQVEKGYBNK^ZUYBNGBALJONITSZMJYIMV^GVO^ 

When combined, they become these four strings: 

Every 4 th letter starting with the first letter: PAEBABANZ I AHAKDXAAAKI U 

Every 4 th letter starting with the second letter: PXKNZNLIMMGTUSWI ZVZBW 

Every 4 th letter starting with the third letter: QQGKUGJT JWVCGUTUVCQP 

Every 4 th letter starting with the fourth letter: CVYMYBOSYRORTDOLVRVPO 



If our guess from Kasiski Examination was correct and the decryption key was in fact 4 
characters long, then the first subkey of the key would have been used to encrypt the characters in 
the first string above, the second subkey of the key would have been used to encrypt the 
characters in the second string above, and so on. 

Frequency Analysis 

Remember, the Vigenere cipher is the same as the Caesar cipher, except it uses multiple subkeys. 
Kasiski Examination tells us how many subkeys were used for the ciphertext, now we just have to 
hack each subkey one at a time. Let's try to hack the first of these four ciphertext strings: 

P AEB AB AN Z I AH AK DXAAAK I U 

We will decrypt this string 26 times, once for each of the 26 possible subkeys, and then see what 
English frequency match score the decrypted text has. In the table below, the first column is the 
subkey used to decrypt the PAEBABANZ I AHAKDXAAAK I U string. The second column is the 
returned decrypted text value from vigenereCipher . decryptMessage ( subkey, 



324 http://inventwithpython.com/hacking 



' PAEBABANZ I AHAKDXAAAKIU ' ) where subkey is the subkey from the first column. The 
third column is the returned value from 

f reqAnalysis . englishFreqMatchScore (decryptedText ) where 
decryptedText is the value from the second column. 

Table 21-2. English frequency match score for each decryption. 



English 
Frequency 



Subkey 


Text When PAEB... is Decrypted 
with the Subkey 


Match 
Score 


'A' 


' PAEBABANZ I AHAKDXAAAKIU ' 


2 


' B ' 


I l~7 "7\ r~7"7\ I~71\/r^7"TTI~7 /"""I r~7 ~r r T I~7 l~7 I~7 ttt m I 

' OZDAZAZMYHZGZ JCWZZZ JHT ' 


1 


' C ' 


' NYCZYZYLXGYFYIBVYYYIGS ' 


1 


' D ' 


' MXBYXYXKWFXEXHAUXXXHFR ' 


0 


' E ' 


' LWAXWXWJVEWDWGZTWWWGEQ ' 


1 


' F ' 


I T^"T T I~7 F.7T TT.7T T ~T X X T ‚Äî \T T/^1T T T ‚Äî 1 TrOT TT TT T T ‚Äî 1 T~\ I 

' KVZWVWVIUDVCVFYSWVFDP ' 


0 


' G ' 


' JUYVUVUHTCUBUEXRUUUECO ' 


1 


' H ' 


' ITXUTUTGSBTATDWQTTTDBN ' 


1 


' I ' 


' HSWTSTSFRASZSCVPSSSCAM ' 


2 


' J' 


' GRVSRSREQZRYRBUORRRBZL ' 


0 


' K ' 


' FQURQRQDPYQXQATNQQQAYK ' 


1 


' L ' 


' EPTQPQPCOXPWPZSMPPPZXJ ' 


0 


' M ' 


' DOSPOPOBNWOVOYRLOOOYWI ' 


1 


' N ' 


' CNRONONAMVNUNXQKNNNXVH ' 


2 


'0' 


' BMQNMNMZLUMTMWP JMMMWUG ' 


1 


i pi 


' ALPMLMLYKTLSLVOILLLVTF ' 


1 


‚Ä¢Q' 


' ZKOLKLKX JSKRKUNHKKKUSE ' 


0 


'R' 


' Y JNK JK JWIRJQ JTMG JJJTRD ' 


1 


' S ' 


'XIMJIJIVHQIPISLFIIISQC ' 


1 


1 rj-i I 


' WHLIHIHUGPHOHRKEHHHRPB ' 


1 


'U' 


' VGKHGHGTFOGNGQ JDGGGQOA ' 


1 


'V 


' UF JGFGFSENFMFPICFFFPNZ ' 


1 


' w 


' TEIFEFERDMELEOHBEEEOMY ' 


2 


'X' 


' SDHEDEDQCLDKDNGADDDNLX ' 


2 


' Y ' 


' RCGDCDCPBKC JCMFZCCCMKW ' 


0 


' Z ' 


' QBFCBCBOAJBIBLEYBBBL JV ' 


0 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 325 



The subkeys that produce decryptions with the closest frequency match to English are the ones 
that are most likely to be the real subkey. In the above decryptions (for the 1 st of the four 
ciphertext strings), 'A', 'I', ' N ' , ' W ' , and ' X ' are the subkeys that have the highest 
frequency matches with English. Note that these scores are low in general because there isn't 
enough ciphertext to give us a large sample of text, but it still ends up working well. 

We need to repeat this 26-decryptions-and-frequency-match for the other three strings to 
find out their most likely subkeys. After this frequency analysis, we find: 

The most likely subkeys for the first string are: A, I, N, W, and X 

The most likely subkeys for the second string are: I and Z 

The most likely subkey for the third string is: C 

The most likely subkeys for the fourth string are: K, N, R, V, and Y 

Brute-Force through the Possible Keys 

Next we will brute -force the key by trying out every combination of subkey. Because there are 5 
possible subkeys for the first subkey, 2 for the second subkey, 1 for the third subkey, and 5 for the 
fourth subkey, the number of combinations is 5 x 2 x 1 x 5 or 50 possible keys to brute-force 
through. This is much better than the 26 x 26 x 26 x 26 or 456,976 possible keys we would have 
to brute -force through if we had not narrowed the list of possible subkeys. This difference 
becomes even greater if the Vigenere key had been longer! 



AICK 


IICK 


NICK 


WICK 


XICK 


AICN 


IICN 


NICN 


WICN 


XICN 


AICR 


NCR 


NICR 


WICR 


XICR 


AICV 


IICV 


NICV 


WICV 


XICV 


AICY 


IICY 


NICY 


WICY 


XICY 


AZCK 


IZCK 


NZCK 


WZCK 


XZCK 


AZCN 


IZCN 


NZCN 


WZCN 


XZCN 


AZCR 


IZCR 


NZCR 


WZCR 


XZCR 


AZCV 


IZCV 


NZCV 


WZCV 


XZCV 


AZCY 


IZCY 


NZCY 


WZCY 


XZCY 



Now it's just a matter of going through all 50 of these decryption keys for the full ciphertext and 
seeing which one produces a readable English plaintext. If you do this, you'll find that the key to 
the "Ppqca xqvekg. . ." ciphertext is "WICK". 



326 http://inventwithpython.com/hacking 



Source Code for the Vigenere Hacking Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as vigenereHacker.py. Press F5 to run the program. Note that 
first you will need to download the pyperclip.py module and place this file in the same directory 
as the vigenereHacker.py file. You can download this file from }i^\ir^y^^ord^^Ti^^Y. 

The ciphertext in this program may be difficult to copy from the book, but you can copy &amp; paste 
it from http://mypy.co You can see if there are any differences between 

the text in your program to the text of the program in this book by using the online diff tool at 
http.://inypy.conVhackingdiff- 



Source code for vigenereHacker.py 

1. # Vigenere Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import itertools, re 

5. import vigenereCi pher , pyperclip, f reqAnalysis, detectEngl i sh 

6. 

7. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

8. SILENT_MODE = False # if set to True, program doesn't print attempts 

9. NUM_MOST_FREQ_LETTERS = 4 # attempts this many letters per subkey 

10. MAX_KEY_LENCTH = 16 # will not attempt keys longer than this 

11. NONLETTERS_PATTERN = re . compi 1 e( ' [AA-Z] ' ) 
12. 

13. 

14. def main() : 

15. # Instead of typing this ciphertext out, you can copy &amp; paste it 

16. # from http://invpy.com/vigenereHacker.py 

17. ciphertext = """Adiz Avtzqeci Tmzubb wsa m Pmilqev hal pqavtakuoi , 
Igouqdaf, kdmktsvmztsl , izr xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz 
hce vmhsgohuqbo ox kaakulmd gxiwvos, krgdurdny i rcmmstugvtawz ca tzm ocicwxfg 
jf "stscmilpy" oid "uwydptsbuci " wabt hce Lcdwig eiovdnw. Bgfdny qe kddwtk 
qjnkqpsmev ba pz tzm roohwz at xoexghzr kkusicw izr vrlqrwxist uboedtuuznum. 
Pimifo Icmlv Emf DI, Lcdwig owdyzd xwd hce Ywhsmnemzh Xovm mby Cqxtsm Supacg 
(CUKE) oo Bdmfqclwg Bomk, Tzuhvif'a ocyetzqofifo ositjm. Rem a lqys ce oie vzav 
wr Vpt 8, lpq gzclqab mekxabnittq tjr Ymdavn fihog cjgbhvnstkgds . Zm psqikmp o 
iuejqf jf lmoviiicqg aoj jdsvkavs Uzreiz qdpzmdg, dnutgrdny bts helpar jf lpq 
pjmtm, mb zlwkff jmwktoiiuix avczqzs ohsb ocplv nuby swbfwigk naf ohw Mzwbms 
umqeifm. Mtoej bts raj pq kjremp oo tzm Zooigvmz Khqauqvl Dincmalwdm, rhwzq vz 
cjmmhzd gvq ca tzm rwmsl lqgdgfa rem a kbafzd-hzaumae kaakulmd, hce SKQ. Wi 
1948 Tmzubb jgqzsy Msf Zsrmsv'e Qjmhcfwig Dincmalwdm vt Eizqcekbqf Pnadqfnilg, 
ivzrw pq onsaafsy if bts yenmxckmwvf ca tzm Yoiczmehzr uwydptwze oid tmoohe 
avfsmekbqr dn eifvzmsbuqvl tqazjgq. Pq kmolm m dvpwz ab ohw ktshiuix pvsaa at 
hojxtcbefmewn , afl bfzdakfsy okkuzgalqzu xhwuuqvl jmmqoigve gpez ie hce 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 327 



Tmxcpsgd-Lvvbgbubnkq zqoxtawz, ken up isme xqdgo otaqfqev qz hce 1960k. Bgfdny'a 
tchokmjivlabk fzsmtfsy if i ofdmavmz krgaqqptawz wi 1952, wzmz vjmgaqlpad iohn 
wwzq goidt uzgeyix wi tzm Cbdtwl Wwigvwy. Vz aukqdoev bdsvtemzh rilp rshadm 
tcmmgvqg (xhwuuqvl uiehmalqab) vs sv mzoejvmhdvw ba dmikwz. Hpravs rdev qz 
1954, xpsl whsm tow iszkk jqtjrw pug 42id tqdhcdsg, rfjm ugmbddw xawnofqzu. Vn 
avcizsl lqhzreqzsy tzif vds vmmhc wsa eidcalq; vds ewfvzr svp gjmw wfvzrk 
jqzdenmp vds vmmhc wsa mqxivmzhvl. Gv 10 Esktwunsm 2009, fgtxcrifo mb Dnlmdbzt 
uiydviyv, Nfdtaat Dmiem Ywiikbqf Bo j lab Wrgez avdw iz cafakuog pmjxwx ahwxcby 
gv nscadn at ohw Jdwoikp scqejvysit xwd "hce sxboglavs kvy zm ion tjmmhzd." Sa 
at Haq 2012 i bfdvsbq azmtmd'g widt ion bwnafz tzm Tcpsw wr Z j rva ivdez eaigd 
yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd. ' 



18. hackedMessage = hackVigenere(ci phertext) 

19. 

20. if hackedMessage != None: 

21. print('Copying hacked message to clipboard:') 

22. print(hackedMessage) 

23 . pypercl i p. copy (hackedMessage) 

24. else: 

25. print('Failed to hack encryption.') 
26. 

27. 

28. def findRepeatSequencesSpacings(message) : 

29. # Goes through the message and finds any 3 to 5 letter sequences 

30. # that are repeated. Returns a diet with the keys of the sequence and 

31. # values of a list of spacings (num of letters between the repeats). 
32. 

33. # Use a regular expression to remove non-letters from the message. 

34. message = NONLETTERS_PATTERN . sub( " , message. upperO) 
35. 

36. # Compile a list of seqLen-letter sequences found in the message. 

37. seqSpacings = {} # keys are sequences, values are list of int spacings 

38. for seqLen in range(3, 6): 

39. for seqStart in range(len(message) - seqLen): 

40. # Determine what the sequence is, and store it in seq 

41. seq = message [seqStart: seqStart + seqLen] 
42. 

43. # Look for this sequence in the rest of the message 

44. for i in range(seqStart + seqLen, len(message) - seqLen): 

45. if message[i:i + seqLen] == seq: 

46. # Found a repeated sequence. 

47. if seq not in seqSpacings: 

48. seqSpaci ngs [seq] = [] # initialize blank list 
49. 

50. # Append the spacing distance between the repeated 

51. # sequence and the original sequence. 

52. seqSpacings[seq] .append(i - seqStart) 

53. return seqSpacings 



328 http://inventwithpython.com/hacking 



54. 
55. 

56. def getllseful Factors (num) : 

57. # Returns a list of useful factors of num. By "useful" we mean factors 

58. # less than MAX_KEY_LENGTH + 1. For example, getUsef ul Factors(144) 

59. # returns [2, 72, 3, 48, 4, 36, 6, 24, 8, 18, 9, 16, 12] 
60. 

61. "if num &lt; 2: 

62. return [] # numbers less than 2 have no useful factors 
63. 

64. factors = [] # the list of factors found 
65. 

66. # When finding factors, you only need to check the integers up to 

67. # MAX_KEY_LENGTH . 

68. for i in range (2, MAX_KEY_LENGTH +1): # don't test 1 

69. if num % i ==0: 

70. factors. append(i) 

71. f actors. append (i nt (num / i)) 

72. if 1 in factors: 

73. factors . remove (1) 

74. return 1 i st(set(factors)) 
75. 

76. 

77. def getltemAtlndexOne(x) : 

78. return x[l] 
79. 

80. 

81. def getMostCommonFactors(seqFactors) : 

82. # First, get a count of how many times a factor occurs in seqFactors. 

83. factorCounts = {} # key is a factor, value is how often if occurs 
84. 

85. # seqFactors keys are sequences, values are lists of factors of the 

86. # spacings. seqFactors has a value like: {'GFD': [2, 3, 4, 6, 9, 12, 

87. # 18, 23, 36, 46, 69, 92, 138, 207], 'ALW : [2, 3, 4, 6, ...], ...} 

88. for seq in seqFactors: 

89. factorList = seqFactors [seq] 

90. for factor in factorList: 

91. if factor not in factorCounts: 

92. factorCounts [factor] = 0 

93. factorCounts [factor] += 1 
94. 

95. # Second, put the factor and its count into a tuple, and make a list 

96. # of these tuples so we can sort them. 

97. factorsByCount = [] 

98. for factor in factorCounts: 

99. # exclude factors larger than MAX_KEY_LENGTH 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 329 



100. 




if factor &lt;= MAX_KEY_LENGTH : 


101. 




# factorsByCount is a list of tuples: (factor, factorCount) 


102. 




# factorsByCount has a value like: [(3, 497), (2, 487), ...] 


103. 




factorsByCount. appendC (factor, factorCounts [factor] ) ) 


104. 






105. 




# Sort the list by the factor count. 


106. 




factorsByCount . sort(key=getItemAtIndexOne , reverse=True) 


107. 






108. 




return factorsByCount 


109. 






110. 






111. 


def 


kasi ski Exami nation(ci phertext) : 


112. 




# Find out the sequences of 3 to 5 letters that occur multiple times 


113. 




# in the ci phertext. repeatedSeqSpaci ngs has a value like: 


114. 




# { 1 EXG 1 1 [192] 'NAF' - [339 972 633] } 


115. 




repeatedSeqSpaci ngs = fi ndRepeatSequencesSpaci ngs (ci phertext) 


116. 






117. 




# See getMostCommonFactorsO for a description of seqFactors. 


118. 




seqFactors = {} 


119. 




for seq in repeatedSeqSpaci ngs : 


120. 




seqFactors [seq] = [] 


121. 




for spacing in repeatedSeqSpaci ngs [seq] : 


122. 




seqFactors [seq] . extend (getUseful Factors (spaci ng)) 


123. 






124. 




# See getMostCommonFactorsO for a description of factorsByCount. 


125. 




factorsByCount = getMostCommonFactors(seqFactors) 


126. 






127. 




# Now we extract the factor counts from factorsByCount and 


128. 




# put them in all Li kelyKeyLengths so that they are easier to 


129. 




# use later. 


130. 




all Li kelyKeyLengths = [] 


131. 




for twoIntTuple in factorsByCount: 


132. 




al 1 Li kel yKeyLengths . append (twoIntTupl e [0] ) 


133. 






134. 




return allLikelyKeyLengths 


135. 






136. 






137. 


def 


getNthSubkeysLetters(n , keyLength, message): 


138. 




# Returns every Nth letter for each keyLength set of letters in text. 


139. 




# E.g. getNthSubkeysLettersQ, 3, 'ABCABCABC') returns 'AAA' 


140. 




# getNthSubkeysLetters(2, 3, 'ABCABCABC') returns ' BBB' 


141. 




# getNthSubkeysLetters(3, 3, 'ABCABCABC') returns 'CCC 


142. 




# getNthSubkeysLettersd, 5, ' ABCDEFGHI ' ) returns 'AF' 


143. 






144. 




# Use a regular expression to remove non-letters from the message. 


145. 




message = NONLETTERS_PATTERN . sub( " , message) 



330 http://inventwithpython.com/hacking 



146. 






147. 




i = n - 1 


148. 




letters = [] 


149. 




while i &lt; 1 en (message) : 


150. 




1 etters . append (message [i ] ) 


151. 




i += keyLength 


152. 




return 1 1 . join(letters) 


153. 






154. 






155. 


def 


attemptHackWi thKeyLength(ci phertext , mostLi kelyKeyLength) : 


156. 




# Determine the most likely letters for each letter "in the key. 


157. 




ciphertextUp = ci phertext . upper () 


158. 




# allFreqScores is a list of mostLi kelyKeyLength number of lists. 


159. 




# These inner lists are the freqScores lists. 


160. 




allFreqScores = [] 


161. 




for nth in range(l, mostLi kelyKeyLength + 1): 


162. 




nthLetters = getNthSubkeysLetters(nth , mostLi kelyKeyLength , 


ciphertextllp) 


163. 






164. 




# freqScores is a list of tuples like: 


165. 




# [(&lt;letter&gt;, &lt;Eng. Freq. match score&gt;) , ... ] 


166. 




# List is sorted by match score. Higher score means better match. 


167. 




# See the engl i shFreqMatchScoreO comments in freqAnalysis.py. 


168. 




freqScores = [] 


169. 




for possibleKey in LETTERS: 


170. 




decryptedText = vigenereCipher.decryptMessage(possibleKey, 


nthLetters) 


171. 




keyAndFreqMatchTuple = (possibleKey, 


f reqAnalysi s . engl i shFreqMatchScore(decryptedText)) 


172. 




freqScores .append (keyAndFreqMatchTuple) 


173. 




# Sort by match score 


174. 




freqScores . sort(key=getItemAtIndexOne , reverse=True) 


175. 






176. 




al 1 FreqScores . append(f reqScores [ : NUM_MOST_FREQ_LETTERS] ) 


177. 






178. 




if not SILENT_MODE: 


179. 




for i in range(l en(al 1 FreqScores)) : 


180. 




# use i + 1 so the first letter is not called the "Oth" letter 


181. 




print('Possible letters for letter %s of the key: ' % (i + 1) , 


end= 


') 




182. 




for freqScore in al 1 FreqScores [i ] : 


183. 




print('%s ' % freqScore [0] , end=") 


184. 




printO # print a newline 


185. 






186. 




# Try every combination of the most likely letters for each position 


187. 




# in the key. 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 331 



188. for indexes in i tertool s . product(range(NUM_MOST_FREQ_LETTERS) , 
repeat=mostLi kelyKeyLength) : 

189. # Create a possible key from the letters in al 1 FreqScores 

190. possibleKey = ' ' 

191. for i in range (mostLi kelyKeyLength) : 

192. possibleKey += al 1 FreqScores [i ] [i ndexes [i ]] [0] 

193. 

194. if not SILENT_M0DE: 

195. printC Attempting with key: %s' % (possibleKey)) 

196. 

197. decryptedText = vigenereCipher.decryptMessage(possibleKey, 

ciphertextUp) 

198. 

199. if detectEnglish.isEnglish(decryptedText) : 

200. # Set the hacked ciphertext to the original casing. 

201. origCase = [] 

202. for i in range(len(ciphertext)) : 

203. if ci phertext [i ]. i supper () : 

204. origCase. append (dec ryptedText [i ] .upper()) 

205. else: 

206. origCase. append(decryptedText[i] .lower()) 

207. decryptedText = ' ' . join(origCase) 

208. 

209. # Check with user to see if the key has been found. 

210. pri nt( 1 Possi ble encryption hack with key %s:' % (possibleKey)) 

211. print(decryptedText[:200]) # only show first 200 characters 

212. print() 

213. print('Enter D for done, or just press Enter to continue 
hacki ng : ' ) 

214. response = input('&gt; ') 
215. 

216. if response. stripO .upper() .startswith('D') : 

217. return decryptedText 
218. 

219. # No English-looking decryption found, so return None. 

220. return None 
221. 

222. 

223. def hackVi genere(ci phertext) : 

224. # First, we need to do Kasiski Examination to figure out what the 

225. # length of the ciphertext's encryption key is. 

226. al 1 Li kelyKeyLengths = kasiski Examination (ciphertext) 

227. if not SILENT_M0DE: 

228. keyLengthStr = ' ' 

229. for keyLength in all Li kelyKeyLengths : 

230. keyLengthStr += '%s ' % (keyLength) 



332 http://inventwithpython.com/hacking 



231. print('Kasiski Examination results say the most likely key lengths 

are: ' + keyLengthStr + '\n') 

232. 

233. for keyLength in all Li kel yKeyLengths : 

234. if not SILENT_MODE: 

235. pri nt( 1 Attempti ng hack with key length %s (%s possible 
keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) 

236. hackedMessage = attemptHackWi thKeyLength(ci phertext , keyLength) 

237. if hackedMessage != None: 

238. break 
239. 

240. # If none of the key lengths we found using Kasiski Examination 

241. # worked, start brute-forcing through key lengths. 

242. if hackedMessage == None: 

243. if not SILENT_MODE: 

244. pri nt( 1 Unabl e to hack message with likely key length(s). 
Brute-forcing key length... 1 ) 

245. for keyLength in ranged, MAX_KEY_LENGTH + 1): 

246. # don't re-check key lengths already tried from Kasiski 

247. if keyLength not in all Li kel yKeyLengths: 

248. if not SILENT_MODE: 

249. pri nt( 'Attempti ng hack with key length %s (%s possible 
keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) 

250. hackedMessage = attemptHackWi thKeyLength(ci phertext, 
keyLength) 

251. if hackedMessage != None: 

252. break 

253. return hackedMessage 
254. 

255. 

256. # If vigenereHacker . py is run (instead of imported as a module) call 

257. # the mainQ function. 



258. if name == ' main ': 

259. mainQ 



Sample Run of the Vigenere Hacking Program 

When you run the vigenereHacker.py program, the output will look like this: 



Kasiski Examination results say the most likely key lengths are: 3 2 6 4 12 

Attempting hack with key length 3 (27 possible keys)... 

Possible letters for letter 1 of the key: A L M 

Possible letters for letter 2 of the key: S N 0 

Possible letters for letter 3 of the key: VIZ 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 333 



Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt 
Attempt! 
Possible 
Possi bl e 
Attempt! 
Attempt! 
Attempt! 
Attempti 
Attempti 
Attempti 
Attempti 
Attempti 
Attempti 
Attempti 
Possible 
Possi bl e 
Possi bl e 
Possible 
Possi bl e 
Possi bl e 



ng with key 



th key 
th key 



th key 
th key 
th key 
th key 
th 
th 
th 
th 



key 
key 
key 
key 
th key 
th key 
th 
th 



key 
key 
th key 
th key 



key 
key 
key 
key 



ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 
ng w 

ng hack with 
letters for 
letters for 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing with key: 
ing hack with 
letters for 
letters 
letters 
letters for 
letters for 
letters for 



th key 
th key 
th key 
th key 
th key 
th key 



ASV 
ASI 
ASZ 
ANV 
AN I 
ANZ 
AOV 
AOI 
AOZ 
LSV 
LSI 
LSZ 
LNV 
LNI 
LNZ 
LOV 
LOI 
LOZ 
MSV 
MSI 
MSZ 
MNV 
MNI 
MNZ 
MOV 
MOI 
MOZ 

key length 2 (9 possible keys) 
letter 1 of the key: 0 A E 
of the key: 



for 
for 



M S 



1 etter 
OM 
OS 
01 
AM 
AS 
AI 
EM 
ES 
EI 

key length 6 (729 possible keys), 
letter 1 of the key: A E 0 
letter 2 of the key: S D C 
letter 3 of the key: I V X 
letter 4 of the key: M Z Q 
letter 5 of the key: 0 B Z 
letter 6 of the key: V I K 



334 http://inventwithpython.com/hacking 



Attempting with key: ASIMOV 

Possible encryption hack with key ASIMOV: 

ALAN MATH I SON TURING WAS A BRITISH MATHEMATICIAN, LOGICIAN, CRYPTANALYST, AND 
COMPUTER SCIENTIST. HE WAS HIGHLY INFLUENTIAL IN THE DEVELOPMENT OF COMPUTER 
SCIENCE, PROVIDING A FORMALISATION OF THE CON 

Enter D for done, or just press Enter to continue hacking: 
&gt; d 

Copying hacked message to clipboard: 

Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and 
computer scientist. He was highly influential in the development of computer 

. . .skipped for brevity. . . 

his death was accidental. On 10 September 2009, following an Internet campaign, 
British Prime Minister Gordon Brown made an official public apology on behalf 
of the British government for "the appalling way he was treated." As of May 
2012 a private member's bill was before the House of Lords which would grant 
Turing a statutory pardon if enacted. 



How the Program Works 



vigenereHacker.py 

1. # Vigenere Cipher Hacker 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import itertools, re 

5. import vigenereCi pher , pyperclip, f reqAnalysis, detectEngl i sh 

6. 

7. LETTERS = 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 

8. SILENT_MODE = False # if set to True, program doesn't print attempts 

9. NUM_MOST_FREQ_LETTERS = 4 # attempts this many letters per subkey 

10. MAX_KEY_LENGTH = 16 # will not attempt keys longer than this 

11. NONLETTERS_PATTERN = re . compi 1 e( ' [AA-Z] ' ) 

The hacking program imports many different modules, including a new module named 
itertools. The constants will be explained as they are used in the program. 



vi genereHacker . py 

14. def main() : 

15. # Instead of typing this ciphertext out, you can copy &amp; paste it 

16. # from http://invpy.com/vigenereHacker.py 

17. ciphertext = """Adiz Avtzqeci Tmzubb wsa m Pmilqev hal pqavtakuoi , 
Igouqdaf, kdmktsvmztsl , izr xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 335 



...skipped for brevity... 

at Haq 2012 i bfdvsbq azmtmd'g widt "ion bwnafz tzm Tcpsw wr Z j rva ivdcz eaigd 
yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd. ' 



18. hackedMessage = hackVigenere(ci phertext) 

19. 

20. "if hackedMessage != None: 

21. print ('Copying hacked message to clipboard:') 

22. pri nt(hackedMessage) 

23 . pypercl i p. copy (hackedMessage) 

24. else: 

25. print('Failed to hack encryption.') 



The main ( ) function of the hacking program is similar to the main ( ) functions of previous 
hacking functions. The ciphertext is passed to the hackVigenere ( ) cipher, which either 
returns the decrypted string (if the hack was successful) or the None value (if the hack failed). If 
successful, the hacked message is printed to the screen and copied to the clipboard. 

Finding Repeated Sequences 

vigenereHacker. py 

28. def findRepeatSequencesSpacings(message) : 



29. # Goes through the message and finds any 3 to 5 letter sequences 

30. # that are repeated. Returns a diet with the keys of the sequence and 

31. # values of a list of spacings (num of letters between the repeats). 
32. 

33. # Use a regular expression to remove non-letters from the message. 

34. message = NONLETTERS_PATTERN . sub( " , message . upperO) 
35. 

36. # Compile a list of seqLen-1 etter sequences found in the message. 

37. seqSpacings = {} # keys are sequences, values are list of int spacings 

38. for seqLen in range(3, 6): 



The f indRepeatSequencesSpacings ( ) locates all the repeated sequences of letters in the 
message string and counts the spacings (that is, the number of letters) between the sequences. 
First, line 34 converts the message to uppercase and removes any non-letter characters from 
message using the sub ( ) regular expression method. 

The seqSpacings dictionary will have keys of the sequence strings and values of a list with 
the integer number of letters between all the occurrences of that sequence in the key. The 
previous "PPQCAXQV. . ." example string from earlier in the "Kasiski Examination, Step 1" 
section, if passed as message, would cause f indRepeatSequenceSpacings () to return 
{ ' VRA ' : [8, 24, 32], 'AZU': [48], ' YBN ' : [8]}. 



336 http ://inventwithpy thon. com/hacking 



The code inside line 38 's for loop will find the repeated sequences in message and calculate 
the spacings. On the first iteration, it will find sequences that are exactly 3 letters long. On the 
next iteration it will find sequences exactly 4 letters long, and then 5 letters long. (You can 
change what sequence lengths the code searches for by modifying the range ( 3 , 6 ) call on 
line 38, but finding repeated sequences of length 3, 4 and 5 seems to work for most ciphertexts.) 

vigenereHacker.py 

39. for seqStart "in range(len(message) - seqLen) : 

40. # Determine what the sequence is, and store it in seq 

41. seq = message [seqStart: seqStart + seqLen] 

The for loop on line 39 makes sure that we iterate over every possible substring of length 
seqLen in the message string. Line 41 sets the seq variable with the sequence we are looking 
for. For example, if seqLen is 3 and message is ' PPQCAXQ ' , we would want to search for the 
following sequences (notice the indexes at the top of the ' PPQCAXQ ' string): 

Table 21-3. Values of seq from message depending on the value in seqStart. 



Indexes 

On 1 st iteration, seqStart is 0 
On 2 nd iteration, seqStart is 1 
On 3 rd iteration, seqStart is 2 
On 4 th iteration, seqStart is 3 
On 5 th iteration, seqStart is 4 



0123456 
' PPQ CAXQ ' 
' P PQC AXQ ' 
' PP QCA XQ ' 
' PPQ CAX Q ' 
' PPQCAXQ' 



(PPQ starts at index 0.) 

(PQC starts at index 1.) 

(QCA starts at index 2.) 

(CAX starts at index 3.) 

(AXQ starts at index 4, which is 

what len (message) - seqLen 

evaluates to and is the last index.) 



vigenereHacker.py 

43. # Look for this sequence in the rest of the message 

44. for i in range(seqStart + seqLen, len(message) - seqLen): 

45. if message[i:i + seqLen] == seq: 

The for loop on line 44 is inside line 39's for loop and sets i to be the indexes of every 
possible sequence of length seqLen in message. These indexes start at seqStart + 
seqLen (that is, after the sequence currently in seq) and go up to len (message ) - 
seqLen (which is the last index where a sequence of length seqLen can be found). 

The expression message [i : i + seqLen] will evaluate to the substring of message that 
gets checked for being a repeat of seq on line 45. If it is, then we need to calculate the spacing 
and add it to the seqSpacings dictionary. This is done on lines 46 to 52. 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 337 





vigenereHacker.py 


46. 


# Found a repeated sequence. 


47. 


if seq not in seqSpacings: 


48. 


seqSpaci ngs [seq] = [] # initialize blank list 


49. 




50. 


# Append the spacing distance between the repeated 


51. 


# sequence and the original sequence. 


52. 


seqSpacings[seq] .append(i - seqStart) 



The spacing between the sequence we've found at message [ i : i + seqLen ] and the 
original sequence at message [ seqStart : seqStart+seqLen] is simply i - 
seqStart. Notice that i and seqStart are the beginning indexes before the colons. So the 
integer that i - seqStart evaluates to is the spacing between the two sequences, which is 
appended to the list stored at seqSpacings [seq] . 



(Lines 47 and 48 guarantee there is a list at this key by checking beforehand if seq exists as a 
key in seqSpacings. If it does not, then seqSpacings [seq] is set as a key with a blank 
list as its value.) 







vigenereHacker.py 


53. 


return seqSpacings 





By the time all these for loops have finished, the seqSpacings dictionary will contain every 
repeated sequence of length 3, 4, and 5 and their spacings. This dictionary is returned from 

f indRepeatSequencesSpacings ( ) on line 53. 



Calculating Factors 



vigenereHacker.py 

56. def getUseful Factors (num) : 



57. # Returns a list of useful factors of num. By "useful" we mean factors 

58. # less than MAX_KEY_LENGTH + 1. For example, getUseful Factors(144) 

59. # returns [2, 72, 3, 48, 4, 36, 6, 24, 8, 18, 9, 16, 12] 
60. 

61. if num &lt; 2: 

62. return [] # numbers less than 2 have no useful factors 
63. 

64. factors = [] # the list of factors found 



The only useful factors for the hacking program's Kasiski Examination code are of length 

MAX_KEY_LENGTH and under, not including 1. The getUsef ulFactors ( ) takes a num 



338 http://inventwithpython.com/hacking 



parameter and returns a list of "useful" factors. The function does not necessarily return all the 
factors of num in this list. 



Line 61 checks for the special case where num is less than 2. In this case, line 62 returns the 
empty list because these numbers have no useful factors. 





vigenereHacker . py 


66. 


# When finding factors, you only need to check the integers up to 


67. 


# MAX_KEY_LENGTH . 


68. 


for i in range (2, MAX_KEY_LENGTH +1): # don't test 1 


69. 


if num % i ==0: 


70. 


factors. append(i) 


71. 


f actors. append (int (num / i)) 



The for loop on line 68 loops through the integers 2 up to MAX_KEY_LENGTH (including the 
value in MAX_KEY_LENGTH itself, since the second argument to range ( ) is 
MAX_KEY_LENGTH + 1). 



If num % i is equal to 0, then we know that i evenly divides (that is, has 0 remainder) num and 
is a factor of num. In this case, line 70 appends i to the list of factors in the factors variable. 
Line 71 also appends num / i (after converting it from a float to an int, since the / operator 
always evaluates to a float value). 







vigenereHacker.py 


72. 


if 1 in factors: 




73. 


factors . remove (1) 





The value 1 is not a useful factor, so we remove it from the factors list. (If the Vigenere key 
had a length of 1, the Vigenere cipher would be no different from the Caesar cipher!) 



Removing Duplicates with the set() Function 







vigenereHacker.py 


74. 


return 1 i st(set(factors)) 





The factors list might contain duplicates. For example, if getUsef ulFactors ( ) was 
passed 9 for the num parameter, then 9 % 3 == 0 would be True and both i and int (num 
/ i ) (both of which evaluate to 3) would have been appended to factors. But we don't want 
duplicate numbers to appear in our factors list. 



Line 74 passes the list value in factors to set ( ) which returns a set form of the list. The set 
data type is similar to the list data type, except a set value can only contain unique values. You 

Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 339 



can pass a list value to the set ( ) function and it will return a set value form of the list. This set 
value will not have any duplicate values in it. If you pass this set value to 1 i s t ( ) , it will return 
a list value version of the set. This is how line 74 removes duplicate values from the factors list. 
Try typing the following into the interactive shell: 



¬ª&gt; set([l, 2, 3, 3, 4]) 
set([l, 2, 3, 4]) 

¬ª&gt; spam = list (set ([2, 2, 2, 'cats', 2, 2])) 
¬ª&gt; spam 
[2, 'cats'] 

¬ª&gt; 



This list(set(factors) ) code is an easy way to remove duplicate factors from the 
factors list. The final list value is then returned from the function. 





vi genereHacker . py 


77. def getltemAtlndexOne(x) : 




78. return x[l] 





The getltemAtlndexOne ( ) is almost identical to getltemAtlndexZero ( ) from the 
freqAnalysis.py program in the previous chapter. This function is passed to sort ( ) to sort based 
on the item at index 1 of the items being sorted. (See the "The Program's 
getltemAtlndexZero ( ) Function" section in Chapter 20.) 



vi genereHacker . py 

81. def getMostCommonFactors(seqFactors) : 

82. # First, get a count of how many times a factor occurs in seqFactors. 

83. factorCounts = {} # key is a factor, value is how often if occurs 
84. 

85. # seqFactors keys are sequences, values are lists of factors of the 

86. # spacings. seqFactors has a value like: {'GFD': [2, 3, 4, 6, 9, 12, 

87. # 18, 23, 36, 46, 69, 92, 138, 207], 'ALW : [2, 3, 4, 6, ...], ...} 

Remember, we need to know the most common factor of the sequence spacings as a part of the 
Kasiski Examination because the most common factor is most likely going to be the length of the 
Vigenere key. 

The seqFactors parameter is a dictionary value created in the kasiskiExamination ( ) 
function, which is explained later. This dictionary has strings of sequences for keys and a list of 
integer factors for the value of each key. (These are factors of the spacing integers found by 
f indRepeatSequencesSpacings ( ) .) For example, seqFactors could contain a 



340 http://inventwithpython.com/hacking 



dictionary value like { ' VRA ': [8, 2 , 4 , 2 , 3, 4 , 6 , 8, 12, 16, 8, 2, 4], 
'AZU': [2, 3, 4, 6, 8, 12, 16, 24], ' YBN ' : [8, 2, 4]}. 

The getMostCommonFactors ( ) function will find the most common factors in 

seqF actors and return a list of two-integer tuples. The first integer in the tuple will be the 

factor and the second integer will be how many times it was in seqFactors. 

For example, getMostCommonFactors ( ) may return a list value such as [(3, 556), 
(2, 541), (6, 529), (4, 331), (12, 325), (8, 171), (9, 156), (16, 

105), (5, 98), (11, 86), (10, 84), (15, 84), (7, 83), (14, 68), 
(13, 52 ) ] . This means that in the seqFactors dictionary passed to 

getMostCommonFactors ( ) , the factor 3 showed up 556 times, the factor 2 showed up 541 
times, the factor 5 showed up 529 times, and so on. Note that 3 is the most frequent factor in the 
list and appears first in the list. 13 is the least frequent factor and is last in the list. 







vigenereHacker.py 


88. 


for seq in seqFactors: 




89. 


factorList = seqFactors [seq] 




90. 


for factor "in factorList: 




91. 


if factor not in factorCounts : 




92. 


factorCounts [factor] = 0 




93. 


factorCounts [factor] += 1 





For the first step of getMostCommonFactors ( ) the for loop on line 88 loops over every 
sequence in seqFactors, storing it in a variable named seq on each iteration. The list of 
factors in seqFactors for seq is stored in a variable named factorList on line 89. 



The factors in this list are looped over with a for loop on line 90. If a factor does not exist as a 
key in factorCounts, it is added on line 92 with a value of 0. On line 93, 
factorCounts [factor] (that is, the factor's value in factorCounts) is incremented. 



vi genereHacker . py 

95. # Second, put the factor and its count into a tuple, and make a list 

96. # of these tuples so we can sort them. 

97. factorsByCount = [] 

98. for factor in factorCounts: 

99. # exclude factors larger than MAX_KEY_LENGTH 

100. if factor &lt;= MAX_KEY_LENGTH : 

101. # factorsByCount is a list of tuples: (factor, factorCount) 

102. # factorsByCount has a value like: [(3, 497), (2, 487), ...] 

103. factorsByCount. append( (factor, factorCounts [factor] ) ) 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 341 



For the second step of getMostCommonFactors ( ) , we need to sort the values in the 
f actorCounts dictionary by their count. But dictionaries do not have an order, so we must 
first convert the dictionary into a list of two-integer tuples. (We did something similar in Chapter 
20 in the getFrequencyOrder ( ) function of the freqAnalaysis.py module.) This list value 
will be stored in a variable named f actorsByCount, which starts as an empty list on line 97. 

The for loop on line 98 goes through each of the factors in f actorCounts and appends this 
(factor, f actorCounts [ factor] ) tuple to the f actorsByCount list as long as the 
factor is less than or equal to MAX_KEY_LENGTH. 



vigenereHacker.py 

105. # Sort the list by the factor count. 

106. f actorsByCount . sort(key=getItemAtIndexOne , reverse=True) 

107. 

108. return factorsByCount 

After the for loop finishes adding all the tuples to factorsByCount, the last step of 
getMostCommonFactors ( ) is that the factorsByCount list is sorted on line 106. 
Because the getltemAtlndexOne function is passed for the key keyword argument and 
True is passed for the reverse keyword argument, the list is sorted in descending order by the 
factor counts. 

After being sorted, the list in factorsByCount is returned on line 108. 

The Kasiski Examination Algorithm 

vigenereHacker.py 

111. def kasi ski Examination (ciphertext) : 

112. # Find out the sequences of 3 to 5 letters that occur multiple times 

113. # in the ciphertext. repeatedSeqSpaci ngs has a value like: 

114. #{'EXC: [192], 'NAF': [339, 972, 633], ... } 

115. repeatedSeqSpaci ngs = findRepeatSequencesSpacings(ciphertext) 

The kasiskiExamination ( ) function returns a list of the most likely key lengths for the 
given ciphertext argument. The key lengths are integers in a list, with the first integer in the 
list being the most likely key length, the second integer the second most likely, and so on. 

The first step is to find the spacings between repeated sequences in the ciphertext. This is 
returned from f indRepeatSequencesSpacings ( ) as a dictionary with keys of the 
sequence strings and values of a list with the spacings as integers. 



342 http://inventwithpython.com/hacking 



The extend ( ) List Method 

The extend ( ) list method is very similar to the append ( ) list method. While the append ( ) 
method adds a single value passed to it to the end of the list, the extend ( ) method will add 
every item in a list argument to the end of the list. Try typing the following into the interactive 
shell: 



¬ª&gt; spam = [] 




¬ª&gt; eggs = ['cat', 'dog', 


mouse'] 


¬ª&gt; spam, extend (eggs) 




¬ª&gt; spam 




['cat', 'dog', 'mouse'] 




¬ª&gt; spam.extend([l, 2, 3]) 




¬ª&gt; spam 




['cat' , 'dog' , 'mouse' , 1, 


2, 3] 


¬ª&gt; 





Notice the difference if you pass a list to the append ( ) list method. The list itself gets appended 
to the end instead of the values in the list: 



¬ª&gt; spam = [] 

¬ª&gt; eggs = ['cat', 'dog', 'mouse'] 
¬ª&gt; spam, append (eggs) 
¬ª&gt; spam 

[['cat', 'dog', 'mouse']] 
¬ª&gt; spam.append([l, 2, 3]) 
¬ª&gt; spam 

[['cat', 'dog', 'mouse'], [1, 2, 3]] 

¬ª&gt; 





vigenereHacker.py 


117. 


# See getMostCommonFactorsO for a description of seqFactors. 


118. 


seqFactors = {} 


119. 


for seq in repeatedSeqSpaci ngs : 


120. 


seqFactors [seq] = [] 


121. 


for spacing in repeatedSeqSpaci ngs [seq] : 


122. 


seqFactors [seq] . extend (getUseful Factors (spaci ng)) 



While repeatedSeqSpacings is a dictionary that maps sequence strings to lists of integer 
spacings, we actually need a dictionary that maps sequence strings to lists of factors of those 
integer spacings. Lines 118 to 122 do this. 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 343 



Line 118 starts with an empty dictionary in seqFactors. The for loop on line 119 iterates 
over every key (which is a sequence string) in repeatedSeqSpacings. For each key, line 
120 sets a blank list to be the value in seqFactors. 

The for loop on line 121 iterates over all the spacing integers, which are each passed to a 
getUsefulFactors () call. The list returned from getUsef ulFactors () has each of its 
items appended to seqFactors [ seq] . 

When all the for loops are finished, seqFactors is a dictionary that maps sequence strings to 
lists of factors of integer spacings. 



vigenereHacker. py 

123. # See getMostCommonFactorsO for a description of factorsByCount . 

124. factorsByCount = getMostCommonFactors(seqFactors) 

The seqFactors dictionary is passed to getMostCommonFactors ( ) on line 124. A list of 
two-integer tuples (the first integer in the tuple being the factor, the second integer being the 
count of how often that factor appeared in seqFactors) is returned and stored in 

factorsByCount. 





vigenereHacker. py 


126. 


# Now we extract the factor counts from factorsByCount and 


127. 


# put them in all Li kelyKeyLengths so that they are easier to 


128. 


# use later. 


129. 


all Li kelyKeyLengths = [] 


130. 


for twoIntTuple in factorsByCount: 


131. 


al 1 Li kel yKey Lengths . append (twoIntTupl e [0] ) 


132. 




133. 


return allLikelyKeyLengths 



The kasiskiExamination () function doesn't return a list of two-integer tuples though, it 
returns a list of integer factors. These integer factors are in the first item of the two-integer tuples 
list in factorsByCount, so we need code to pull these integer factors out and put them in a 
separate list. 



This separate list will be stored in allLikelyKeyLengths, which to begin with is set to an 
empty list on line 129. The for loop on line 130 iterates over each of the tuples in 
factorsByCount, and appends the tuple's index 0 item to the end of 

allLikelyKeyLengths. 



344 http://inventwithpython.com/hacking 



After this for loop completes, the allLikelyKeyLengths variable contains all the factor 
integers that were in f actorsByCount. This list is returned from 

kasiskiExamination () . 



vigenereHacker.py 

137. def getNthSubkeysLetters(n, keyLength, message): 



138. 


# 


Returns every Nth letter for each keyLength 


set of letters in text 


139. 


# 


E.g. getNthSubkeysLettersCl, 3, ' ABCABCABC ' ) 


returns 'AAA' 


140. 


# 


getNthSubkeysLetters(2, 3, 'ABCABCABC') 


returns ' BBB' 


141. 


# 


getNthSubkeysLetters(3, 3, 'ABCABCABC') 


returns 'CCC 


142. 


# 


getNthSubkeysLettersCl, 5, ' ABCDEFGHI ' ) 


returns 'AF' 


143. 








144. 


# 


Use a regular expression to remove non-letters from the message. 


145. 


message = NONLETTERS_PATTERN . sub( ' ' , message) 





In order to pull out the letters from a ciphertext that were encrypted with the same subkey, we 
need a function that can create a string for the 1 st , 2 nd , or "N th " subkey' s letters from a message. 
The first part of getting these letters is to remove the non-letter characters from message using a 
regular expression object and its sub ( ) method on line 145. (Regular expressions were first 
discussed in Chapter 18's "A Brief Intro to Regular Expressions and the sub() Regex Method".) 
This letters-only string is stored as the new value in message. 







vigenereHacker.py 


147. 


i = n - 1 




148. 


letters = [] 




149. 


while i &lt; len(message) : 




150. 


1 etters . append (message [i ] ) 




151. 


i += keyLength 




152. 


return ' ' . join(letters) 





Next we will build up a string by appending the letter strings to a list and using the j oin ( ) list 
method to create the final string value. This approach executes much faster than string 
concatenation with the + operator. (This approach was first discussed in Chapter 18's "Building 
Strings in Python with Lists" section.) 



The i variable will point to the index of the letter in message that we want to append to our 
string-building list. This list is stored in a variable named letters. The i variable starts with 
the value n - 1 on line 147 and the letters variable starts with a blank list on line 148. 

The while loop on line 149 keeps looping while i is less than the length of message. On each 
iteration the letter at mes sage [ i ] is appended to the list in letters. Then i is updated to 
point to the next of the subkey's letters by adding keyLength to i on line 151. 

Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 345 



After this loop finishes, the code on line 152 joins the single-letter string values in the letters 
list together to form a single string, and this string is returned from 

getNthSubkeysLetters () . 







vigenereHacker. py 


155. 


def attemptHackWi thKeyLength (ci phertext 


mostLi kelyKeyLength) : 


156. 


# Determine the most likely letters 


for each letter in the key. 


157. 


ciphertextUp = ci phertext . upper () 





Recall that our kasi skiExamination ( ) function isn't guaranteed to return the one true 
integer length of the Vigenere key, but rather the function returns a list of several lengths sorted 
in order of most likely to be the key length. If our code has guessed the wrong key length, then it 
will have to try again with a different key length. The attemptHackWithKeyLength ( ) 
function is passed the ciphertext and the key length guess. If successful, this function returns a 
string of the hacked message. If the hacking fails, the function returns None. 

The hacking code works on uppercase letters but the original string will also be needed, so the 
uppercase form of the ciphertext string will be stored in a separate variable named 

ciphertextUp. 



vigenereHacker.py 

158. # allFreqScores is a list of mostLi kelyKeyLength number of lists. 

159. # These inner lists are the freqScores lists. 

160. allFreqScores = [] 

161. for nth in range(l, mostLi kelyKeyLength + 1): 

162. nthLetters = getNthSubkeysLetters(nth , mostLi kelyKeyLength, 
ciphertextUp) 

If we assume the value in the mostLikelyKeyLength is the correct key length, the hack 
algorithm calls getNthSubkeysLetters ( ) for each subkey and then brute-forces through 
the 26 possible letters for each subkey to find the one that produces decrypted text whose letter 
frequency closest matches the letter frequency of English. 

First, an empty list is stored in allFreqScores on line 160. What this list stores will be 
explained a little later. 

The for loop on line 161 sets the nth variable to each integer from 1 to the 
mostLikelyKeyLength value. (Remember, that when range ( ) is passed two arguments, 
the range goes up to, but not including, the second argument. The + 1 is put into the code so that 
the integer value in mostLikelyKeyLength itself is included in the range object returned.) 



346 http://inventwithpython.com/hacking 

The letters of the Nth subkey are returned from getNthSubkeysLetters ( ) on line 162. 



vigenereHacker.py 

164. # freqScores is a list of tuples like: 

165. # [(&lt;letter&gt;, &lt;Eng. Freq. match score&gt;) , ... ] 

166. # List is sorted by match score. Higher score means better match. 

167. # See the engl i shFreqMatchScoreO comments in f reqAnalysi s . py. 

168. freqScores = [] 

169. for possibleKey in LETTERS: 

170. decryptedText = vigenereCipher.decryptMessage(possibleKey, 
nthLetters) 

171. keyAndFreqMatchTuple = (possibleKey, 
f reqAnalysi s . engl i shFreqMatchSco re (decryptedText)) 

172 . freqScores .append (keyAndFreqMatchTuple) 



Next, a list of English frequency match scores is stored in a list in a variable named 
freqScores. This variable starts as an empty list on line 168 and then the for loop on line 
169 loops through each of the 26 uppercase letter from the LETTERS string. The possibleKey 
value is used to decrypt the ciphertext by calling vigenereCipher . decryptMessage ( ) 
on line 170. The subkey in possibleKey is only one letter, but the string in nthLetters is 
made up of only the letters from message that would have been encrypted with that subkey if 
we've guessed the key length correctly. 

The decrypted text is then passed to f reqAnalysis . englishFreqMatchScore ( ) to see 
how closely the frequency of the letters in decryptedText matches the letter frequency of 
regular English. (Remember from the last chapter that the return value will be an integer between 
0 and 1 2 , with a higher number meaning a closer match.) 

This frequency match score, along with the key used to decrypt, are put into a tuple that is stored 
in a variable named keyAndFreqMatchTuple on line 171. This tuple is appended to the end 
of freqScores on line 172. 



vi genereHacker . py 

173. # Sort by match score 

174. freqScores . sort(key=getItemAtIndexOne , reverse=True) 

After the for loop on line 169 completes, the freqScores list will contain 26 key-and- 
frequency-match-score tuples: one tuple for each of the 26 subkeys. We need to sort this so that 
the tuples with the largest English frequency match scores are first in the list. 

This means that we want to sort by the value at index 1 of the tuples in freqScores and in 
reverse (that is, descending) order. We call the sort ( ) method on the freqScores list, 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 347 



passing the function value getltemAtlndexOne (not calling the function: note the lack of 
parentheses) for the key keyword argument. The value True is passed for the reverse 
keyword argument to sort in reverse (that is, descending) order. 



vigenereHacker. py 

176 . al 1 FreqScores . append(f reqScores [ : NUM_MOST_FREQ_LETTERS] ) 

The NUM_MOST_FREQ_LETTERS constant was set to the integer value 3 on line 9. Once the 
tuples in f reqScores are sorted, a list containing only the first 3 tuples (that is, the tuples with 
the three highest English frequency match scores) is appended toallFreqScores. 

After the for loop on line 161 completes, allFreqScores will contain a number of list 
values equal to the integer value in mostLikelyKeyLength. (For example, since 
mostLikelyKeyLength was 3, allFreqScores would be a list of three lists.) The first 
list value will hold the tuples for the top three highest matching subkeys for the first subkey of the 
full Vigenere key. The second list value will hold the tuples for the top three highest matching 
subkeys for the second subkey of the full Vigenere key, and so on. 

Originally, if we wanted to brute -force through the full Vigenere key, there would be (26 A key 
length) number of possible keys. For example, if the key was ROSEBUD (with a length of 7) 
there would be 26 A 7 (that is, 8,031,810,176) possible keys. 

But by checking the English frequency matching, we've narrowed it down to the 4 most likely 
letters for each subkey, meaning that there are now only (4 A key length) possible keys. Using the 
example of ROSEBUD (with a length of 7) for a Vigenere key, now we only need to check 4 A 7 
(that is, 16,384) possible keys. This is a huge improvement over 8 billion! 



The end Keyword Argument for print ( ) 





vigenereHacker. py 


178. 


-if not SILENT_M0DE : 


179. 


for i in range(l en(al 1 FreqScores)) : 


180. 


# use i + 1 so the first letter is not called the "0th" letter 


181. 


printC'Possible letters for letter %s of the key: ' % (i + 1) , 


end=") 




182. 


for freqScore in al 1 FreqScores [i ] : 


183. 


print('%s ' % freqScore [0] , end=") 


184. 


printO # print a newline 



348 http://inventwithpython.com/hacking 

At this point, the user might want to know which letters are in the top three most likely list for 
each subkey. If the SILENT_MODE constant was set to False, then the code on lines 178 to 184 
will print out the values in allFreqScores to the screen. 

Whenever the print ( ) function is called, it will print the string passed to it on the screen along 
with a newline character. If we want something else printed at the end of the string instead of a 
newline character, we can specify the string for the print ( ) function's end keyword argument. 
Try typing the following into the interactive shell: 



¬ª&gt; printC 'HEllo' 


end='\n') 


HE~No 




¬ª&gt; printC Hello' 


end='\n') 


Hello 




¬ª&gt; printC Hello' 


end=") 


Hello&gt;¬ª printC 'Hello' , end='XYZ') 


HelloXYZ&gt;¬ª 





(The above was typed into the python.exe interactive shell rather than IDLE. IDLE will always 
add a newline character before printing the &gt;¬ª prompt.) 



The itertools .product () Function 

The itertools. pro duct ( ) function produces every possible combination of items in a list 
or list-like value, such as a string or tuple. (Though the itertools. pro duct ( ) function 
returns a "itertools product" object value, this can be converted to a list by passing it to li st ( ) .) 
This combination of things is called a Cartesian product, which is where the function gets its 
name. Try typing the following into the interactive shell: 



¬ª&gt; import itertools 
















¬ª&gt; itertools. productC'ABC , repeat=4) 














&lt;itertools. product object at 0x02C40170&gt; 














¬ª&gt; listCitertools. productC'ABC 


, repeat=4)) 














[C'A', 'A', 'A', 'A'), C'A', 'A' 


, 'A', 'B'), 


C'A' 


, 'A' 


, 'A' 


, 'C'), 


C'A' 


'A' 


'B', 'A'), C'A', 'A', 'B\ 'B'), 


C'A', 'A', 


‚ñ†B' , 


'C'), 


C'A' 


, 'A', 


'C , 


'A') , 


C'A', 'A', 'C, 'B'), C'A', 'A', 


'C, 'C'), 


C'A', 


'B' , 


'A' , 


'A'), 


C'A', 


' B ' , 


'A', 'B'), C'A', 'B', 'A', 'C'), 


C'A', 'B', 


' B ' , 


'A') , 


C'A' 


, 'B', 


'B', 


'B'), 


. . .skipped for brevity. . . 
















C'C , 'B' , 'C , 'B'), C'C , 'B' , 


'C, 'C'), 


C'C, 


'C , 


'A' , 


'A'), 


C'C, 


'C, 


'A', 'B'), C'C, 'C, 'A', 'C'), 


C'C, 'C, 


' B' , 


'A') , 


C'C 


, 'C, 


'B' , 


'B'), 


C'C, 'C, 'B', 'C), C'C, 'C, 


'C, 'A'), 


C'C, 


'C , 


'C, 


'B'), 


C'C, 


'C, 


'C, 'C')] 

















Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 349 



As you can see, by passing ' ABC ' and the integer 4 for the repeat keyword argument, 
itertools . product ( ) returns an "itertools product" object that, when converted to a list, 
has tuples of four values with every possible combination of ' A ' , ' B ' , and ' C ' . (This results in 
a list with a total of 3 A 4 or 8 1 tuples in it.) 

Since range objects returned from range ( ) are also list-like, they can be passed to 
itertools . product ( ) as well. Try typing the following into the interactive shell: 



¬ª&gt; "import "itertools 

¬ª&gt; list("itertools.product(range(8) , repeat=5)) 

[(0, 0, 0, 0, 0), (0, 0, 0, 0, 1), (0, 0, 0, 0, 2), (0, 0, 0, 0, 3), (0, 0, 0, 
0, 4), CO, 0, 0, 0, 5), CO, 0, 0, 0, 6), CO, 0, 0, 0, 7), CO, 0, 0, 1, 0), CO, 
0, 0, 1, 1), CO, 0, 0, 1, 2), CO, 0, 0, 1, 3), CO, 0, 0, 1, 4), 

. . .skipped for brevity. . . 
C7, 7, 7, 6, 6), C7, 7, 7, 6, 7), C7, 7, 7, 7, 0), C7, 7, 7, 7, 1), C7, 7, 7, 
7, 2), C7, 7, 7, 7, 3), C7, 7, 7, 7, 4), C7, 7, 7, 7, 5), C7, 7, 7, 7, 6), C7, 
7, 7, 7, 7)] 

When the range object returned from range ( 8 ) is passed to itertools . product ( ) (along 
with 5 for the repeat keyword argument), the list that is generated has tuples of 5 values, and 
each value are from the integers 0 to 7. 

The itertools. pro duct() function is an easy way to generate a list with every possible 
combination of some group of values. This is how our hacking program will create integer 
indexes to test every possible combination of possible subkeys. 



vi genereHacker . py 

186. # Try every combination of the most likely letters for each position 

187. # in the key. 

188. for indexes in i tertool s . product C range CNUM_M0ST_FREQ_LETTERS) , 
repeat=mostLi kelyKeyLength) : 

The allFreqScores variable is a list of lists of tuples such that allFreqS cores [ i] will 
evaluate to a list of tuples of possible letters for a single subkey. That is, allFreqScores [ 0 ] 
has a list of tuples for the first subkey, allFreqScores [ 1 ] has a list of tuples for the second 
subkey, and so on. 

Also, since the NUM_MOST_FREQ_LETTERS constant is set to 4, 
itertools .product (range (NUM_MOST_FREQ_LETTERS ) , 

repeat=mostLikelyKeyLength) will cause the for loop to have a tuple of integers (from 
0 to 3) for the indexes variable. If 5 was passed for mostLikelyKeyLength, then the 
following values would be set to indexes for each iteration: 



350 http://inventwithpython.com/hacking 



Table 21-4. Value of indexes on each iteration. 





On thp 1 s * iteration "i n Hpyp c ic ¬´pt to* 

V.y 1 1 Lilt 1 lltl O.IHJ11, _L 1 2S.tr o IS SCI l\J, 

On the 2 nd iteration, indexes is set to: 
On the 3 iteration, indexes is set to: 
On the 4 th iteration, indexes is set to: 
On the 5 th iteration, indexes is set to: 

And so on. . . 


o o o o o 
o o o o o 
o o o o o 






vigenereHacker.py 


189. 


# Create a possible key from the 


letters "in al 1 FreqScores 


190. 


possibleKey = ' ' 




191. 


for i "in range (mostLi kelyKeyLength) : 


192. 


possibleKey += al 1 FreqScores [i ] [i ndexes [i ] ] [0] 



The full Vigenere key will be constructed from the subkeys in allFreqScores using the 
indexes supplied by indexes. The key starts off as a blank string on line 190, and the for loop 
on line 191 will iterate through the integers from 0 up to, but not including, 

most Li kelyKeyLength. 



As the i variable changes for each iteration of the for loop, the value at indexes [ i ] will be 
the index of the tuple we want to use in allFreqScores [ i ] . This is why 
allFreqScores [i] [indexes [i] ] evaluates to the correct tuple we want (and the subkey 
we want is at index 0 in that tuple). 





vigenereHacker.py 


194. 


if not SILENT_M0DE: 


195. 


printC Attempting with key: %s' % (possibleKey)) 


If SILENT MODE is False, the key created by the for loop on line 191 is printed to the 


screen. 






vigenereHacker . py 


197. 


decryptedText = vigenereCipher.decryptMessage(possibleKey, 


ciphertextUp) 




198. 




199. 


if detectEnglish.isEnglish (decryptedText) : 


200. 


# Set the hacked ciphertext to the original casing. 


201. 


origCase = [] 


202. 


for i in range(len(ciphertext)) : 


203. 


if ci phertext [i ]. i supper () : 


204. 


ori gCase . append (decryptedText [i ] . upper ()) 


205. 


else: 


206. 


ori gCase . append (decryptedText [i ] . 1 ower ()) 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 351 



207. decryptedText = ' ' . join(origCase) 

Now that we have a complete Vigenere key, lines 197 to 208 will decrypt the ciphertext and 
check if the decrypted text is readable English. If it is, then it is printed to the screen for the user 
to confirm it is English (since i sEngli sh ( ) might produce a false positive). 

But decryptedText is in all uppercase letters. The code on lines 201 to 207 builds a new 
string by appending the origCase list with an uppercase or lowercase form of the letters in 
decryptedText. The for loop on line 202 goes through each of the indexes in the 
ciphertext string (which, unlike ciphertextUp, has the original casing of the 
ciphertext). If ciphertext [i] is uppercase, then the uppercase form of 
decryptedText [ i ] is appended to origCase. Otherwise, the lowercase form of 
decryptedText [ i ] is appended. The list in origCase is then joined together on line 207 to 
become the new value of decryptedText. 

This table shows how the ciphertext and decryptedText values produce the strings that 
go into origCase: 

ciphertext Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi 
decryptedText ALAN MATHISON TURING WAS A BRITISH MATHEMATICIAN 
''. join (origCase) Alan Mathison Turing was a British mathematician 







vigenereHacker.py 


209. 


# Check with user to see if the key has been 


found . 


210. 


pri nt( ' Possi bl e encryption hack with key %s: 


% (possi bleKey)) 


211. 


print(decryptedText[:200]) # only show first 


200 characters 


212. 


pri nt() 




213. 


printC'Enter D for done, or just press Enter 


to continue 


hackl ng : ' ) 






214. 


response = input('&gt; ') 




215. 






216. 


if response. strip () .upperO . startswith( ' D' ) : 




217. 


return decryptedText 





The correctly-cased decrypted text is printed to the screen for the user to confirm it is English. If 
the user enters ' D ' then the function returns the decryptedText string. 







vigenereHacker.py 


219. 


# No English-looking decryption found, so return None. 




220. 


return None 





352 http://inventwithpython.com/hacking 



Otherwise, after the for loop on line 188 iterates through all of the possible indexes to use and 
none of the decryptions look like English, the hacking has failed and the None value is returned. 



vi genereHacker . py 

223. def hackVigenere(ciphertext) : 

224. # First, we need to do Kasiski Examination to figure out what the 

225. # length of the ci phertext 1 s encryption key is. 

226. all Li kelyKeyLengths = kasi ski Examinati on (ci phertext) 

Now we define the hackVigenere ( ) function, which calls all of the previous functions. 
We've already defined all the work it will do. Let's run through the steps it goes through to 
perform the hacking. The first step is to get the most likely lengths of the Vigenere key based on 
Kasiski Examination of ciphertext. 





vigenereHacker.py 


227. 


if not SILENT_MODE : 


228. 


keyLengthStr = ' ' 


229. 


for keyLength in al 1 Li kelyKeyLengths : 


230. 


keyLengthStr += '%s ' % (keyLength) 


231. 


print('Kasiski Examination results say the most likely key lengths 


are: 


' + keyLengthStr + '\n') 



The likely key lengths are printed to the screen if SILENT_MODE is False. 



The break Statement 

Similar to how the continue statement is used inside of a loop to continue back to the start of 
the loop, the break statement (which is just the break keyword by itself) is used inside of a 
loop to immediately exit the loop. When the program execution "breaks out of a loop", it 
immediately moves to the first line of code after the loop ends. 



vigenereHacker.py 

233. for keyLength in al 1 Li kel yKeyLengths : 

234. if not SILENT_MODE: 

235. printC Attempting hack with key length %s (%s possible 
keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) 

236. hackedMessage = attemptHackWi thKeyLength(ci phertext , keyLength) 

237. if hackedMessage != None: 

238. break 



For each possible key length, the code calls the attemptHackWithKeyLength ( ) function 
on line 236. If attemptHackWithKeyLength ( ) does not return None, then the hack was 
successful and the program execution should break out of the for loop on line 238. 

Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 353 



vigenereHacker.py 

240. # If none of the key lengths we found using Kasiski Examination 

241. # worked, start brute-forcing through key lengths. 

242. if hackedMessage == None: 

243. if not SILENT_M0DE: 

244. pri nt( 1 Unabl e to hack message with likely key length(s). 
Brute-forcing key length... 1 ) 

245. for keyLength in ranged, MAX_KEY_LENGTH + 1): 

246. # don't re-check key lengths already tried from Kasiski 

247. if keyLength not in allLikelyKeyLengths: 

248. if not SILENT_M0DE: 

249. printC'Attempting hack with key length %s (%s possible 
keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength)) 

250. hackedMessage = attemptHackWithKeyLength(ciphertext, 
keyLength) 

251. if hackedMessage != None: 

252. break 



If the hack had failed for all the possible key lengths that kasiskiExamination ( ) returned, 
hackedMessage will be set to None when the if statement on line 242 executes. In this case, 
all the other key lengths up to MAX_KEY_LENGTH are tried. If Kasiski Examination failed to 
calculate the correct key length, then we can just brute-force through the key lengths. 

Line 245 starts a for loop that will call attemptHackWithKeyLength ( ) for each value of 
keyLength (which ranges from 1 to MAX_KEY_LENGTH) as long as it was not in 
allLikelyKeyLengths. (This is because the key lengths in allLikelyKeyLengths 
have already been tried in the code on lines 233 to 238.) 





vigenereHacker.py 


253. return hackedMessage 




Finally, the value in hackedMessage is returned on line 253. 




vigenereHacker.py 


256. # If vigenereHacker.py is run (instead of imported 


as a module) call 


257. # the main() function. 




258. if name == ' main ': 




259. main() 





Lines 258 and 259 call the main ( ) function if this program was run by itself rather than 
imported by another program. 



354 http://inventwithpython.com/hacking 



That's the full Vigenere hacking program. Whether it is successful or not depends on the 
characteristics of the ciphertext. Also, the closer the original plaintext's letter frequency is to 
regular English's letter frequency and the longer the plaintext, the more likely our hacking 
program will work. 

Practice Exercises, Chapter 21, Set A 

Practice exercises can be found at http://inypy.co^ 

Modifying the Constants of the Hacking Program 

There are a few things we can modify if the hacking program doesn't work though. There are 
three constants we set on lines 8 to 10 that affect how our hacking program runs: 



vigenereHacker.py 

8. MAX_KEY_LENCTH = 16 # will not attempt keys longer than this 

If the Vigenere key was longer than the integer in MAX_KEY_LENGTH, there is no possible way 
the hacking program will find the correct key. However, if we have MAX_KEY_LENGTH set very 
high and the kasiskiExamination ( ) function mistakenly thinks that the key length could 
be a very large integer, the program could be spending hours (or days or months) attempting to 
hack the ciphertext with wrong key lengths. 

Trying to hack the wrong key length that is small is not that big of a problem: it will only take 
seconds or minutes to go through the likely keys of that length. If the hacking program fails to 
hack the ciphertext, try increasing this value and running the program again. 



vigenereHacker.py 

9. NUM_MOST_FREQ_LETTERS = 3 # attempts this many letters per subkey 

The NUM_MOST_FREQ_LETTERS limits the number of possible letters tried for each subkey. 
By increasing this value, the hacking program tries many more keys (which is needed if the 
f reqAnalysis . englishFreqMatchScore ( ) was inaccurate for the original plaintext 
message), but this will also cause the program to slow down. And setting 

NUM_MOST_FREQ_LETTERS to 2 6 will cause the program to not narrow down the number of 
possible letters for each subkey at all! 

Table 21-5. Tradeoffs for the MAX_KEY_LENGTH and NUM_MOST_FREQ_LETTERS. 

Smaller value: Larger value: 
Faster to execute. Slower to execute. 
Less likely to hack. More likely to hack. 



Email questions to the author: al@inventwithpython.com 



Chapter 21 - Hacking the Vigenere Cipher 355 



vi genereHacker . py 

10. SILENT_M0DE = False # if set to True, program doesn't print attempts 

While your computer can perform calculations very fast, displaying characters on the screen is 
relatively slow. If you want to speed up your program, you can set S I LENT_MODE to True so 
that the program does not waste time printing information to the screen. On the downside, you 
will not know how the program is doing until it has completely finished running. 

Summary 

Hacking the Vigenere cipher requires several detailed steps to follow. There are also many parts 
where our hacking program could fail: perhaps the Vigenere key used for encryption was larger 
in length than MAX_KEY_LENGTH, or perhaps the English frequency matching function got 
inaccurate results because the plaintext doesn't follow normal letter frequency, or maybe the 
plaintext has too many words that aren't in our dictionary file and isEnglish ( ) doesn't 
recognize it as English. 

If you identify different ways that the hacking program could fail, you could change the code to 
become ever more sophisticated to handle these other cases. But the hacking program in this book 
does a pretty good job at reducing billions or trillions of possible keys to brute-force through to 
mere thousands. 

However, there is one trick to make the Vigenere cipher mathematically impossible to break, no 
matter how powerful your computer or how clever your hacking program is. We'll learn about 
these "one-time pads" in the next chapter. 



356 http ://inventwithpy thon. com/hacking 




Chapter 22 



The One-Time Pad Cipher 



Topics Covered In This Chapter: 

‚Ä¢ The Unbreakable One -Time Pad Cipher 

‚Ä¢ The Two-Time Pad is the Vigenere Cipher 



"I've been over it a thousand times," Waterhouse 
says, "and the only explanation I can think of is 
that they are converting their messages into large 
binary numbers and then combining them with 
other large binary numbers ‚Äî one-time pads, most 
likely ‚Äî to produce the ciphertext." 

"In which case your project is doomed," Alan says, 
"because you can't break a one-time pad." 

"Cryptonomicon" by Neal Stephenson 



Email questions to the author: al@inventwithpython.com 



Chapter 22 - The One-Time Pad Cipher 357 



The Unbreakable One-Time Pad Cipher 

There is one cipher that is impossible to crack, no matter how powerful your computer is, how 
much time you have to crack it, or how clever of a hacker you are. We won't have to write a new 
program to use it either. Our Vigenere program can implement this cipher without any changes. 
But this cipher is so inconvenient to use on a regular basis that it is often only used for the most 
top-secret of messages. 

The one-time pad cipher is an unbreakable cipher. It is a Vigenere cipher where: 

1. The key is exactly as long as the message that is encrypted. 

2. The key is made up of truly random symbols. 

3. The key is used one time only, and never used again for any other message. 

By following these three rules, your encrypted message will be invulnerable to any cryptanalyst's 
attack. Even with literally an infinite amount of computing power, the cipher cannot be broken. 

The key for the one-time pad cipher is called a pad because they were printed on pads of paper. 
The top sheet of paper would be torn off the pad after it was used to reveal the next key to use. 

Why the One-Time Pad is Unbreakable 

To see why the one-time pad (OTP) cipher is unbreakable, let's think about why the regular 
Vigenere cipher is vulnerable to breaking. Our Vigenere cipher hacking program works by doing 
frequency analysis. But if the key is the same length as the message, then every possible 
ciphertext letter is equally probable to be for the same plaintext letter. 

Say that we want to encrypt the message, "If you want to survive out here, you've got to know 
where your towel is." If we remove the spaces and punctuation, this message has 55 letters. So to 
encrypt it with a one-time pad, we need a key that is also 55 letters long. Let's use the key 
"kcqyzhepxautiqekxejmoretzhztrwwqdylbttvejmedbsanybpxqik". Encrypting the string looks like 
this: 

Plaintext if youwanttosurviveouthereyouvegottoknowwhereyourtowelis 
Key kcqyzhepxautiqekxe jmoretzhztrwwqdylbttve jmedbsanybpxqik 
Ciphertext shomtdecqtilchzssixghyikdf nnmacewrzlghraqqvhzguerplbbqc 

Now imagine a cryptanalyst got a hold of the ciphertext ("shomtdec..."). How could she attack 
the cipher? Brute -forcing through the keys would not work, because there are too many even for a 
computer. The number of keys is 26 A (number of letters in the message), so if the message has 55 
letters, there would be a total of 26 A 55, or 666,091,878,431,395,624,153,823,182,526,730,590, 
376,250,379,52 8,249,805,353,030,484,209,594,192,101,376 possible keys. 



358 http://inventwithpython.com/hacking 



But it turns out that even if she had a computer that was powerful enough to try all the keys, it 
still would not break the one-time pad cipher. This is because for any ciphertext, all possible 
plaintext messages are equally likely. 

For example, given the ciphertext "shomtdec...", we could easily say the original plaintext was 
"The myth of Osiris was of importance in ancient Egyptian religion." encrypted with the key 
"zakavkxolfqdlzhwsqjbzmtwmmnakwurwexdcuywksgorghnnedvtcp": 

Plaintext themythof osiriswasof importanceinancientegyptianreligion 
Key zakavkxolf qdlzhwsqjbzmtwmmnakwurwexdcuywksgorghnnedvtcp 

Ciphertext shomtdecqtilchzssixghyikdf nnmacewrzlghraqqvhzguerplbbqc 

The way we are able to hack encryption is because there is usually only one key that can be used 
to decrypt the message to sensible English. But we've just shown that the same ciphertext could 
have been made from two very different plaintext messages. For the one-time pad, the 
cryptanalyst has no way of telling which was the original message. In fact, any readable English 
plaintext message that is exactly 55 letters long is just as likely to be the original plaintext. Just 
because a certain key can decrypt the ciphertext to readable English does not mean it was 
the original encryption key. 

Since any English plaintext could have been used to create a ciphertext with equal likelihood, it is 
completely impossible to hack a message encrypted with a one-time pad. 

Beware Pseudorandomness 

The random module that comes with Python does not generate truly random numbers. They are 
computed from an algorithm that creates numbers that only appear random (which is often good 
enough). If the pad is not generated from a truly random source, then it loses its mathematically- 
perfect secrecy. 

The os . urandom ( ) function can provide truly random numbers but is a bit more difficult to 
use. For more information about this function, see http://inypy..cpm/random. 

Beware the Two-Time Pad 

If you do use the same one-time pad key to encrypt two different messages, you have introduced 
a weakness into your encryption. Using the one-time pad cipher this way is sometimes called a 
"two-time pad cipher". It's a joke name though, the two-time pad cipher is really just using the 
one-time pad cipher incorrectly. 

Just because a key decrypts the one-time pad ciphertext to readable English does not mean it is 
the correct key. However, if you use the same key for two different messages, now the hacker can 



Email questions to the author: al@inventwithpython.com 



Chapter 22 - The One-Time Pad Cipher 359 



know that if a key decrypts the first ciphertext to readable English, but that same key decrypts the 
second message to random garbage text, it must not be the original key. In fact, it is highly likely 
that there is only one key that will decrypt both messages to English. 

If the hacker only had one of the two messages, then it is still perfectly encrypted. But, you must 
always assume that all of your encrypted messages are being intercepted by hackers and/or 
governments (otherwise, you wouldn't need to bother encrypting your messages.) Remember 
Shannon's Maxim: The enemy knows the system! This includes knowing the ciphertext. 

The Two-Time Pad is the Vigenere Cipher 

To see why the two-time pad is hackable just like the Vigenere Cipher, let's think about how the 
Vigenere cipher works when it encrypts a message that is longer than the key. Once we run out of 
characters in the key to encrypt with, we go back to the first character of the key and continue 
encrypting. So to encrypt a 20-character message like "AABBCCDDEEVVWWXXYYZZ" with 
a 10-character long key such as "PRECOCIOUS", the first ten characters (AABBCCDDEE) are 
encrypted with "PRECOCIOUS" and then the next ten characters (VVWWXXYYZZ) are also 
encrypted with "PRECOCIOUS". 

Plaintext AABBCCDDEEVVWWXXYYZZ 
Vigenere Key PRECOCIOUSPRECOCIOUS 
Vigenere Ciphertext PRFDQELRYWKMAYLZGMTR 

We have already learned how to break Vigenere ciphers. If we can show that a two-time pad 
cipher is the same thing as a Vigenere cipher, then we can prove that it is breakable using the 
same techniques used to break Vigenere cipher. 

Using the one-time pad cipher, let's say the 10-character message "AABBCCDDEE" was 
encrypted with the one-time pad key "PRECOCIOUS". Then the cryptographer makes the 
mistake of encrypting a second 10-character message "VVWWXXYYZZ" with the same one- 
time pad key, "PRECOCIOUS". 

Message 1 Message 2 
Plaintext AABBCCDDEE VVWWXXYYZZ 
One-Time Pad Key PRECOCIOUS PRECOCIOUS 
One-Time Pad Ciphertext PRFDQELRYW KMAYLZGMTR 

If we compare the ciphertext of the Vigenere cipher and the ciphertexts of the one-time pad 
cipher, we can see they are the exact same. The two-time pad cipher has the same properties as 
the Vigenere cipher, which means that the same techniques could be used to hack it! 

This also tells us that if we do the Vigenere cipher but use a key that is as long as the message it 
is encrypting (and only use this key once for this message), then it will be perfectly unbreakable. 



360 http://inventwithpython.com/hacking 



This is why we don't need to write a separate one-time pad cipher program. Our Vigenere cipher 
program already does it! 

Practice Exercises, Chapter 22, Set A 

Practice exercises can be found at ht^://inypxAQn^^J^^ra^ce22A. 

Summary 

In short, a one-time pad is just the Vigenere cipher with a key that is the same length as the 
message and is only used once. As long as these two conditions are followed, it is literally 
impossible to break the one-time pad. However, it is so inconvenient to use the one-time pad that 
it is not generally used except for the most top-secret of secrets. Usually a large list of one-time 
pad keys are generated and shared in person, with the keys marked for specific dates. This way, if 
you receive a message from your collaborator on October 31 st , you can just look through the list 
of one-time pads to find the one for that day. But be sure this list doesn't fall into the wrong 
hands ! 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 361 



Chapter 23 



Finding Prime Numbers 



Topics Covered In This Chapter: 

‚Ä¢ Prime and Composite Numbers 

‚Ä¢ The Sieve of Eratosthenes 

‚Ä¢ The Rabin-Miller Primality Test 



"Mathematicians have tried in vain to this day to 
discover some order in the sequence of prime 
numbers, and we have reason to believe that it is a 
mystery into which the human mind will never 
penetrate." 

Leonhard Euler, 18 th century mathematician 

All of the ciphers described in this book so far have been around for hundreds of years, and all of 
them (with the exception of the one-time pad) are easily broken by computers. These ciphers 
worked very well when hackers had to rely on pencil and paper to hack them, but computers can 
now manipulate data trillions of times faster than a person with a pencil. 

The RSA cipher has several improvements over these old ciphers, and it will be detailed in the 
next chapter. However, the RSA cipher will require us to learn about prime numbers first. 




362 http://inventwithpython.com/hacking 



Prime Numbers 

A prime number is an integer (that is, a whole number) that is greater than 1 and has only two 
factors: 1 and itself. Remember that the factors of a number are the numbers that can be 
multiplied to equal the original number. The numbers 3 and 7 are factors of 21. The number 12 
has factors 2 and 6, but also 3 and 4. 

Every number has factors of 1 and itself. The numbers 1 and 21 are factors of 21. The numbers 1 
and 12 are factors of 12. This is because 1 times any number will always be that same number. 
But if no other factors exist for that number, then that number is prime. 

Here's a list of prime numbers (note that 1 is not considered a prime number): 

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 
107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 
211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281 ...and so on, FOREVER. 

There are an infinite number of prime numbers. This means there is no "largest" prime. They just 
keep getting bigger and bigger, just like regular numbers do. (See http://mypy.TO 
for a proof of this.) The RSA cipher makes use of very large prime numbers in the keys it uses. 
Because of this, there will be far too many keys to brute -force through. 

A googol is the number that has a one with a hundred zeros behind it: 

10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00 
0,000,000,000,000,000,000,000,000,000,000,000 

(As a bit of history: the name of the search engine company Google came from misspelling 
"googol", but they decided they liked that spelling better and kept it.) 

A billion billion billion googols has twenty-seven more zeros than a googol: 

10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00 
0,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000 

But these are tiny numbers. A typical prime number used in our RSA program will have hundreds 
of digits: 

112,829,754,900,439,506,175,719,191,782,841,802,172,556,768,253,593,054,977,186,2355,84,9 
79,780,304,652,423,405,148,425,447,063,090,165,759,070,742,102,132,335,103,295,947,000,71 
8,386,333,756,395,799,633,478,227,612,244,071,875,721,006,813,307,628,061,280,861,610,153, 
485,352,017,238,548,269,452,852,733,818,231,045,171,038,838,387,845,888,589,411,762,622,0 
41,204,120,706,150,518,465,720,862,068,595,814,264,819 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 363 



The above number is so big, I'm going to guess you didn't even read it to notice the typo in it. 

Composite Numbers 

Integers that are not prime numbers are called composite numbers, because they are composed 
of at least two factors besides 1 and the number itself. They are called composite numbers 
because these number are composed of prime numbers multiplied together, such as the composite 
number 1,386 being composed of the prime numbers in 2x3x3x7x11. 

Here are four facts about prime numbers: 

1. Prime numbers are integers greater than lthat have only 1 and themselves as factors. 

2. Two is the only even prime number. (Though I guess that makes two a very odd 
prime number.) 

3. There are an infinite number of prime numbers. There is no "largest prime number". 

4. Multiplying two prime numbers will give a number that only has two pairs of 
factors, 1 and itself (like all numbers do), and the two prime numbers that were 
multiplied. For example, 3 and 7 are prime numbers. 3 times 7 is 21. The only 
factors for 21 are 1, 21, 3, and 7. 

Source Code for The Prime Sieve Module 

First we will create a module that has functions related to prime numbers: 

‚Ä¢ i s Prime ( ) will return either True or False if the number passed to it is prime or not. It will 
use the "divides test" algorithm. 

‚Ä¢ primeSieve ( ) will use the "Sieve of Eratosthenes" algorithm (explained later) to generate 
numbers. 

Like cryptomath.py, the primeSieve. py program is only meant to be imported as a module to our 
other programs. It does not do anything when run on its own. 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as primeSieve. py. 



Source code for primeSieve. py 

1. # Prime Number Sieve 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import math 

5. 

6. 

7. def isPrime(num) : 



364 http://inventwithpython.com/hacking 



8. # Returns True if num is a prime number, otherwise False. 
9. 

10. # Note: Generally, isPrimeO is slower than primeSi eve() . 
11. 

12. # all numbers less than 2 are not prime 

13 . if num &lt; 2 : 

14. return False 
15. 

16. # see if num is divisible by any number up to the square root of num 

17. for i in range(2, i nt(math . sqrt(num)) + 1): 

18. if num % i == 0: 

19. return False 

20. return True 
21. 

22. 

23. def primeSieve(sieveSize) : 

24. # Returns a list of prime numbers calculated using 

25. # the Sieve of Eratosthenes algorithm. 
26. 

27. sieve = [True] * sieveSize 

28. sieve[0] = False # zero and one are not prime numbers 

29. si eve [1] = False 
30. 

31. # create the sieve 

32. for i in range(2, int(math.sqrt(sieveSize)) + 1): 

33. pointer = i * 2 

34. while pointer &lt; sieveSize: 

35. sieve[pointer] = False 

36. pointer += i 
37. 

38. # compile the list of primes 

39. primes = [] 

40. for i in range (si eveSi ze) : 

41. if sieve[i] == True: 

42. primes. append(i) 
43. 

44. return primes 



How the Program Works 



primeSieve.py 

1. # Prime Number Sieve 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import math 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 365 
The only module primeSieve.py needs is the math module. 



How to Calculate if a Number is Prime 







primeSieve.py 


7. 


def isPrime(num) : 




8. 
9. 


# Returns True if num is a prime number, otherwise False. 




10. 


# Note: Generally, isPrimeO is slower than primeSi eve() . 




11. 






12. 


# all numbers less than 2 are not prime 




13. 


i f num &lt; 2 : 




14. 


return False 





We will program the isPrime ( ) function to return False if the num parameter is a composite 
number and True if the num parameter is a prime number. If num is less than 2 we know it is 
not prime and can simply return Fal se. 









primeSieve.py 


16. 


# see if num is divisible by any number 


up to the square 


root of num 


17. 


for i in range (2, i nt (math . sqrt (num)) + 


1): 




18. 


if num % i ==0: 






19. 


return False 






20. 


return True 







A prime number has no factors besides 1 and itself. So to find out if a given number is prime or 
not, we just have to keep dividing it by integers and see if any of them evenly divide the number 
with 0 remainder. 



The math . sqrt ( ) function will return a float value of the square root of the number it is 
passed. The square root of a number can be multiplied by itself to get the number. For example, 
the square root of 49 is 7, because 7 x 7 is 49. 

For example, to find out if 49 is prime, divide it by the integers starting with 2: 



49^ 


2 = 


24 remainder 1 


49^ 


3 = 


16 remainder 1 


49^ 


4 = 


12 remainder 1 


49, 


-5 = 


9 remainder 4 


49^ 


-6 = 


8 remainder 1 



366 http://inventwithpython.com/hacking 



49 -r 7 = 7 remainder 0 



Actually, you only need to divide the number by prime numbers. For example, there's no reason 
to see if 6 divides 49, because if it did then 2 would have divided 49 since 2 is a factor of 6. Any 
number that 6 divides evenly can also be divided by 2 evenly: 

If 2 divides 6 evenly... 




I 

...then any number that 
6 divides, 2 divides also. 

^: ! :i:f 

r‚Äî . ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî (where x is any 
l=* ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî ‚ñ† ‚Äî 'J amount of length) 

Figure 23-1. 2 divides 6, and 6 divides X, therefore 2 divides X. 

Because there's an integer (that is not 1 or 49) that evenly divides 49 (that is, has a remainder of 
0), we know that 49 is not a prime number. For another example, let's try 13: 

13-^2 = 6 remainder 1 

13 -r 3 = 4 remainder 1 

13 -f 4 = 3 remainder 1 

No integer divides 13 with a remainder of 0 (except for 1 and 13, which don't count). Actually, 
we don't even have to divide all the numbers up to 13. We only have to test the integers up to 
(and including) the square root of the number we are testing for primality. The square root of a 
number is the number that is multiplied by itself to get that first number. The square root of 25 is 
5, because 5 X 5 = 25. The square root of 13 is about 3.6055512754639, because 
3.6055512754639 x 3.6055512754639 = 13. This means that when we were testing 13 for 
primality, we only had to divide 2 and 3 because 4 is larger than the square root of 13. 
Line 18 checks if the remainder of division is 0 by using the % mod operator. If line 17's for 
loop never returns Fal se, the function will return True on line 20. 

The Sieve of Eratosthenes 

The sieve of Eratosthenes (pronounced "era, taws, thuh, knees") is an algorithm for calculating 
prime numbers. Imagine a bunch of boxes for each integer, all marked "prime": 




Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 367 
Table 23-1. A blank sieve of Eratosthenes, with each number marked as "prime". 



Prime 
1 


Prime 
2 


Prime 

3 


Prime 
4 


Prime 
5 


Prime 
6 


Prime 
7 


Prime 
8 


Prime 
9 


Prime 
10 


Prime 
11 


Prime 
12 


Prime 
13 


Prime 
14 


Prime 
15 


Prime 
16 


Prime 
17 


Prime 
18 


Prime 
19 


Prime 
20 


Prime 
21 


Prime 
22 


Prime 

23 


Prime 
24 


Prime 
25 


Prime 
26 


Prime 
27 


Prime 
28 


Prime 
29 


Prime 
30 


Prime 
31 


Prime 

32 


Prime 

33 


Prime 
34 


Prime 
35 


Prime 
36 


Prime 

37 


Prime 

38 


Prime 
39 


Prime 
40 


Prime 
41 


Prime 
42 


Prime 
43 


Prime 
44 


Prime 
45 


Prime 
46 


Prime 
47 


Prime 
48 


Prime 
49 


Prime 
50 



Mark 1 as "Not Prime" (since one is never prime). Then mark all the multiples of two (except for 
two itself) as "Not Prime". This means we will mark the integers 4 (2 x 2), 6 (2 x 3), 8 (2 x 4), 
10, 12, and so on up to 50 (the largest number we have) are all marked as "Not Prime": 

Table 23-2. The sieve with one and the multiples of 2 (except 2 itself) marked as "not prime". 



Prime 


Prime 
2 


Prime 

3 




Not 




Prime 


Prime 


Prime 


11 


12 


13 




Not 




Prime 


Prime 


Prime 


21 


22 


23 




Not 




Prime 


Prime 


Prime 


31 


32 


33 




Not 




Prime 


Prime 


Prime 


41 


42 


43 



Prime Prime Prime 
4 



Not 

14 
Not 



34 
Not 
Prime 
44 



Prime 


Prime 


Prime 


5 


6 


7 




Not 




Prime 


Prime 


Prime 


15 


16 


17 




Not 




Prime 


Prime 


Prime 


25 


26 


27 




Not 




Prime 


Prime 


Prime 


35 


36 


37 




Not 




Prime 


Prime 


Prime 


45 


46 


47 



Prime Prime Prime Prime 

10 
Not 



Pr 

r 

j 
Pr: 

} 



Prime 

18 19 
Not 

rime Prime 

28 29 
Not 

rime Prime 



38 
Not 



39 



Prime Prime Prime Prime 



48 



49 



50 



Then repeat this with all the multiples of three, except for three itself: 6, 9, 12, 15, 18, 21, and so 
on are all marked "Not Prime". Then do this for all of the multiples of four (except for four 
itself), and all of the multiples of five (except for five itself), up until eight. We stop at 8 because 



368 http://inventwithpython.com/hacking 



it is larger than 7.071, the square root of 50). We can do this because all the multiples of 9, 10, 
11, and so on will already have been marked. 

The completed sieve looks like this: 

Table 23-3. A completed sieve of Eratosthenes. 





Not 





Not 


Prime 


Prime 


37 


38 




Not 


Prime 


Prime 


47 





Prime Prime 
18 19 
Not 

Prime 
29 
Not 
Prime 
39 
Not 
Prime 
49 



Not 
Prim 
10 

Not 
Prime 



Not 
Prime 
30 
Not 
Prime 
40 
Not 
Prime 
_^0_ 



By using the sieve of Erastothenes, we've calculated that the prime numbers under 50 are 2, 3, 5, 
7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, and 47. This sieve algorithm is good when we want to 
quickly find out all the prime numbers in a certain range of numbers. It is much faster than using 
the previous "divides test" algorithm to test if 2 is prime, then test if 3 is prime, then test if 4 is 
prime, and so on. 



The primeSieve ( ) Function 



23. 


def primeSieve(sieveSize) : 


24. 


# Returns a list of prime numbers calculated using 


25. 


# the Sieve of Eratosthenes algorithm. 


26. 




27. 


sieve = [True] * sieveSize 


28. 


sieve[0] = False # zero and one are not prime numbers 


29. 


si eve [1] = False 



The primeSieve ( ) function returns a list of all prime numbers between 1 and sieveSize. 
First, line 27 creates a list of Boolean True values that is the length of sieveSize. The 0 and 
1 indexes are marked as False because 0 and 1 are not prime numbers. 



Email questions to the author: al@inventwithpython.com 





Chapter 23 - 


Finding Prime Numbers 369 


31. 


# create the sieve 




32. 


for i in range(2, i nt(math . sqrt(si eveSi ze)) + 


1): 


33. 


pointer = i * 2 




34. 


while pointer &lt; sieveSize: 




35. 


si eve [pointer] = False 




36. 


pointer += i 





The for loop on line 32 goes through each integer from 2 up to the square root of sieveSize. 
The variable pointer will start at the first multiple of i after i (which will be i * 2). Then 
the while loop will set the pointer index in the sieve list to False, and line 36 will 
change pointer to point to the next multiple of i. 



38. 


# compile the list of primes 


39. 


primes = [] 


40. 


for i in range(si eveSi ze) : 


41. 


if si eve [i] == True: 


42. 


primes. append(i) 



After the for loop on line 32 completes, the sieve list will contain True for each index that is 
a prime number. We can create a new list (which starts as an empty list in primes) and loop over 
the entire sieve list, and appends and numbers if sieve [ i ] is True (meaning i is prime). 



44. return primes 

The list of prime numbers is returned on line 44. 

Detecting Prime Numbers 

The is Prime ( ) function in primeSieve.py checks if the number can be divided evenly by a 
range of numbers from 2 to the square root of the number. But what about a number like 
1,070,595,206,942,983? If you pass this integer to isPrime ( ) , it takes several seconds to 
determine if it is prime or not. And if the number is hundreds of digits long (like the prime 
numbers in next chapter's RSA cipher program are), it would take over a trillion years to figure 
out if that one number is prime or not. 

The is Prime ( ) function in primeSieve.py is too slow for the large numbers we will use in the 
RSA cipher. Fortunately there is an algorithm called the Rabin-Miller Primality Test than can 
calculate if such large numbers are prime or not. We will create a new i s Prime ( ) function in 
rabinMiller.py that makes use of this better algorithm. 



370 http://inventwithpython.com/hacking 



The code for this algorithm uses advanced mathematics, and how the algorithm works is beyond 
the scope of this book. Like the gcd ( ) function in cryptomath.py, this book will just present the 
code for the algorithm for you to use without explanation. 

Source Code for the Rabin-Miller Module 

Open a new file editor window and type in the following code. Save this file as rabinMiller.py . 
This program will be a module that is meant to be imported by other programs. 

Instead of typing out the list of numbers on line 43, just temporarily add the lines import 
pyperclip and pyperclip . copy (primeSieve (1000) ) in the primeSieve.py file and 
run it. This will copy the list of primes to the clipboard, and then you can paste it into the 
rabinMiller.py file. 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as rabinMiller.py. 



Source code for rabinMiller.py 

1. # Primality Testing with the Rabin-Miller Algorithm 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import random 

5. 

6. 

7. def rabi nMi 1 1 er(num) : 



8. # Returns True if num is a prime number. 
9. 

10. s = num - 1 

11. t = 0 

12. while s % 2 == 0: 

13. # keep halving s while it is even (and use t 

14. # to count how many times we halve s) 

15. s = s // 2 

16. t += 1 
17. 

18. for trials in range(5): # try to falsify num's primality 5 times 

19. a = random. randrange(2 , num - 1) 

20. v = pow(a, s, num) 

21. if v != 1: # this test does not apply if v is 1. 

22. i = 0 

23. while v != (num - 1): 

24. if i == t - 1: 

25. return False 

26. else: 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 37 1 



27. i=i+l 

28. v = (v ** 2) % num 

29. return True 
30. 

31. 

32. def isPrime(num) : 

33. # Return True "if num is a prime number. This function does a quicker 

34. # prime number check before calling rabinMillerO . 
35. 

36 . if (num &lt; 2) : 

37. return False # 0, 1, and negative numbers are not prime 
38. 

39. # About 1/3 of the time we can quickly determine if num is not prime 

40. # by dividing by the first few dozen prime numbers. This is quicker 

41. # than rabinMillerO, but unlike rabinMillerO is not guaranteed to 

42. # prove that a number is prime. 

lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 

53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 



139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 

229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 

317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 

421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 

521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 

619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 

733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 

839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 

953, 967, 971, 977, 983, 991, 997] 



44. 

45. if num in lowPrimes: 

46. return True 
47. 

48. # See if any of the low prime numbers can divide num 

49. for prime in lowPrimes: 

50. if (num % prime == 0): 

51. return False 
52. 

53. # If all else fails, call rabinMillerO to determine if num is a prime. 

54. return rabinMiller(num) 
55. 

56. 

57. def generateLargePrime(keysi ze=1024) : 

58. # Return a random prime number of keysize bits in size. 

59. while True: 

60. num = random. randrange(2**(keysi ze-1) , 2** (keysize)) 

61. if isPrime(num) : 

62. return num 



372 http://inventwithpython.com/hacking 



Sample Run of the Rabin Miller Module 

If you run the interactive shell, you can import the rabinMiller.py module and call the functions 
in it. Try typing the following into the interactive shell: 



¬ª&gt; import rabi nMi 11 er 

¬ª&gt; rabi nMi 1 1 er . generateLargePri me() 

1228811683422110410305236835154432390074842906007015553694882717483780547440094 

6375131251147129101194573241337844666680914050203700367321105215349360768161999 

0563076859566835016382556518967124921538212397036345815983641146000671635019637 

218348455544435908428400192565849620509600312468757953899553441648428119 

¬ª&gt; rabinMiller.isPrime(45943208739848451) 

False 

¬ª&gt; rabinMiller.isPrime(13) 
True 

&gt;¬ª 



How the Program Works 







rabinMiller.py 


1. 


# Primality Testing with the Rabin-Miller Algorithm 




2. 
3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 


import random 





The Rabin-Miller algorithm uses random numbers, so we import the random module on line 4. 



The Rabin-Miller Primality Algorithm 







rabinMiller.py 


7. 


def rabi nMi 1 1 er (num) : 




8. 
9. 


# Returns True if num is a prime number. 




10. 


s = num - 1 




11. 


t = 0 




12. 


while s % 2 == 0: 




13. 


# keep halving s while it is even (and use 


t 


14. 


# to count how many times we halve s) 




15. 


s = s // 2 




16. 


t += 1 




17. 






18. 


for trials in range(5): # try to falsify num's 


primality 5 times 


19. 


a = random. randrange(2 , num - 1) 




20. 


v = pow(a, s, num) 




21. 


if v != 1: # this test does not apply if v 


is 1. 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 373 



22. 


i = 0 




23. 


whi lev ! = (num - 1) : 




24. 


if i == t - 1: 




25. 


return False 




26. 


else: 




27. 


i = i + 1 




28. 


v = (v ** 2) ? 


&amp; num 


29. 


return True 





The mathematics of the Rabin-Miller Primality algorithm are beyond the scope of this book, so 
the code in this function will not be explained. 



The Rabin-Miller algorithm is also not a surefire test for primality; however, you can be 
extremely certain that it is accurate. (Although this is not good enough for commercial encryption 
software, it is good enough for the purposes of the programs in this book.) The main benefit of 
the Rabin-Miller algorithm is that it is a relatively simple primality test and only takes a few 
seconds to run on a normal computer. 

If rabinMiller ( ) returns True, then the num argument is extremely likely to be prime. If 
rabinMiller ( ) returns False, then num is definitely composite. 



The New and Improved isPrime () Function 







rabinMiller. py 


32. 


def isPrime(num) : 




33. 


# Return True if num is a prime number. This function 


does a quicker 


34. 


# prime number check before calling rabinMillerO . 




35. 






36. 


i f (num &lt; 2) : 




37. 


return False # 0, 1, and negative numbers are not 


prime 



All numbers that are less than two (such as one, zero, and negative numbers) are all not prime, so 
we can immediately return False. 



rabinMiller.py 

39. # About 1/3 of the time we can quickly determine if num is not prime 

40. # by dividing by the first few dozen prime numbers. This is quicker 

41. # than rabinMillerO, but unlike rabinMillerO is not guaranteed to 

42. # prove that a number is prime. 

lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 
53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 
139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 
229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 
317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 



374 http://inventwithpython.com/hacking 



421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 

521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 

619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 

733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 

839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 

953, 967, 971, 977, 983, 991, 997] 
44. 

45. if num in "lowPrimes : 

46. return True 



The numbers in the lowPrimes list are primes. (Duh.) We can immediately return True if num 
is in the lowPrimes list. 







rabinMiner.py 


48. 


# See if any of the low prime numbers can divide num 




49. 


for prime in lowPrimes: 




50. 


if (num % prime == 0): 




51. 


return False 





Line 49 loops through each of the prime numbers in the lowPrimes list. The integer in num is 
modded with the % mod operator by each prime number on line 50, and if this evaluates to 0 then 
we know that prime divides num and so num is not prime. In that case, line 51 returns False. 

Checking if num is divisible by all the primes under 1000 won't tell us if the number is prime, but 
it might tell us if the number is composite. About 30% of the random numbers that 
generateLargePrime ( ) creates that are composite will be detected as composite by 
dividing by the low prime numbers. Dividing by the low prime numbers is much faster than 
executing the full Rabin-Miller algorithm on the number, so this shortcut can make our program 
execute much more quickly. 



rabinMiller.py 

53. # If all else fails, call rabinMillerO to determine if num is a prime. 

54. return rabinMiller(num) 



Those are all the quick tests to determine if a number is prime or not. But if num does not match 
any of those tests, then it is passed to the rabinMiller ( ) function to check if it is prime or 
not. The return value of rabinMiller ( ) will be returned by isPrime ( ) . 

The comment on line 53 means call the rabinMiller ( ) function to determine if the number is 
prime. Please do not call Dr. Rabin or Dr. Miller personally to ask them if your number is prime. 



rabinMiller.py 



Email questions to the author: al@inventwithpython.com 



Chapter 23 - Finding Prime Numbers 375 



57. def generateLargePrime(keysi ze=1024) : 

58. # Return a random prime number of keysize bits in size. 

59. while True: 

60. num = random. randrange(2**(keysi ze-1) , 2** (keysize)) 

61. if isPrime(num) : 

62. return num 

The generateLargePrime ( ) function will return an integer that is prime. It does this by 
coming up with a large random number, storing it in num, and then passing num to i sPrime ( ) . 
The is Prime ( ) function will then test to see if num is composite and then pass the num to 
rabinMiller ( ) for a more thorough (and computationally expensive) primality test. 

If the number num is prime, then line 62 returns num. Otherwise the infinite loop goes back to 
line 60 to try a new random number. This loop keeps trying over and over again until it finds a 
number that the is Prime ( ) function says is prime. 

Summary 

Prime numbers have fascinating properties in mathematics. As you will learn in the next chapter, 
they are also the backbone of ciphers used in actual professional encryption software. The 
definition of a prime number is simple enough: a number that only has one and itself as factors. 
But determining which numbers are prime and which are composite (that is, not prime) takes 
some clever code. 

Modding a number with all the numbers from two up to the square root of the number is how our 
is Prime ( ) function determines if that number is prime or not. A prime number will never have 
a remainder of 0 when it is modded by any number (besides its factors, 1 and itself.) But this can 
take a while for the computer to calculate when testing large numbers for primality. 

The sieve of Erastothenes can be used to quickly tell if a range of numbers is prime or not, but 
this requires a lot of memory. 

The RSA cipher makes use of extremely large prime numbers that are hundreds of digits long. 
The Sieve of Erastothenes and the basic i sPrime ( ) function we have in primeSieve.py aren't 
sophisticated enough to handle numbers this large. 

The Rabin-Miller algorithm uses some mathematics which has simple code (but the mathematical 
reasoning behind it is too complex for this book), but it allows us to determine if a number that is 
hundreds of digits long is prime. 



376 http://inventwithpython.com/hacking 

In the next chapter, we will use the prime number code we developed for the rabinMiller.py 
module in our RSA Cipher program. At last, we will have a cipher easier to use than the one-time 
pad cipher but that cannot be hacked by the simple hacker techniques in this book! 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 377 



Warning to Time Travelers: 



Should you travel back to the early 1990's with this book, the contents of Chapter 24 would be 
illegal to possess in the United States. Strong crypto (that is, cryptography strong enough not to 
be hacked) was regulated at the same level as tanks, missiles, and flamethrowers and the export of 
encryption software would require State Department approval. They said that this was a matter of 
national security. 

Daniel J. Bernstein, a student at the University of California, Berkeley at the time, wanted to 
publish an academic paper and associated source code on his "Snuffle" encryption system. He 
was told by the U.S. government that he would first need to become a licensed arms dealer before 
he could post his source code on the Internet. They also told him that they would deny him an 
export license if he actually applied for one, because his technology was too secure. 

The Electronic Frontier Foundation, in its second major case as a young digital civil liberties 
organization, brought about the Bernstein v. United States court cases. The court ruled, for the 
first time ever, that written software code is speech protected by the First Amendment, and that 
the export control laws on encryption violated Bernstein's First Amendment rights by prohibiting 
his constitutionally protected speech. 

Today, strong crypto is used to safeguard businesses and e-commerce used by millions of Internet 
shoppers everyday. Cryptography is at the foundation of a large part of the global economy. But 
in the 1990's, spreading this knowledge freely (as this book does) would have landed you in 
prison for arms trafficking. 

A more detailed history of the legal battle for cryptography can be found in Steven Levy's book, 
Crypto: How the Code Rebels Beat the Government, Saving Privacy in the Digital Age. 



The fears and predictions made by the "experts" of the intelligence community that encryption 
software would become a grave national security threat turned out to be. . . less than well-founded. 



378 http://inventwithpython.com/hacking 




Chapter 24 



Public Key Cryptography 
and the RSA Cipher 

Topics Covered In This Chapter: 

‚Ä¢ Public key cryptography 

‚Ä¢ Man-in-the-middle attacks 

‚Ä¢ ASCII 

‚Ä¢ The chr ( ) and ord ( ) functions 

‚Ä¢ The bytes data type and bytes ( ) function 

‚Ä¢ The encode () string and decode ( ) bytes method 

‚Ä¢ The min ( ) and max ( ) functions 

‚Ä¢ The insert () list method 

‚Ä¢ The pow ( ) function 



"Why shouldn't I work for the NSA? That's a tough one, but I'll take a 
shot. Say I'm working at the NSA and somebody puts a code on my desk, 
something no one else can break. Maybe I take a shot at it, and maybe I 
break it. I'm real happy with myself, 'cause I did my job well. But maybe 
that code was the location of some rebel army in North Africa or the 
Middle East and once they have that location they bomb the village where 
the rebels are hiding. Fifteen hundred people that I never met, never had 
no problem with, get killed. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 379 



Now the politicians are saying 'Oh, send in the Marines to secure the 
area,' 'cause they don't give a shit. It won't be their kid over there getting 
shot just like it wasn't them when their number got called 'cause they 
were pulling a tour in the National Guard. It'll be some kid from Southie 
over there taking shrapnel in the ass. He comes back to find that the plant 
he used to work at got exported to the country he just got back from, and 
the guy that put the shrapnel in his ass got his old job, 'cause he'll work 
for fifteen cents a day and no bathroom breaks. 

Meanwhile he realizes that the only reason he was over there in the first 
place was so we could install a government that would sell us oil at a good 
price. And of course the oil companies use the little skirmish to scare up 
domestic oil prices, a cute little ancillary benefit for them, but it ain't 
helping my buddy at two-fifty a gallon. They're taking their sweet time 
bringing the oil back, of course, and maybe they took the liberty of hiring 
an alcoholic skipper who likes to drink martinis and fucking play slalom 
with the icebergs. It ain't too long until he hits one, spills the oil, and kills 
all the sea life in the North Atlantic. 

So now my buddy's out of work, he can't afford to drive, so he's walking 
to the fucking job interviews which sucks because the shrapnel in his ass 
is giving him chronic hemorrhoids. And meanwhile he's starving 'cause 
any time he tries to get a bite to eat the only Blue Plate Special they're 
serving is North Atlantic Scrod with Quaker State. 

So what did I think? I'm holding out for something better." 

"Good Will Hunting" 

Public Key Cryptography 

All of the ciphers in this book so far have one thing in common: the key used for encryption is the 
same key used for decryption. This leads to a tricky problem: How do you share encrypted 
messages with someone you've never talked to before? 



380 http://inventwithpython.com/hacking 



Say someone on the other side of the world wants to communicate with you. But you both know 
that spy agencies are monitoring all emails, letters, texts, and calls that you send. You could send 
them encrypted messages, however you would both have to agree on a secret key to use. But if 
one of you emailed the other a secret key to use, then the spy agency would be able to see this key 
and then decrypt any future messages you send with that key. Normally you would both secretly 
meet in person and exchange the key then. But you can't do this if the person is on the other side 
of the world. You could try encrypting the key before you send it, but then you would have to 
send the secret key for that message to the other person and it would also be intercepted. 

This is a problem solved by public key cryptography. Public key cryptography ciphers have 
two keys, one used for encryption and one used for decryption. A cipher that uses different keys 
for encryption and decryption is called an asymmetric cipher, while the ciphers that use the 
same key for encryption and decryption (like all the previous ciphers in this book) are called 
symmetric ciphers. 

The important thing to know is that a message encrypted with one key can only be decrypted 

with the other key. So even if someone got their hands on the encryption key, they would not be 
able to read an encrypted message because the encryption key can only encrypt; it cannot be used 
to decrypt messages that it encrypted. 

So when we have these two keys, we call one the public key and one the private key. The public 
key is shared with the entire world. However, the private key must be kept secret. 

If Alice wants to send Bob a message, Alice finds Bob's public key (or Bob can give it to her). 
Then Alice encrypts her message to Bob with Bob's public key. Since the public key cannot 
decrypt a message that was encrypted with it, it doesn't matter that everyone else has Bob's 
public key. 

When Bob receives the encrypted message, he uses his private key to decrypt it. If Bob wants to 
reply to Alice, he finds her public key and encrypts his reply with it. Since only Alice knows her 
own private key, Alice will be the only person who can decrypt the encrypted message. 

Remember that when sending encrypted messages using a public key cipher: 

‚Ä¢ The public key is used for encrypting. 

‚Ä¢ The private key is used for decrypting. 

To go back to the example of communicating with someone across the world, now it doesn't 
matter if you send them your public key. Even if the spy agency has your public key, they cannot 
read messages that were encrypted with the public key. Only your private key can decrypt those 
messages, and you keep that key a secret. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 381 



The particular public key cipher that we will implement is called the RSA cipher, which was 
invented in 1977 and named after its inventors: Ron Rivest, Adi Shamir and Leonard Adleman. 

The Dangers of "Textbook" RSA 

While we don't write a hacking program for the RSA cipher program in this book, don't make the 
mistake of thinking the rsaCipher.py program featured in this chapter is secure. Getting 
cryptography right is very hard and requires a lot of experience to know if a cipher (and a 
program that implements it) is truly secure. 

The RSA program in this chapter is known as textbook RSA because, while it does implement 
the RSA algorithm correctly using large prime numbers, there are several subtle faults with it that 
can lead to its encrypted messages being hacked. The difference between pseudorandom and truly 
random number generation functions is one such fault. But there are many others. 

So while you might not be able to hack the ciphertext created by rsaCipher.py, don't think that no 
one else can. The highly accomplished cryptographer Bruce Schneier once said, "Anyone, from 
the most clueless amateur to the best cryptographer, can create an algorithm that he himself can't 
break. It's not even hard. What is hard is creating an algorithm that no one else can break, even 
after years of analysis. And the only way to prove that is to subject the algorithm to years of 
analysis by the best cryptographers around." 

The program in this book is a fun example, but stick to professional encryption software to secure 
your files. You can find a list of (usually free) encryption software here: 
h^://inypy.cpm/redciyptp. 

A Note About Authentication 

There is a slight problem with public key ciphers. Imagine you got an email that said this: 

"Hello. I am Emmanuel Goldstein, leader of the resistance. I would 
like to communicate secretly with you about very important matters. 
Attached is my public key." 

Using the public key, you can be sure that the messages you send cannot be read by anyone other 
than "Emmanuel Goldstein". But how do you know the person who sent you this is actually 
Emmanuel Goldstein? Maybe it is Emmanuel Goldstein that you are sending encrypted messages 
to, or maybe it is a spy agency that is pretending to be Emmanuel Goldstein to lure you into a 
trap. 



382 http://inventwithpython.com/hacking 



So while public key ciphers (and, in fact, all the ciphers in this book) can provide 
confidentiality (that is, keeping the message a secret), they don't provide authentication (that 
is, proof that who you are communicating with really is who they say they are). 

Normally this isn't a problem with symmetric ciphers, because when you exchange keys with the 
person you can see them for yourself. However, you don't need to see a person in order to get 
their public key and begin sending them encrypted messages. This is something to keep in mind 
when using public key cryptography. 

There is an entire field called PKI (Public Key Infrastructure) that deals with authentication so 
that you can match public keys to people with some level of security; however, PKI is beyond the 
scope of this book. 



Even more insidious than hacking our encrypted messages is a man-in-the-middle attack. Say 
Emmanuel Goldstein really did want to communicate with you and sent you the above message, 
but the spy agency intercepted it. They could then replace the public key Emmanuel attached to 
the email with their own public key, and then send it on to you. You would think the spy agency's 
key was Emmanuel's key! 

Now when you encrypt a reply to Emmanuel, they intercept that message, decrypt it (since you 
really encrypted the message with the spy agency's public key, not Emmanuel's public key) and 
read it, and then they re-encrypt it with Emmanuel's actual public key and send it to him. They do 
the same thing with any messages that Emmanuel sends to you. 



The Man-ln-The-Middle Attack 




Figure 24-1. A man-in-the-middle attack. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 383 



To both you and Emmanuel, it looks like you are communicating secretly with each other. But 
actually, the spy agency is doing a man-in-the-middle attack and reading all of your messages. 
You and Emmanuel are actually encrypting your messages public keys generated by the spy 
agency! Again, this problem is caused by the fact that the public key cipher only provides 
confidentiality, but does not provide authentication. 

Generating Public and Private Keys 

A key in the RSA scheme is made of two numbers. There are three steps to creating the keys: 

1. Create two random, very large prime numbers. These numbers will be called p and q. 
Multiply these numbers to get a number which we will call n. 

2. Create a random number, called e, which is relatively prime with (p - 1) x (q - 1). 

3. Calculate the modular inverse of e. This number will be called d. 

The public key will be the two numbers n and e. The private key will be the two numbers n and d. 
(Notice that both keys have the number n in them.) We will cover how to encrypt and decrypt 
with these numbers when the RSA cipher program is explained. First let's write a program to 
generate these keys. 

Source Code for the RSA Key Generation Program 

Open a new file editor window by clicking on File ‚ñ∫ New Window. Type in the following code 
into the file editor, and then save it as makeRsaKeys.py. 



Source code for makeRsaKeys.py 

1. # RSA Key Generator 

2. # http://inventwithpython.com/hacknng (BSD Licensed) 
3. 

4. import random, sys, os, rabinMiller, cryptomath 

5. 

6. 

7. def main() : 

8. # create a public/private keypai r with 1024 bit keys 

9. print('Making key files...') 

10. makeKeyFiles('al_sweigart' , 1024) 

11. print('Key files made.') 
12. 

13. def generateKey(keySize) : 

14. # Creates a public/private key pair with keys that are keySize bits in 

15. # size. This function may take a while to run. 
16. 

17. # Step 1: Create two prime numbers, p and q. Calculate n = p * q. 

18. print('Cenerating p prime...') 



384 http://inventwithpython.com/hacking 



19. p = rabinMiller .generateLargePrime(keySize) 

20. printCGenerating q prime...') 

21. q = rabinMiller .generateLargePrime(keySize) 

22. n = p * q 

23. 

24. # Step 2: Create a number e that is relatively prime to (p-l)*(q-l) . 

25. printCGenerating e that is relatively prime to (p-l)*(q-l) . . . ') 

26. while True: 

27. # Keep trying random numbers for e until one is valid. 

28. e = random. rand range (2 ** (keySize - 1) , 2 ** (keySize)) 

29. if cryptomath.gcdCe, (p - 1) * (q - 1)) == 1: 

30. break 
31. 

32. # Step 3: Calculate d, the mod inverse of e. 

33. print('Calculating d that is mod inverse of e...') 

34. d = cryptomath . f i ndModInverse(e , (p - 1) * (q - 1)) 
35. 

36. publicKey = (n, e) 

37. privateKey = (n, d) 
38. 

39. pri nt( 1 Publ i c key:', publicKey) 

40. pri nt( ' Pri vate key:', privateKey) 
41. 

42. return (publicKey, privateKey) 

43. 

44. 

45. def makeKeyFiles(name, keySize): 

46. # Creates two files 'x_pubkey.txt' and 'x_privkey.txt' (where x is the 

47. # value in name) with the the n,e and d,e integers written in them, 

48. # delimited by a comma. 
49. 

50. # Our safety check will prevent us from overwriting our old key files: 

51. if os. path. exists('%s_pubkey. txt' % (name)) or 
os.path.exists('%s_privkey.txt' % (name)): 

52. sys.exitC WARNING: The file %s_pubkey.txt or %s_pri vkey . txt already 
exists! Use a different name or delete these files and re-run this program.' % 
(name, name)) 

53. 

54. publicKey, privateKey = generateKey(keySi ze) 
55. 

56. printO 

57. print('The public key is a %s and a %s digit number.' % 
(len(str(publicKey[0])) , len(str(publicKey[l])))) 

58. pri nt( ' Wri ti ng public key to file %s_pubkey.txt. . . ' % (name)) 

59. fo = open ('%s_pubkey. txt' % (name), 'w') 

60. fo.write('%s,%s,%s' % (keySize, publ i cKey [0] , publ i cKey [1] )) 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 385 



61. 


fo.closeO 


62. 




63. 


printO 


64. 


print('The private key is a %s and a %s digit number.' % 


(len(str(publicKey[0])) , len(str(publicKey[l])))) 


65. 


pri nt( ' Wri ti ng private key to file %s_privkey.txt. . . 1 % (name)) 


66. 


fo = open('%s_privkey.txt' % (name), 'w') 


67. 


fo.write('%s,%s,%s' % (keySize, pri vateKey [0] , privateKey[l])) 


68. 


fo.closeO 


69. 




70. 




71. 


# If makeRsaKeys . py is run (instead of imported as a module) call 


72. 


# the main() function. 


73. 


if name == ' main ': 


74. 


mainQ 



Sample Run of the RSA Key Generation Program 

When you run the makeRsaKeys. py program, the output will look something like this (of course, 
the numbers for your keys will be different since they are random numbers): 



Making key files. . . 
Generating p prime... 
Generating q prime... 

Generating e that is relatively prime to (p-l)*(q-l) . . . 
Calculating d that is mod inverse of e... 
Public key: 

(210902406316700502401968491406579417405090396754616926135810621216116191338086 

5678407459875355468897928072386270510720443827324671435893274858393749685062411 

6776147241821152026946322876869404394483922202407821672864242478920813182699000 

8473526711744296548563866768454251404951960805224682425498975230488955908086491 

8521163487778495362706850854469709529156400505222122042218037444940658810103314 

8646830531744960702788478777031572995978999471326531132766377616771007701834003 

6668306612665759417207845823479903440572724068125211002329298338718615859542093 

72109725826359561748245019920074018549204468791300114315056117093, 

1746023076917516102173184545923683355383240391086912905495420037367858093524760 

6622265764388235752176654737805849023006544732896308685513669509917451195822611 

3980989513066766009588891895645995814564600702703936932776834043548115756816059 

906591453170741270845572335375041024799371425300216777273298110097435989) 

Private key: 

(210902406316700502401968491406579417405090396754616926135810621216116191338086 
5678407459875355468897928072386270510720443827324671435893274858393749685062411 
6776147241821152026946322876869404394483922202407821672864242478920813182699000 
8473526711744296548563866768454251404951960805224682425498975230488955908086491 
8521163487778495362706850854469709529156400505222122042218037444940658810103314 



386 http://inventwithpython.com/hacking 



8646830531744960702788478777031572995978999471326531132766377616771007701834003 

6668306612665759417207845823479903440572724068125211002329298338718615859542093 

72109725826359561748245019920074018549204468791300114315056117093, 

4767673579813771041216688491698376504317312028941690434129597155228687099187466 

6099933371008075948549008551224760695942666962465968168995404993934508399014283 

0537106767608359489023128886399384026861870750523607730623641626642761449656525 

5854533116668173598098138449334931305875025941768372702963348445191139635826000 

8181223734862132564880771928931192 572481077942568188460364002867327313529283117 

0178614206817165802812291528319562200625082557261680470845607063596018339193179 

7437503163601143217769616471700002 543036826990539739057474642785416933878499897 

014777481407371328053001838085314443545845219087249544663398589) 

The public key is a 617 and a 309 digit number. 
Writing public key to file al_sweigart_pubkey.txt... 

The private key is a 617 and a 309 digit number. 
Writing private key to file al_sweigart_privkey.txt... 

These two keys are written out to two different files, al_sweigart _pubkey.txt and 
al_sweigart _privkey.txt. These filenames are used because the string ' al_sweigart ' was 
passed to the makeKeyFiles ( ) function. You can specify a different filenames by passing a 
different string. These key files will be used by the RSA cipher program to encrypt and decrypt 
messages. 

If you try to run makeRsaKeys.py again with the same string being passed to 
makeKeyFiles ( ) , the output of the program will look like this: 



Making key files. . . 

WARNING: The file al_sweigart_pubkey.txt or al_sweigart_privkey.txt already 
exists! Use a different name or delete these files and re-run this program. 

This warning is here so you don't accidentally overwrite your key files, making any files you 
encrypted with them impossible to recover. Keep your keys safe! 



How the Key Generation Program Works 







makeRsaKeys . py 


1. 


# RSA Key Generator 




2. 
3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 


import random, sys, os, rabinMiller, cryptomath 





The program imports the rabinMiller and cryptomath modules that we created in the last 
chapter, along with a few others. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 387 







makeRsaKeys . py 


7. 

8. 


def mainO : 

# create a public/private keypai r with 1024 bit keys 




9. 


print('Making key files...') 




10. 


makeKeyFiles('al_sweigart' , 1024) 




11. 


print('Key files made. 1 ) 





When makeRsaKeys. py is run, the main ( ) function is called, which will create the key files. 
Since the keys might take a while for the computer to generate, we print a message on line 9 
before the makeKeyFiles ( ) call so the user knows what the program is doing. 



The makeKeyFiles ( ) call on line 10 passes the string ' al_sweigart ' and the integer 
102 4. This will generate keys with a size of 1024 bits and store them in files named 
al_sweigart _pubkey.txt and al_sweigart _privkey.txt. 



The Program's generateKey ( ) Function 





makeRsaKeys . py 


13. 


def generateKey(keySize) : 


14. 


# Creates a public/private key pair with keys that are keySize bits in 


15. 


# size. This function may take a while to run. 


16. 




17. 


# Step 1: Create two prime numbers, p and q. Calculate n = p * q. 


18. 


print('Cenerating p prime...') 


19. 


p = rabinMiller .generateLargePrime(keySize) 


20. 


print('Cenerating q prime...') 


21. 


q = rabinMiller .generateLargePrime(keySize) 


22. 


n = p * q 



The first step of creating keys is coming up with two random prime numbers which are called p 
and q. The generateLargePr ime ( ) function we wrote in the last chapter's rabinMiller. py 
program will return a prime number (as an integer value) of the size determined by the value in 
keySize on line 19 and line 21. These integer values are stored in variables named p and q. 



On line 22, the number n is calculated by multiplying p and q, and stored in n. 





makeRsaKeys . py 


24. 


# Step 2: Create a number e that is relatively prime to (p-l)*(q-l) . 


25. 


printC'Generating e that is relatively prime to (p-l)*(q-l) . . . ') 


26. 


while True: 


27. 


# Keep trying random numbers for e until one is valid. 


28. 


e = random. randrange(2 ** (keySize - 1) , 2 ** (keySize)) 


29. 


if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1: 



388 http://inventwithpython.com/hacking 



30. break 

The second step is calculating a number e which is relatively prime to the product of p - 1 and 
q - 1. The while loop on line 26 is an infinite loop. The random . randrange ( ) call on 
line 28 returns a random integer (stored in the e variable) and line 29 tests if this random number 
is relatively prime to (p - 1) * (q - 1 ). If it is, the break statement on line 30 breaks 
out of the infinite loop. Otherwise, the program execution jumps back to line 26 and will keep 
trying different random numbers until it finds one that is relatively prime with (p - 1 ) * ( q - 
1). 

This way we can guarantee that when the program execution gets past this while loop, the 
variable e will contain a number that is relatively prime to (p - 1 ) * (q-1). 









makeRsaKeys . py 


32. 


# Step 3: Calculate d, the mod inverse of e. 






33. 


print ('Calculating d that is mod inverse of e.. 


‚ñ† ') 




34. 


d = cryptomath.findModInverse(e, (p - 1) * (q - 


D) 





The third step is to find the mod inverse of e. The f indModlnverse ( ) function that we wrote 
for our cryptomath module in Chapter 14 will do this calculation for us. The mod inverse of e 
is stored in a variable named d. 







makeRsaKeys . py 


36. 


publicKey = (n, e) 




37. 


privateKey = (n, d) 





In the RSA cipher, each key is made up of two numbers. The public key will be the integers 
stored in n and e, and the private key will be the integers stored in n and d. Lines 36 and 37 store 
these integers as tuples in the variables publicKey and privateKey. 



There's no reason e has to be in the public key and d in the private key, and you could swap 
them. However, once you make the public key public, you must keep the private key a secret. 









makeRsaKeys . py 


39. 


pri nt( 1 Publ i c key: 


, publicKey) 




40. 


pri nt( 1 Private key 


' , privateKey) 




41. 








42. 


return (publicKey, 


privateKey) 





Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 389 



The remaining lines inthegenerateKeyO function print the keys on the screen with 
print ( ) calls on lines 39 and 40. Then line 42's generateKey ( ) call returns a tuple with 

publicKey and privateKey. 







makeRsaKeys . py 


45. 


def makeKeyFiles(name, keySize): 




46. 


# Creates two files 'x_pubkey.txt 


and 'x_privkey.txt' (where x is the 


47. 


# value in name) with the the n,e 


and d,e integers written in them, 


48. 


# delimited by a comma. 





While the generateKey () function will generate the actual integers for the public and private 
keys, we need to store these numbers in a file so that our RSA cipher program can use them later 
to encrypt and decrypt. Each of the keys are made of two integers that are hundreds of digits long; 
that's too many to memorize or conveniently write down. The easiest way to store them is as text 
files on your computer. 

This means that you have to be sure that nobody hacks your computer and copies these key files. 
It might be a good idea to store these files on a USB thumb drive instead of on your computer. 
However, this is also risky. If someone borrows the thumb drive then they could copy the key 
files, or if you accidentally break or lose the thumb drive then you will lose your own private key! 



makeRsaKeys . py 

50. # Our safety check will prevent us from overwriting our old key files: 

51. if os. path. exists('%s_pubkey. txt' % (name)) or 
os . path . exi sts ( ' %s_pri vkey . txt ' % (name)): 

52. sys. exit ('WARNING: The file %s_pubkey . txt or %s_pri vkey .txt already 
exists! Use a different name or delete these files and re-run this program.' % 
(name, name)) 



To prevent us from accidentally deleting our key files by running the program again, line 51 
checks to see if the public or private key files with the given name already exist. If they do, the 
program will exit with a warning message. 



makeRsaKeys . py 

54. publicKey, privateKey = generateKey(keySi ze) 



After the check, line 54 has a call to generateKey ( ) to get the public and private keys using 
the multiple assignment trick. The generateKey ( ) function returns a tuple of two tuples. The 
first tuple has two integers for the public key and the second tuple has two integers for the private 
key. These are stored in the variables publicKey and privateKey. 



390 http://inventwithpython.com/hacking 

RSA Key File Format 

makeRsaKeys . py 

56. print () 

57. print('The public key is a %s and a %s digit number. 1 % 
(len(str(publicKey[0])) , len(str(publicKey[l])))) 

58. print('Writing public key to file %s_pubkey.txt. . . ' % (name)) 

59. fo = open('%s_pubkey.txt' % (name), 'w') 
fo.write('%s,%s,%s' % (keySize, publ i cKey [0] , publicKey[l])) 

61. fo.closeO 

Line 57 prints some information about the public key. It can tell how many digits are in the 
integer in publicKey [ 0 ] and publicKey [ 1 ] by converting those values to strings with the 
str ( ) function, and then finding the length of the string with the len ( ) function. 

The key file's contents will be the key size, a comma, the n integer, another comma, and the e (or 
d) integer. The file's contents will look like: &lt;key size integer&gt;,&lt;n integer&gt;,&lt;e or d integer&gt; 

Lines 59 to 61 open a file in write mode, as you can tell from the ' w ' string passed to open ( ) . 



makeRsaKeys . py 

63. printO 

64. print('The private key is a %s and a %s digit number.' % 
(len(str(publicKey[0])) , len(str(publicKey[l])))) 

65. printC'Writing private key to file %s_privkey.txt. . . ' % (name)) 

66. fo = open('%s_privkey.txt' % (name), 'w') 

67. fo.write('%s,%s,%s' % (keySize, pri vateKey [0] , privateKey[l])) 

68. fo.closeO 



Lines 63 to 68 do the exact same thing as lines 56 and 61, except for writing the private key out to 
a file. 



makeRsaKeys . py 

71. # If makeRsaKeys . py is run (instead of imported as a module) call 

72. # the main() function. 

73. if name == 1 main ': 

74. main() 

Lines 73 and 74 are at the bottom of the program, and call main ( ) if makeRsaKeys.py is being 
run as a program instead of imported as a module by another program. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 39 1 



Hybrid Cryptosystems 

In real life, the complicated mathematics make RSA and public-key encryption slow to compute. 
This is especially true for servers that need to make hundreds or thousands of encrypted 
connections a second. Instead, the RSA cipher is often used to encrypt the key for a symmetric 
key cipher. The encrypted key is then sent to the other person, and that key is used to pass 
messages that are encrypted using the (faster) symmetric cipher. Using a symmetric key cipher 
and an asymmetric key cipher to securely communicate like this is called a hybrid 
cryptosystem. More information about hybrid cryptosystems can be found at 
https://en.wM 

It's not recommended to use the rsaCipher.py program to encrypt the keys for, say, the 
vigenereCipher.py program. We've already proven that the Vigenere cipher is hackable. A strong 
symmetric key cipher isn't covered in this book, but you can still use rsaCipher.py to encrypt 
your files anyway. 

Source Code for the RSA Cipher Program 

Now that you can create key files, let's write the program that does encryption and decryption 
with the RSA cipher. Open a new file editor window by clicking on File ‚ñ∫ New Window. Type 
in the following code into the file editor, and then save it as rsaCipher.py. 



Source code for rsaCipher.py 

1. # RSA Cipher 

2. # http://inventwithpython.com/hacking (BSD Licensed) 
3. 

4. import sys 
5. 

6. # IMPORTANT: The block size MUST be less than or equal to the key size! 

7. # (Note: The block size is in bytes, the key size is in bits. There 

8. # are 8 bits in 1 byte.) 

9. DEFAULT_BLOCK_SIZE = 128 # 128 bytes 

10. BYTE_SIZE = 256 # One byte has 256 different values. 
11. 

12 . def main() : 

13. # Runs a test that encrypts a message to a file or decrypts a message 

14. # from a file. 

15. filename = 'encrypted_file.txt' # the file to write to/read from 

16. mode = 'encrypt' # set to 'encrypt' or 'decrypt' 
17. 

18. if mode == 'encrypt': 

19. message = 1 ' 1 "Journal i sts belong in the gutter because that is 
where the ruling classes throw their guilty secrets." -Gerald Priestland "The 



392 http://inventwithpython.com/hacking 



Founding Fathers gave the free press the protection it must have to bare the 
secrets of government and inform the people." -Hugo Black' 1 ' 



20. pubKeyFilename = 'al_sweigart_pubkey.txt' 

21. pri nt( ' Encrypti ng and writing to %s...' % (filename)) 

22. encryptedText = encryptAndWriteToFile(filename, pubKeyFilename, 
message) 

23. 

24. pri nt( ' Encrypted text:') 

25. pri nt(encryptedText) 

26. 

27. el if mode == 'decrypt': 

28. privKeyFilename = 'al_sweigart_privkey.txt' 

29. pri nt( ' Readi ng from %s and decrypting... 1 % (filename)) 

30. decryptedText = readFromFileAndDecrypt(filename, privKeyFilename) 

31. 

32. pri nt( ' Decrypted text:') 

33. print(decryptedText) 

34. 
35. 

36. def getBlocksFromText(message, blockSize=DEFAULT_BLOCK_SIZE) : 

37. # Converts a string message to a list of block integers. Each integer 

38. # represents 128 (or whatever blockSize is set to) string characters. 
39. 

40. messageBytes = message . encode( ' asci i ' ) # convert the string to bytes 
41. 

42. blocklnts = [] 

43. for blockStart in range(0, len(messageBytes) , blockSize): 

44. # Calculate the block integer for this block of text 

45. blocklnt = 0 

46. for i in range(blockStart, mi n(blockStart + blockSize, 
len(messageBytes))) : 

47. blocklnt += messageBytes [i ] * (BYTE_SIZE ** (i % blockSize)) 

48. blocklnts. append(blocklnt) 

49. return blocklnts 
50. 

51. 

52. def getTextFromBlocks(block!nts, messageLength , 



blockSize=DEFAULT_BLOCK_SIZE) : 



53. # Converts a list of block integers to the original message string. 

54. # The original message length is needed to properly convert the last 

55. # block integer. 

56. message = [] 

57. for blocklnt in blocklnts: 

58. blockMessage = [] 

59. for i in range(blockSize - 1, -1, -1): 

60. if 1 en (message) + i &lt; messageLength: 

61. # Decode the message string for the 128 (or whatever 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 393 



62. # blockSize is set to) characters from this block integer. 

63. ascii Number = blocklnt // (BYTE_SIZE ** i) 

64. blocklnt = blocklnt % (BYTE_SIZE ** i) 

65. blockMessage.insert(0, chr(asci i Number)) 



66. message. extend (blockMessage) 

67. return ' ' . join(message) 
68. 

69. 

70. def encryptMessage(message, key, blockSize=DEFAULT_BLOCK_SIZE) : 

71. # Converts the message string into a list of block integers, and then 

72. # encrypts each block integer. Pass the PUBLIC key to encrypt. 

73. encryptedBlocks = [] 

74. n, e = key 
75. 

76. for block in getBlocksFromText(message, blockSize): 

77. # ciphertext = plaintext a e mod n 

78. encryptedBlocks. append (pow(block, e, n)) 

79. return encryptedBlocks 
80. 

81. 

82. def decryptMessage(encryptedBlocks , messageLength , key, 
blockSize=DEFAULT_BLOCK_SIZE) : 



83. # Decrypts a list of encrypted block ints into the original message 

84. # string. The original message length is required to properly decrypt 

85. # the last block. Be sure to pass the PRIVATE key to decrypt. 

86. decryptedBlocks = [] 

87. n, d = key 

88. for block in encryptedBlocks: 

89. # plaintext = ciphertext a d mod n 

90. decryptedBlocks. append(pow(block, d, n)) 

91. return getTextFromBlocks(decryptedBlocks, messageLength, blockSize) 

92. 
93. 

94. def readKeyFi 1 e(keyFi 1 ename) : 

95. # Given the filename of a file that contains a public or private key, 

96. # return the key as a (n,e) or (n,d) tuple value. 

97. fo = open (keyFil ename) 

98. content = fo.readO 

99. fo.closeO 

100. keySize, n, EorD = content . spl i t( ',' ) 

101. return (i nt(keySi ze) , int(n), int(EorD)) 
102. 

103. 

104. def encryptAndWriteToFile(messageFil ename, keyFilename, message, 



blockSize=DEFAULT_BLOCK_SIZE) : 

105. # Using a key from a key file, encrypt the message and save it to a 



394 http://inventwithpython.com/hacking 



106. # file. Returns the encrypted message string. 

107. keySize, n, e = readKeyFile(keyFilename) 
108. 

109. # Check that key size is greater than block size. 

110. if keySize &lt; blockSize * 8: # * 8 to convert bytes to bits 

111. sys . exi t( ' ERROR: Block size is %s bits and key size is %s bits. 



The RSA cipher requires the block size to be equal to or less than the key 
size. Either increase the block size or use different keys.' % (blockSize * 8, 
keySize)) 



112. 
113. 

114. # Encrypt the message 

115. encryptedBlocks = encryptMessage(message , (n, e) , blockSize) 

116. 

117. # Convert the large int values to one string value. 

118. for i in range(len(encryptedBlocks)) : 

119. encryptedBlocks[i] = str(encryptedBlocks[i]) 

120. encryptedContent = ' , ' . joi n(encryptedBlocks) 
121. 

122. # Write out the encrypted string to the output file. 

123. encryptedContent = '%s_%s_%s' % (len(message) , blockSize, 
encryptedContent) 

124. fo = open(messageFilename, 'w') 

125. fo . wri te(encryptedContent) 

126. fo.closeO 

127. # Also return the encrypted string. 

128. return encryptedContent 
129. 

130. 

131. def readFromFileAndDecryptCmessageFilename, keyFilename) : 

132. # Using a key from a key file, read an encrypted message from a file 

133. # and then decrypt it. Returns the decrypted message string. 

134. keySize, n, d = readKeyFile(keyFilename) 
135. 

136. 

137. # Read in the message length and the encrypted message from the file. 

138. fo = open(messageFilename) 

139. content = fo.readO 

140. messageLength , blockSize, encryptedMessage = content. split('_') 

141. messageLength = i nt(messageLength) 

142. blockSize = int(blockSize) 

143. 

144. # Check that key size is greater than block size. 

145. if keySize &lt; blockSize * 8: # * 8 to convert bytes to bits 

146. sys.exit('ERR0R: Block size is %s bits and key size is %s bits. 



The RSA cipher requires the block size to be equal to or less than the key 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 395 



size. Did you specify the correct key file and encrypted file?' % (blockSize * 

8, keySize)) 

147. 

148. # Convert the encrypted message into large int values. 

149. encryptedBlocks = [] 

150. for block in encryptedMessage . spl i t( ' , ' ) : 

151. encryptedBlocks. append (i nt (block)) 

152. 

153. # Decrypt the large int values. 

154. return decryptMessage(encryptedBlocks, messageLength , (n, d) , 
blockSi ze) 

155. 
156. 

157. # If rsaCipher.py is run (instead of imported as a module) call 

158. # the main() function. 

159. if name == ' main ': 

160. mainQ 



Sample Run of the RSA Cipher Program 

Once you have a public and private key file, you can send anyone your public file (or post it 
somewhere online) so others can send you messages. If you want to send a secret message to 
someone, first get their public key file and place it in the same directory as the rsaCipher.py 
program. Set the message variable on line 19 to the string of the message to encrypt. 

Make sure the mode variable is set to the string 'encrypt ' on line 16, and set the 
pubKeyFilename variable to the public key file's filename on line 20. The filename 
variable holds a string of the file that the ciphertext will be written to. 

When you run the program, the output will look like this: 



Encrypting and writing to encrypted_file.txt... 
Encrypted text: 

262_128_99261588918914129248869521413561361425429438626950729912505980066002708 
9830015533870663668185646157509007528457226336261821873976954531347724960840148 
5234147843064609273929706353514554444810285427183303767133366827434264155196422 
0917826499299282445350219039270525853857169256807439317455881433369973441896615 
9641434946805896304802494813292321784924727694126957902732539670170912919151008 
4539012275457327046892059514600198713235394985023008043572425418307615110483262 
2796568393228930000619315738939341534920563203314816419962044702016227849752350 
41470244964996075123464854629954207517620745550909143567815440815430367,6684261 
3553841756289795361296785769122909029892643608575548034344009592725547265584325 
2331933112765122922637923600156910575424723444966430139306688707256391991191466 
4504822721492217530056774346964092 597494522555496959638903763181124233744530745 



396 http://inventwithpython.com/hacking 



2041948917261094688708004245747998030244635761849845611609053856921438831555343 
2751213283486646600584040245146570901217502941710992503572482408074196762322544 
6680099823178790059243202224297039960462494558200472899766913932921695002362188 
1996217713713494770944644417894970293643840346744192412614346008019737829011867 
03144271104078294839144290043228508639879193883889311384,7277016624458973047704 
0806680156575455285570435553143790299815533233656061333313422971390933175290260 
5817773458688756774589737014227054621841244485285514206025269405528441594535085 
05361747163825597906271930262 56934316461174349640238168693204610463496242533658 
4736211406286896178786120454116459075038688037119234659059503824465257190001591 
9094263967757274610514128826270203357049019841335033192183418122067029417580137 
3024013553583624428117568253845170657841567369678118510784447456725765265002966 
2854459043617323327066630863887606386875040688709377112851144150781493772858323 
25922978358897651126143551277531003851780 



At the start of the text is 262 (which is the original message length), followed by an underscore 
and then 128 (which is the "block size"; block sizes are explained later). If you look carefully at 
the long string of digits after that, you will find two commas. The message is encrypted into three 
very large integers, separated by commas. These integers are the encrypted form of the string in 
the message variable on line 19. 

To decrypt, change the mode variable to 'decrypt ' and run the program again. Make sure 
privKeyFilename on line 28 is set to the filename of the private key file and that this file is 
in the same folder as rsaCipher.py. When you run the program, the output on the screen will look 
like this: 



Reading from encrypted_file.txt and decrypting... 
Decrypted text: 

"Journalists belong in the gutter because that is where the ruling classes 
throw their guilty secrets." -Gerald Priestland "The Founding Fathers gave the 
free press the protection it must have to bare the secrets of government and 
inform the people." -Hugo Black 

Note that the way the RSA cipher program is implemented, it can only encrypt and decrypt 
plaintext files. A plaintext file (not to be confused with "plaintext" in the cryptography sense) is 
a file that only contains text characters (like the kind that you can type on your keyboard). For 
example, the .py files that you type for your Python programs are plaintext files. Plaintext files 
are the type created with text editor software such as Notepad (on Windows), TextMate (on OS 
X), or Gedit (on Ubuntu). Specifically, plaintext files are files that only contain ASCII values 
(which are described later in this chapter). 

Files such as images, videos, executable programs, or word processor files are called binary 
files. (Word processor files are binary files because their text has font, color, and size information 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 397 



bundled with the text.) More information about plaintext files and binary files can be found at 
http;//inypy.conVpM 

Practice Exercises, Chapter 24, Set A 

Practice exercises can be found at http://inypy^ 

Digital Signatures 

Digital signatures is a very large topic of its own, but we can cover a little of it here. Let's say 
Alice sent this email to Bob: 



From : al i ce@i nventwi thpython . com 
To: bob@coffeeghost.net 
Subject: Our agreement. 

Dear Bob, 

I promise to buy your old broken laptop for one 
million dollars. 

Si ncerely , 
Alice 



This is great news to Bob, who wants to get rid of his worthless laptop for any price. But what if 
Alice later claims that she didn't make this promise, and that the email Bob has is a forgery that 
didn't really come from her. The email just exists as some file on Bob's computer. Bob could 
have easily created this file himself. 

If they had met in person, Alice and Bob could have signed a contract. The handwritten signature 
is not easy to forge and provides some proof that Alice really did make this promise. But even if 
Alice signed such a paper, took a photo of it with her digital camera, and sent Bob the image file, 
it is still believable for Alice to say that the image was photoshopped. 

The RSA cipher (and any public key cipher) not only provides encryption, but it can also provide 
a way to digitally sign a file or string. Remember that RSA has a public key and a private key, 
and that any string that is encrypted with one key produces ciphertext that can only be decrypted 
with the other key. Normally we encrypt with the public key, so that only the owner of the private 
key can decrypt this ciphertext. 

But we can also do the reverse. If Alice writes this message, and then "encrypts" it with her 
private key, this will produce "ciphertext" that only Alice's public key can decrypt. This 
"ciphertext" isn't really so secret since everyone in the world has access to Alice's public key to 



398 http://inventwithpython.com/hacking 

decrypt it. But by encrypting a message with her own private key, Alice has digitally signed 
the message in a way that cannot be forged. Everyone can decrypt this signed message with her 
public key, and since only Alice has access to her private key, only Alice could have produced 
this ciphertext. Alice has to stick to her digital signature; she can't say that Bob forged or 
photoshopped it! 

This feature is called nonrepudiation. Nonrepudiation is where someone who has made a 
statement or claim cannot later refute that they made that statement or claim. Alice could always 
claim that her computer was hacked and somebody else had access to her private key, but this 
would mean that any other documents she signed could be called into question. (And it would be 
very suspicious if Alice's computer kept "getting hacked" each time she wanted to back out of a 
promise.) 

Digital signatures can also provide authentication, which allows someone to prove they are who 
they say they are. If Alice gets an email claiming to be from the President but wants to be sure it 
really is the President, she could always respond with, "Prove you're the President! Encrypt the 
string 'SIMTAVOKXVAHXXSLBGZXVPKNMQMHOYGWFQMXEBCC' with the President's 
private key." and Alice would be able to decrypt the reply with the President's public key to see if 
it decrypted to her random string. This is called a challenge-response authentication system. 

Digital signatures can be used to do many important things, including digital cash, authentication 
of public keys, or anonymous web surfing. If you'd like to find out more, go to 



How the RSA Cipher Program Works 







rsaCipher.py 


1. 


# RSA Cipher 




2. 

3. 


# http://inventwithpython.com/hacking (BSD Licensed) 




4. 
5. 


import sys 




6. 


# IMPORTANT: The block size MUST be less than or equal to the 


key size! 


7. 


# (Note: The block size is in bytes, the key size is in bits. 


There 


8. 


# are 8 bits in 1 byte.) 




9. 


D E FAU LT_B LOC K_S I Z E = 128 # 128 bytes 




10. 


BYTE_SIZE = 256 # One byte has 256 different values. 





A single "byte" can hold a number between 0 and 255, that is, 256 different numbers. We will use 
this fact in some of the block-related math explained later. This is why the BYTE_S I ZE constant 
is set to 2 5 6. The DEFAULT_BLOCK_S I ZE constant is set to 1 2 8 because we will be using 
block sizes of 128 bytes by default in our program. (Block sizes are explained later.) 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 399 







rsaCi pher . py 


12. 


def man n() : 




13. 


# Runs a test that encrypts a message to a file or decrypts 


a message 


14. 


# from a file. 




15. 


filename = 'encrypted_file.txt' # the file to write to/read 


from 


16. 


mode = 'encrypt' # set to 'encrypt' or 'decrypt' 





If mode is set to ' encrypt ' the program encrypts a message (and writes it to the file that is 
named in filename). If mode is set to ' decrypt ' the program reads the contents of an 
encrypted file (specified by the string in filename) to decrypt it. 



rsaCipher.py 

18. if mode == 'encrypt': 

19. message = 111 "Journal i sts belong in the gutter because that is 
where the ruling classes throw their guilty secrets." -Gerald Priestland "The 
Founding Fathers gave the free press the protection it must have to bare the 
secrets of government and inform the people." -Hugo Black' 1 ' 

20. pubKeyFi 1 ename = 'al_sweigart_pubkey.txt' 

21. pri nt( ' Encrypti ng and writing to %s...' % (filename)) 

22. encryptedText = encryptAndWri teToFi 1 e(fi 1 ename , pubKeyFi 1 ename , 
message) 

23. 

24. pri nt( ' Encrypted text: 1 ) 

25. pri nt(encryptedText) 

The message variable contains the text to be encrypted, and pubKeyFilename contains the 
filename of the public key file. Line 22 calls the encryptAndWriteToFile ( ) function, 
which will encrypt me s sage using the key, and write the encrypted message to the file named in 

filename. 





rsaCipher.py 


27. 


el if mode == 'decrypt': 


28. 


pri vKeyFi 1 ename = 'al_sweigart_privkey.txt' 


29. 


print('Reading from %s and decrypting...' % (filename)) 


30. 


decryptedText = readFromFileAndDecrypt(filename, pri vKeyFil ename) 


31. 




32. 


print('Decrypted text:') 


33. 


print(decryptedText) 



The code that handles calling the decryption function is similar to the code on lines 18 to 33. The 
filename of the private key file is set in privKeyFilename. The encrypted file's filename is 
stored in the filename variable. These two variables are passed to a call to 



400 http://inventwithpython.com/hacking 



readFromFileAndDecrypt ( ) . The return value is stored in decryptedText and then 
printed to the screen. 

ASCII: Using Numbers to Represent Characters 

All data is stored on your computer as numbers. A code called the American Standard Code for 
Information Interchange, or ASCII (pronounced "ask-ee") maps numbers to characters. Table 24- 
1 shows how ASCII maps numbers and characters (only numbers 32 to 126 are used): 



Table 24-1. The ASCII table. 



32 


(space) 


48 


0 


64 


@ 


80 


P 


96 




112 


P 


33 


i 


49 


1 


65 


A 


81 


Q 


97 


a 


113 


q 


34 




50 


2 


66 


B 


82 


R 


98 


b 


114 


r 


35 


# 


51 


3 


67 


C 


83 


S 


99 


c 


115 


s 


36 


$ 


52 


4 


68 


D 


84 


T 


100 


d 


116 


t 


37 


o, 

0 


53 


5 


69 


E 


85 


U 


101 


e 


117 


u 


38 


&amp; 


54 


6 


70 


F 


86 


V 


102 


f 


118 


V 


39 




55 


7 


71 


G 


87 


w 


103 


g 


119 


w 


40 


( 


56 


8 


72 


H 


88 


X 


104 


h 


120 


X 


41 


) 


57 


9 


73 


I 


89 


Y 


105 


i 


121 


Y 


42 


* 


58 




74 


J 


90 


Z 


106 


j 


122 


z 


43 


+ 


59 


r 


75 


K 


91 


[ 


107 


k 


123 


{ 


44 


f 


60 


&lt; 


76 


L 


92 


\ 


108 


1 


124 


1 


45 




61 




77 


M 


93 


] 


109 


m 


125 


} 


46 




62 


&gt; 


78 


N 


94 


A 


110 


n 


126 




47 


1 


63 




79 


0 


95 




111 


o 







A single ASCII character uses one byte of memory to store. A byte is enough memory to store a 
number from 0 to 255 (for a total of 256 different values.) So the string 'Hello ' is actually 
stored on your computer as the numbers 72, 101, 108, 108, and 111. These numbers take up 5 
bytes. ASCII provides a standard way to convert string characters to numbers and back. 

ASCII works fine for English messages, but not so much for other European languages that have 
special characters such as the e in "Vigenere", or languages such as Chinese and Arabic. ASCII 
doesn't even work well outside of America, since ASCII includes the $ dollar sign but not the ‚Ç¨ 
euro or ¬£ pound signs. If you want to learn about Unicode, the international system of character 
encoding, go to http://inypy.com/umcode. But this book will use ASCII for simplicity. 

Thechr() andord() Functions 

Remember from the first chapter where a code was a publicly-known way of translating 
information from one format to another format? For example, Morse code was a way of 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 401 



translating English letters into electric pulses of dots and dashes. ASCII is just a code. We can 
encode characters into ASCII numbers and decode ASCII numbers back to characters. 

The chr ( ) function (pronounced "char", short for "character") takes an integer ASCII number 
as the argument and returns a single -character string. The ord ( ) function (short for "ordinal") 
takes a single-character string as the argument, and returns the integer ASCII value for that 
character. Try typing the following into the interactive shell: 

&gt;&gt;&gt; chr(65) 
'A' 

&gt;&gt;&gt; ord ( ' A ' ) 

65 

¬ª&gt; chr(73) 
' I ' 

¬ª&gt; chr(65 + 8) 
' I ' 

¬ª&gt; chr (52) 
' 4 ' 

&gt;&gt;&gt; chr (ord ( ' F ' ) ) 
' F ' 

&gt;&gt;&gt; ord (chr ( 68) ) 

68 

&gt;&gt;&gt; 



But if you have a string with many letters, it may be easier to use the encode ( ) and 
decode ( ) string methods explained later in this chapter. 

Practice Exercises, Chapter 24, Set B 

Practice exercises can be found at http://invpy.co^ 

Blocks 

In cryptography, a "block" is a fixed length of bits. In our RSA cipher program, a block is 
represented by an integer. We've set the block size to 128 bytes, or 1024 bits (since there are 8 
bits in 1 byte). Our message string value will be converted into several integer values (i.e. several 
blocks). 

‚Ä¢ It is important to note that the RSA encryption algorithm requires that the block size be 
equal or less than the key size. Otherwise, the math doesn't work and you won't be able 
to decrypt the ciphertext the program produced. 



402 http://inventwithpython.com/hacking 



So a cryptographic block is really just a very large integer. Since our block size is 128 bytes, it 

can represent any integer between 0 and up to (but not including) 256 A 128, which is 

179,769,3 13,486,23 1 ,590,772,930,5 19,078,902,473,361 ,797,697,894,230,657,273,430,08 1 ,157,7 

32,675,805,500,963,132,708,477,322,407,536,021,120,113,879,871,393,357,658,789,768,814,41 

6,622,492,847,430,639,474,124,377,767,893,424,865,485,276,302,219,601,246,094,119,453,082, 

952,085,005,768,838,150,682,342,462,881,473,913,110,540,827,237,163,350,510,684,586,298,2 

39,947,245,938,479,716,304,835,356,329,624,224,137,216. 

(You might have noticed that the RSA cipher uses a lot of big numbers.) 

The reason RSA needs to work on a block (which represents multiple characters) is because if we 
used the RSA encryption algorithm on a single character, the same plaintext characters would 
always encrypt to the same ciphertext characters. In that case, the RSA cipher just becomes a 
simple substitution cipher with fancy mathematics, kind of like the affine and Caesar ciphers. 

The RSA cipher works by encrypting an integer that is hundreds of digits long (that is, a block) 
into a new integer that is hundreds of digits long (that is, a new block). The mathematics of 
encrypting a large plaintext integer to a large ciphertext integer are simple enough. But first we 
will need a way to convert between a string and a large integer (that is, a block). 

We can use ASCII as a system to convert between a single character and a small integer (between 
0 and 255). But we will also need a way to combine several small integers into a large integer that 
we perform RSA encryption on. 

Remember how the affine cipher in Chapter 15 had two keys, Key A and Key B, but they were 
combined by multiplying Key A by the symbol set size (which was 95) and then adding Key B? 
This was how we combined two small key integers into one larger key integer. 

This worked because the ranges of both Key A and Key B were from 0 to 94. In the RSA 
program, each character's ASCII integer ranges from 0 to 255. To combine ASCII integers 
together into one large number we use the following formula: 

Take the ASCII integer of the character at index 0 of the string and multiply it by 256 A 0 (but 
since 256 A 0 is 1, and multiplying by 1 leaves you with just the original number, this one is 
easy). Take the ASCII integer of the character at index 1 and multiply it by 256 A 1. Take the 
ASCII integer of the character at index 2 and multiply it by 256 A 2, and so on and so on. To get 
the final large integer, add all of these products together. This integer is the ciphertext' s block. 

Table 24-2 has an example using the string, 'Hello world!': 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 403 



Table 24-2. Encoding a string into a block. 



Index 


Character 


ASCII 


Multiplied 


Number 






Number 


By 




0 


H 


72 


x 256 A 0 


= 72 


1 


e 


101 


x 256 A 1 


= 25,856 


2 


1 


108 


x 256 A 2 


= 7,077,888 


3 


1 


108 


x 256 A 3 


= 1,811,939,328 


4 


o 


111 


x 256 A 4 


= 476,741,369,856 


5 


(space) 


32 


x 256 A 5 


= 35,184,372,088,832 


6 


w 


119 


x 256 A 6 


= 33,495,522,228,568,064 


7 


o 


111 


x 256 A 7 


= 7,998,392,938,210,000,896 


8 


r 


114 


x 256 A 8 


= 2,102,928,824,402,888,884,224 


9 


1 


108 


x 256 A 9 


= 510,015,580,149,921,683,079,168 


10 


d 


100 


x 256 A 10 


= 120,892,581,961,462,917,470,617,600 


11 


! 


33 


x 256 A 11 


= 10,213,005,324,104,387,267,917,774,848 



SUM: 10,334,410,032,606,748,633,331,426,632 



(You might have noticed that the RSA cipher does a lot of math with big numbers.) 

So the string 'Hello world ! ' when put into a single large integer "block" becomes the 
integer 10,334,410,032,606,748,633,331,426,632. This integer uniquely refers to the string 
' Hello world ! ' . By continuing to use larger and larger powers of 256, any string possible 
has exactly one large integer. For example, 2,175,540 is the integer for ' 42 ! ' and 
17,802,628,493,700,941 is the integer for 'Moose?? ' and 

23,071,981,395,336,227,453,293,155,570,939,985,398,502,658,016,284,755,880,397,214,576,11 
0,064,091,578,359,739,349,325 is the integer for 'My cat's breath smells like cat 
food. ' . 

Because our block size is 128 bytes, we can only encrypt up to 128 characters in a single block. 
But we can just use more blocks if the message is longer than 128 characters. The RSA cipher 
program will separate the blocks it outputs with commas so we can tell when one block ends and 
the next one begins. 

As an example, here's a message that is split into blocks, and the integer that represents each 
block (calculated using the same method in Table 24-2.). Each block has at most 128 characters 
of the message. 



404 http://inventwithpython.com/hacking 



Table 24-3. A message split into blocks, with each block's integer. 



1 st Block 

(128 characters) 



2 nd Block 

(128 characters) 



3 rd Block 

(128 characters) 



4 th Block 

(107 characters) 



Message 

Alan Mathison Turing 
was a British 
mathematician, 
logician, cryptanalyst, 
and computer scientist. 
He was highly 
influential in t 

he development of 
computer science, 
providing a 
formalisation of the 
concepts of "algorithm" 
and "computation" with 
the Turing m 

achine. Turing is 
widely considered to be 
the father of computer 
science and artificial 
intelligence. During 
World War II, Turin 



g worked for the 
Government Code and 
Cypher School (GCCS) 
at Bletchley Park, 
Britain's codebreaking 
centre. 



Block Integer 

8 1 54693 1 2 1 8 1 7801 0029845 8 1 79 1 5569 1 8 8970228 
63503588092404856861189798874246340656702 
38839432215827478831941988018897629951268 
200430557 1 8365 1 6 1 1 72430048774726604 1 8030 1 
48768604258244651074200425332013985856895 
55969506391783606289711328048889254351125 
31133886746309774148590001157056903849858 
716430520524535327809 

7663 1289268 15471285902245 1 85 144708303053 1 
65677349319343558638588471345037404319956 
45932085093160422349968619052225062492420 
68799766044 14967974 1 1 6052 1 63 82354643908 14 
93343748091892111084834682008279498952509 
54725768834415584340223896902248947030025 
14434767442075089828357797890134106785932 
701869224970151814504 

77533874832922662837221187157031815413218 
696656 1 8 82894792372850423293 1 792998759025 
56568632161704130179292825376098664640739 
1 3 89732783 847470902847573 8093 8 88688583459 
78166272494460147358283858671447396525449 
89 1 375 1 78204782804352709400 1 4295674 1 750 14 
93130489686652467441331220556610652015232 
23099426694367336 1 249 

87080208891262703930798322686594857958157 
7351911311 2470 129994578 8 1 1 890430257029 1 37 
88 1 087 1 6 1 9692 1 9604284 1 627479667 1 334547332 
6462572770347673 84 1 50 178 8 1 8 8063 1 98043506 1 
77034123161704448596151 1 19133333044771426 
77343891157354079822547964726407323487308 
38206586983 



Converting Strings to Blocks with getBlocksFromText ( ) 

rsaCipher.py 

36. def getBlocksFromText (message, blockSize=DEFAULT_BLOCK_SIZE) : 

37. # Converts a string message to a list of block integers. Each integer 

38. # represents 128 (or whatever blockSize is set to) string characters. 

The getBlocksFromText ( ) function takes the message and returns a list of blocks (that is, a 
list of very large integer values) that represents the message. It is trivially easy to convert between 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 405 



strings to blocks and blocks to strings, so this step isn't encrypting anything. The encryption will 
be done later in the encryptMessage ( ) function. 

The encode ( ) String Method and the Bytes Data Type 

rsaCipher.py 

40. messageBytes = message . encode (' asci i ' ) # convert the string to bytes 

First, we need to convert the characters in the message string into ASCII integers. The 
encode ( ) string method will return a "bytes" object. Because a byte is represented as a number 
from 0 to 255, a bytes value is like a list of integers (although these integers have a very limited 
range of 0 to 255). The len ( ) function and indexing work with a bytes object in the same way a 
list of integers would. A bytes value can be turned into a list value of integer values by passing it 
to the li st ( ) function. Try typing the following into the interactive shell: 



¬ª&gt; spam = 'hello' .encode ('ascin ') 

¬ª&gt; spam 

b'hello' 

¬ª&gt; list(spam) 

[104, 101, 108, 108, 111] 

¬ª&gt; len (spam) 

5 

¬ª&gt; spam[2] 
108 

¬ª&gt; 

Note that a single bytes value is a collection of values, just like a single list value can contain 
multiple values. If you try to get a single "byte" from a bytes object (like spam [ 2 ] does above), 
this just evaluates to an integer value. 

Line 140 places the bytes form of the message string in a variable named messageBytes. 

The bytes ( ) Function and decode ( ) Bytes Method 

Just like you can create a list by calling the list ( ) function, you can also create a bytes object 
by calling the bytes ( ) function. The bytes ( ) function is passed a list of integers for the byte 
values. Try typing the following into the interactive shell: 



¬ª&gt; spam = bytes([104, 101, 108, 108, 111]) 

¬ª&gt; spam 

b'hello' 

¬ª&gt; list(spam) 

[104, 101, 108, 108, 111] 



406 http://inventwithpython.com/hacking 



¬ª&gt; 



You can also directly type a bytes object into your source code just like you type a string or list. 
A bytes object has the letter b right before what looks like an ordinary string value. But 
remember, the letter b right before the quotes means that this is a bytes value, not a string value. 
Try typing the following into the interactive shell, making sure that there is no space between the 
b and the quote characters: 



¬ª&gt; spam = b' hello' 

¬ª&gt; list(spam) 

[104, 101, 108, 108, 111] 

¬ª&gt; 

We don't use the decode ( ) bytes method in this program, but you should know about it. It does 
the opposite of the encode ( ) string method. When called on a bytes object, the decode ( ) 
method returns a string made from the values stored in the bytes object. Try typing the following 
into the interactive shell: 



¬ª&gt; spam = bytes([104, 101, 108, 108, 111]) 

¬ª&gt; spam. decode ('ascii ') 

'hello' 

¬ª&gt; 



Practice Exercises, Chapter 24, Set C 

Practice exercises can be found at http://inypy.con^^ 



Back to the Code 







rsaCipher.py 


42. 


blocklnts = [] 




43. 


for blockStart in range(0, len(messageBytes) , blockSize): 





The blocklnts list will contain the large integer "blocks" form of the characters in message. 
The blockSize parameter is set to DEFAULT_BLOCK_SI ZE by default, and the 
DEFAULT_BLOCK_SIZE constant was set to 128 (meaning, 128 bytes) on line 9. This means 
that each large integer block can only store 128 string characters at most (since 1 ASCII character 
takes up 1 byte). See Table 24-3 for an example of a message split into 128-character blocks. 



Line 43 's for loop will set the value in blockStart so that on each iteration it will be set to 
the index of the block being created. For example, if blockSize is set to 128, then the index of 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 407 



the start of the first block will be 0 , the index of the start of the second block will be 1 2 8 , the 
index of the start of the third block will be 2 5 6, and so on as long as the index is less than 

len (messageBytes ) . 



Themin() and max () Functions 

The min ( ) function returns the smallest (that is, the minimum) value of its arguments. Try 
typing the following into the interactive shell: 



¬ª&gt; 


min(13, 


32, 


13, 


15, 17, 39) 


13 










¬ª&gt; 


min(21, 


45, 


18, 


10) 


10 











You can also pass min ( ) a single argument if the argument is a list or tuple value. In this case, 
min ( ) returns the smallest value in that list or tuple. Try typing the following into the interactive 
shell: 



¬ª&gt; min ([31, 26, 20, 13, 12, 36]) 
12 

¬ª&gt; spam = (10, 37, 37, 43, 3) 

¬ª&gt; min (spam) 

3 

¬ª&gt; 



The max ( ) function will return the largest (that is, the maximum) value of its arguments: 



¬ª&gt; max(18, 15, 22, 30, 31, 34) 
34 

¬ª&gt; 



rsaCipher.py 

44. # Calculate the block integer for this block of text 

45. blocklnt = 0 

46. for i in range(blockStart, mi n(blockStart + blockSize, 
len(messageBytes))) : 

The code inside line 43 's for loop will create the very large integer for a single block. Recall 
from earlier in this chapter that this is done by multiplying the ASCII value of the character by 
(256 A index -of -character). 



408 http://inventwithpython.com/hacking 

The very large integer will eventually be stored inblocklnt, which starts at 0 on line 45. (This 
is much like how our previous cipher programs had a translated variable that started as a 
blank string but eventually held the encrypted or decrypted message by the end of the program.) 
Line 46's for loop sets i to be the index of all the characters in mes sage for this block. This 
index should start at blockStart and go up to blockStart + blockSize (that is, 
blockSize characters after blockStart) or len (messageBytes) , whichever is smaller. 
The min ( ) call on line 46 will return the smaller of these two expressions. 

The second argument to range ( ) on line 46 should be the smaller of these values because each 
block will always be made up of 128 (or whatever value is in blockSize) characters, except for 
the last block. The last block might be exactly 128 characters, but more likely it is less than the 
full 128 characters. In that case we want i to stop at len (messageBytes ) because that will 
be the last index in messageBytes. 







rsaCipher.py 


47. 


blocklnt += messageBytes [1] * (BYTE_SIZE ** (i 


% blockSize)) 



The value that is added to the block integer in blocklnt is the ASCII value of the character 
(which is what messageBytes [ i ] evaluates to) multiplied by (256 A index -of-character). 



The variable i cannot directly be used for the index-of-character part of the equation, because it 
is the index in the entire messageBytes object which has indexes from 0 up to 
len (messageBytes ) . We only want the index relative to the current iteration 's block, which 
will always be from 0 to blockSize. This table shows the difference between these indexes: 

Table 24-4. The indexes of the full message on top, and indexes relative to the block on bottom. 



1 st Block's Indexes 2 nd Block's Indexes 3 rd Block's Indexes 



0 


1 


2 


.. 127 


128 


129 130 . 


. 255 


256 


257 


258 . 


. 511 


512 


0 


1 


2 


.. 127 


128 


0 1 


. 127 


128 


0 


1 


. 127 


128 



By modding i by blockSize, we can get the position relative to the block. This is why line 47 

is BYTE SIZE ** (i % blockSize) instead of BYTE SIZE ** i. 







rsaCipher.py 


48. 


blocklnts .append (blocklnt) 




49. 


return blocklnts 





After line 46's for loop completes, the very large integer for the block has been calculated. We 
want to append this block integer to the blocklnts list. The next iteration of line 43 's for 
loop will calculate the block integer for the next block of the message. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 409 



After line 43 's for loop has finished, all of the block integers have been calculated and are 
stored in the blocklnts list. Line 49 returns blocklnts from getBlocksFromText ( ) . 



rsaCipher.py 

52. def getTextFromBlocksCblocklnts, messageLength , 
blockSize=DEFAULT_BLOCK_SIZE) : 

53. # Converts a list of block "integers to the original message string. 

54. # The original message length is needed to properly convert the last 

55. # block integer. 

56. message = [] 

57. for blocklnt in blocklnts: 



The getTextFromBlocks ( ) function does the opposite of getBlocksFromText ( ) . This 
function is passed a list of block integers (as the blocklnts parameter) and returns the string 
value that these blocks represent. The function needs the length of the message encoded in 
messageLength, since this information is needed to get the string from the last block integer if 
it is not a full 128 characters in size. 

Just as before, blockSize will default to DEFAULT_BLOCK_SI ZE if no third argument is 
passed to getTextFromBlocks ( ) , and DEFAULT_BLOCK_SI ZE was set to 12 8 on line 9. 

The message list (which starts as blank on line 56) will contain a string value for each character 
that was computed from each block integer in blocklnts. (This list of strings will be joined 
together to form the complete string at the end of getTextFromBlocks ( ) .) The message 
list starts off empty on line 56. The for loop on line 57 iterates over each block integer in the 
blocklnts list. 







rsaCipher.py 


58. 


blockMessage = [] 




59. 


for i in range(blockSize - 1, -1, -1): 





Inside the for loop, the code from lines 58 to 65 calculates the letters that are in the current 
iteration's block. Recall from Chapter 15's affine cipher program how one integer key was split 
into two integer keys: 



24. def getKeyParts(key) : 

25. keyA = key // 1 en (SYMBOLS) 

26. keyB = key % 1 en (SYMBOLS) 

27. return (keyA, keyB) 

The code in getTextFromBlocks ( ) works in a similar way, except the single integer (i.e. the 
block integer) is split into 128 integers (and each is the ASCII value for a single character). The 



410 http://inventwithpython.com/hacking 



way the ASCII numbers are extracted from blocklnt has to work backwards, which is why the 
for loop on line 59 starts at blockSize - 1, and then subtracts 1 on each iteration down to 
(but not including) - 1 . This means the value of i on the last iteration will be 0 . 



rsaCipher.py 

60. if 1 en (message) + i &lt; messageLength : 

61. # Decode the message string for the 128 (or whatever 

62. # blockSize is set to) characters from this block integer. 

63. ascii Number = blocklnt // (BYTE_SIZE ** i) 

64. blocklnt = blocklnt % (BYTE_SIZE ** i) 



The length of the me s sage list will be how many characters have been translated from blocks so 
far. The i f statement on line 60 makes sure the code does not keep computing text from the 
block after i has reached the end of the message. 

The ASCII number of the next character from the block is calculated by integer dividing 
blocklnt by (BYTE_SIZE ** i ). Now that we have calculated this character, we can 
"remove" it from the block by setting blocklnt to the remainder of blocklnt divided by 
( BYTE_S I ZE * * i ) . The % mod operator is used to calculate the remainder. 

The insert ( ) List Method 

While the append ( ) list method only adds values to the end of a list, the insert ( ) list 
method can add a value anywhere in the list. The arguments to insert ( ) are an integer index 
of where in the list to insert the value, and the value to be inserted. Try typing the following into 
the interactive shell: 



¬ª&gt; spam 


= [2, 4, 6, 8] 


¬ª&gt; spam 


insert(0, 'hello') 


¬ª&gt; spam 




['hello' 


2, 4, 6, 8] 


¬ª&gt; spam 


insert(2, 'world') 


¬ª&gt; spam 




['hello' 


2, 'world' , 4, 6, 8] 


¬ª&gt; 









rsaCipher.py 


65. 


blockMessage . i nsert(0, chr(asci i Number)) 





Using the chr ( ) function, the character that asciiNumber is the ASCII number of is inserted 
to the beginning of the list at index 0 . 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 411 







rsaCipher.py 


66. 


message . extend (bl ockMessage) 





After the for loop on line 59 completes, blockMessage will be a list of single-character 
strings that were computed/rom the current block integer. The strings in this list are appended to 
the end of the mes sage list with the extend ( ) method. 









rsaCipher.py 


67. 


return 1 


1 . joi n (message) 





After the for loop on line 57 completes, the single-character strings in message are joined 
together into a single string which is the complete message. This string is then returned from the 

getTextFromBlocks ( ) function. 



The Mathematics of RSA Encrypting and Decrypting 

With the numbers for e, d, and n from the public and private keys, the mathematics done on the 
block integers to encrypt and decrypt them can be summarized as follows: 

‚Ä¢ Encrypted Block = Plaintext Block A e mod n 

‚Ä¢ Decrypted Block = Ciphertext Block A d mod n 



rsaCipher.py 

70. def encryptMessage(message, key, blockSize=DEFAULT_BLOCK_SIZE) : 

71. # Converts the message string into a list of block integers, and then 

72. # encrypts each block integer. Pass the PUBLIC key to encrypt. 

73. encryptedBlocks = [] 

74. n, e = key 

The encryptMes sage ( ) function is passed the plaintext string along with the two-integer 
tuple of the private key. The function returns a list of integer blocks of the encrypted ciphertext. 
First, the encryptedBlocks variable starts as an empty list that holds the integer blocks and 
the two integers in key are assigned to variables n and e. 

Thepow() Function 

While the * * operator does exponents, the pow ( ) function handles exponents and mod. The 
expression pow (a, b, c) is equivalent to (a ** b) % c. However, the code inside the 
pow ( ) function knows how to intelligently handle very large integers and is much faster than 
typing the expression ( a * * b ) % c. Try typing the following into the interactive shell: 



¬ª&gt; pow(2, 8) 



412 http://inventwithpython.com/hacking 



256 






¬ª&gt; 


(2 ** 8) 




256 






¬ª&gt; 


pow(2, 8, 


10) 


6 






¬ª&gt; 


(2 ** 8) 


% 10 


6 






¬ª&gt; 











rsaCipher.py 


76. 


for block "in getBlocksFromText (message, blockSize): 




77. 


# ciphertext = plaintext a e mod n 




78. 


encryptedBlocks. append (pow(block, e, n)) 




79. 


return encryptedBlocks 





While creating the public and private keys involved a lot of math, the actual math of the 
encryption is simple. The very large integer of the block created from the string in message is 
raised to e and then modded by n. This expression evaluates to the encrypted block integer, and 
is then appended to encryptedBlocks on line 78. 



After all the blocks have been encrypted, the function returns encryptedBlocks on line 79. 



rsaCipher.py 

82. def decryptMessage(encryptedBlocks , messageLength , key, 
blockSize=DEFAULT_BLOCK_SIZE) : 

83. # Decrypts a list of encrypted block ints into the original message 

84. # string. The original message length is required to properly decrypt 

85. # the last block. Be sure to pass the PRIVATE key to decrypt. 

86. decryptedBlocks = [] 

87. n, d = key 



The math used in the decryptMessage ( ) function is also simple. The decryptedBlocks 
variable will store a list of the decrypted integer blocks, and the two integers of the key tuple are 
placed in n and d respectively using the multiple assignment trick. 







rsaCipher.py 


88. 


for block in encryptedBlocks: 




89. 


# plaintext = ciphertext a d mod n 




90. 


decryptedBlocks. append (pow(block, d, n)) 





The math of the decryption on line 90 is the same as the encryption's math, except the integer 
block is being raised to d instead of e. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 413 



rsaCipher.py 

91. return getTextFromBlocks(decryptedBlocks, messageLength , blockSize) 

The decrypted blocks along with the messageLength and blockSize parameters are passed 
getTextFromBlocks ( ) so that the decrypted plaintext as a string is returned from 

decryptMessage () . 



Reading in the Public &amp; Private Keys from their Key Files 









rsaCipher.py 


94. 


def readKeyFi 1 e(keyFi 1 ename) : 






95. 


# Given the filename of a file 


that contains a public or 


private key, 


96. 


# return the key as a (n,e) or 


(n,d) tuple value. 




97. 


fo = open (keyFil ename) 






98. 


content = fo. read() 






99. 


fo. closeQ 







The key files that makeRsakeys.py creates look like this: 



&lt;key size as an integer&gt;,&lt;big integer for N&gt;,&lt;big integer for E or D&gt; 



The readKeyFile ( ) function is called to read the key size, n, and e (for the public key) or d 
(for the private key) values from the key file. Lines 97 to 99 open this file and read in the contents 
as a string into the content variable. 







rsaCipher.py 


100. 


keySize, n, EorD = content . spl i t( ',' ) 




101. 


return (i nt(keySize) , int(n), int(EorD)) 





The split ( ) string method splits up the string in content along the commas. The list that 
split ( ) returns will have three items in it, and the multiple assignment trick will place each of 
these items into the keySize, n, and EorD variables respectively on line 100. 



Remember that content was a string when it was read from the file, and the items in the list 
that split ( ) returns will also be string values. So before returning the keySize, n, and EorD 
values, they are each passed to int ( ) to return an integer form of the value. This is how 
readKeyFile ( ) returns three integers that were read from the key file. 

The Full RSA Encryption Process 

rsaCipher.py 

104. def encryptAndWriteToFile(messageFilename, keyFilename, message, 
blockSize=DEFAULT_BLOCK_SIZE) : 



414 http://inventwithpython.com/hacking 



105. 


# Using 


a key from a key file, encrypt the message and save it to a 


106. 


# file. 


Returns the encrypted message string. 


107. 


keySize 


n, e = readKeyFile(keyFilename) 



The encryptAndWriteToFile ( ) function is passed three string arguments: a filename to 
write the encrypted message in, a filename of the public key to use, and a message to be 
encrypted. This function handles not just encrypting the string with the key, but also creating the 
file that contains the encrypted contents. (The blockSize parameter can also be specified, but 
it will be set to DEFAULT_BL0CK_SI ZE by default, which is 12 8.) 



The first step is to read in the values for keySize, n, and e from the key file by calling 
readKeyFile ( ) on line 107. 



rsaCipher.py 

109. # Check that key size is greater than block size. 

110. if keySize &lt; blockSize * 8: # * 8 to convert bytes to bits 

111. sys.exitC ERROR: Block size is %s bits and key size is %s bits. 
The RSA cipher requires the block size to be equal to or less than the key 
size. Either increase the block size or use different keys.' % (blockSize * 8, 
keySi ze)) 

In order for the mathematics of the RSA cipher to work, the key size must be equal to or greater 
than the block size. The blockSize value is in bytes, while the key size that was stored in the 
key file was in bits, so we multiply the integer in blockSize by 8 on line 1 10 so that both of 
these values represent number of bits. 

If keySize is less than blockSize * 8, the program exits with an error message. The user 
will either have to decrease the value passed for blocks i ze or use a larger key. 



rsaCipher.py 

114. # Encrypt the message 

115. encryptedBlocks = encryptMessage(message , (n, e) , blockSize) 

Now that we have the n and e values for the key, we call the encryptMes sage ( ) function 
which returns a list of integer blocks on line 115. The encryptMes sage ( ) is expecting a two- 
integer tuple for the key, which is why the n and e variables are placed inside a tuple that is then 
passed as the second argument for encryptMessage ( ) . 







rsaCipher.py 


117. 


# Convert the large int values to one string value. 




118. 


for i in range(len(encryptedBlocks)) : 





Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 415 



119. encryptedB"locks[i] = str(encryptedBlocks[i]) 

120. encryptedContent = ' , ' . joi n(encryptedBlocks) 

The j oin ( ) method will return a string of the blocks separated by commas, but j oin ( ) only 
works on lists with string values, and encryptedBlocks is a list of integers. These integers 
will have to first be converted into strings. 

The for loop on line 118 iterates through each index in encryptedBlocks, replacing the 
integer at encryptedBlocks [ i ] with a string form of the integer. When the loop completes, 
encryptedBlocks now contains a list of string values instead of a list of integer values. 

The list of string values is passed to the join ( ) method, which returns a single string of the 
list's strings joined together with commas. Line 120 stores this string in a variable named 

encryptedContent. 



rsaCipher.py 

122. # Write out the encrypted string to the output file. 

123. encryptedContent = '%s_%s_%s' % (1 en (message) , blockSize, 
encryptedContent) 

We want to write out more than just the encrypted integer blocks to the file though, so line 123 
changes the encryptedContent variable to include the size of the message (as an integer), 
followed by an underscore, followed by the blockSize (which is also an integer), followed by 
another underscore, and then followed by the encrypted integer blocks. 







rsaCipher.py 


124. 


fo = open(messageFilename, 'w') 




125. 


fo . wri te (encryptedContent) 




126. 


fo. close() 





The last step is to write out the contents of the encrypted file. The filename provided by the 
messageFilename parameter is created with the call to open ( ) on line 124. (The ' w ' 
argument tells open ( ) to open the file in "write mode".) Note that if a file with this name 
already exists, then it will be overwritten by the new file. 



The string in encryptedContent is written to the file by calling the write ( ) method on 
line 125. Now that we are done writing the file's contents, line 126 closes the file object in f o. 







rsaCipher.py 


127. 


# Also return the encrypted string. 




128. 


return encryptedContent 





416 http://inventwithpython.com/hacking 

Finally, the string in encryptedContent is returned from the 

encryptAndWriteToFile ( ) function on line 128. (This is so that the code that calls the 
function can use this string to, for example, print it on the screen.) 

The Full RSA Decryption Process 

rsaCipher.py 

131. def readFromFileAndDecryptCmessageF-ilename, keyFilename): 

132. # Using a key from a key file, read an encrypted message from a file 

133. # and then decrypt it. Returns the decrypted message string. 

134. keySize, n, d = readKeyFi 1 e(keyFi 1 ename) 

The readFromFileAndDecrypt ( ) function, like encryptAndWriteToFile ( ) , has 
parameters for the encrypted message file's filename and the key file's filename. (Be sure to pass 
the filename of the private key for keyFilename, not the public key.) 



The first step is the same as encryptAndWriteToFile ( ) : the readKeyFile ( ) function 
is called to get the values for the keySize, n, and d variables. 





rsaCipher.py 


137. 


# Read in the message length and the encrypted message from the file. 


138. 


fo = open (messageFil ename) 


139. 


content = fo. read() 


140. 


messageLength , blockSize, encryptedMessage = content. split('_') 


141. 


messageLength = i nt(messageLength) 


142. 


blockSize = int(blockSize) 



The second step is to read in the contents of the file. The messageFil ename file is opened for 
reading (the lack of a second argument means open ( ) will use "read mode") on line 138. The 
read ( ) method call on line 139 will return a string of the full contents of the file. 



Remember that the encrypted file's format has an integer of the message length, an integer for the 
block size used, and then the encrypted integer blocks (all separated by underscore characters). 
Line 140 calls the split ( ) method to return a list of these three values, and the multiple 
assignment trick places the three values into the messageLength, blockSize, and 
message variables respectively. 



Because the values returned by split ( ) will be strings, lines 141 and 142 will set 
messageLength and blockSize to their integer form, respectively. 







rsaCipher.py 


144. 


# Check that key size is greater than block size. 





Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 417 



145. if keySize &lt; blockSize * 8: # * 8 to convert bytes to bits 

146. sys.exit('ERROR: Block size is %s bits and key size is %s bits. 
The RSA cipher requires the block size to be equal to or less than the key 
size. Did you specify the correct key file and encrypted file?' % (blockSize * 
8, keySize)) 

The readFromFileAndDecrypt ( ) function also has a check that the block size is equal to 
or less than the key size. This should always pass, because if the block size was too small, then it 
would have been impossible to create this encrypted file. Most likely the wrong private key file 
was specified for the keyFilename parameter, which means the key would not have decrypted 
the file correctly anyway. 







rsaCipher.py 


148. 


# Convert the encrypted message into large int values. 




149. 


encryptedBlocks = [] 




150. 


for block in encryptedMessage . spl i t( 1 , 1 ) : 




151. 


encryptedBlocks. append (i nt (block)) 





The encryptedMessage string contains many integer characters joined together with 
commas. Line 150's for loop iterates over the list returned by the split ( ) method. This list 
contains strings of individual blocks. The integer form of these strings is appended to the 
encryptedBlocks list (which starts as an empty list on line 149) each time line 151 is 
executed. After the for loop on line 150 completes, the encryptedBlocks list contains 
integer values of the numbers that were in the encryptedMessage string. 



rsaCipher.py 

153. # Decrypt the large int values. 

154. return decryptMessage(encryptedBlocks , messageLength , (n, d) , 
blockSize) 

The list in encryptedBlocks is passed to decryptMessage ( ) , along with 
messageLength, the private key (which is a tuple value of the two integers in n and d), and 
the block size. The decryptMessage ( ) function returns a single string value of the decrypted 
message, which itself is returned from readFileAndDecrypt ( ) on line 154. 



rsaCipher.py 

157. # If rsaCipher.py is run (instead of imported as a module) call 

158. # the main() function. 

159. if name == ' main ': 

160. mainQ 



418 http://inventwithpython.com/hacking 

Lines 159 and 160 call the main ( ) function if this program was run by itself rather than 
imported by another program. 

Practice Exercises, Chapter 24, Set D 

Practice exercises can be found at ht^://inypxAQn^^J^^ra^ce24p. 

Why Can't We Hack the RSA Cipher 

All the different types of cryptographic attacks we've used in this book can't be used against the 
RSA cipher: 

1. The brute-force attack won't work. There are too many possible keys to go through. 

2. A dictionary attack won't work because the keys are based on numbers, not words. 

3. A word pattern attack can't be used because the same plaintext word can be encrypted 
differently depending on where in the block it appears. 

4. Frequency analysis can't be used. Since a single encrypted block represents several 
characters, we can't get a frequency count of the individual characters. 

There are no mathematical tricks that work, either. Remember, the RSA decryption equation is: 

M = C A d mod n 

Where M is the message block integer, C is the ciphertext block integer, and the private key is 
made up of the two numbers (d, n). Everyone (including a cryptanalyst) has the public key file, 
which provides (e, n), so the n number is known. If the cryptanalyst can intercept the ciphertext 
(which we should always assume is possible), then she knows C as well. But without knowing d, 
it is impossible to do the decryption and calculate M, the original message. 

A cryptanalyst knows that d is the inverse of e mod (p-l)x(q-l) and also knows e from the 
public key. But there's no way she knows what (p - 1) x (q - 1) is. There are some hints to figure 
it out though. 

The key sizes are known (it's in the public key file), so the cryptanalyst knows that p and q are 
less than 2 A 1024 and that e is relatively prime with (p - 1) x (q - 1). But e is relatively prime 
with a lot of numbers, and with a range of 0 to 2 A 1024 possible numbers, it is too large to brute- 
force. 

The cryptanalyst has another hint from the public key, though. The public key is two numbers (e, 
n). And from the RSA algorithm she knows that n = pxq. And since p and q are both prime 
numbers, for the given n number there can be only two numbers for p and q. 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 419 



(Remember, prime numbers have no factors besides 1 and themselves. If you multiply two prime 
numbers, that new number will only have the factors of 1 and itself, and also the two prime 
numbers.) 

So to solve everything and hack the RSA cipher, all we need to do is figure out what the factors 
are for n. Since there are two and only two numbers that multiply to n, we won't have several 
different numbers to choose from. Then we can calculate (p - 1) x (q - 1) and then calculate d. 
This seems pretty easy. We already have code that finds factors in primeSieve.py's isPrime ( ) 
function: 

Source code from primeSieve. py 

7. def isPrime(num) : 

8. # Returns True if num is a prime number, otherwise False. 
9. 

10. # Note: Generally, isPrimeO is slower than primeSi eve() . 
11. 

12. # all numbers less than 2 are not prime 

13 . if num &lt; 2 : 

14. return False 
15. 

16. # see if num is divisible by any number up to the square root of num 

17. for i in range(2, i nt (math . sqrt (num)) + 1): 

18. if num % i == 0: 

19. return False 

20. return True 

We can just modify this code to return the first factors it finds (since we know that there can be 
only two factors for n besides 1 and n): 

def i sPrime(num) : 

# Returns (p,q) where p and q are factors of num 

# see if num is divisible by any number up to the square root of num 
for i in range(2, i nt(math . sqrt(num)) + 1): 

if num % i ==0: 

return (i , num / i ) 
return None # no factors exist for num, num must be prime 

We can just call this function, pass it n (which we get from the public key file), and wait for it to 
find our factors, p and q. Then we can know what (p - 1) x (q - 1) is, which means we can 
calculate the mod inverse of e mod (p - 1) x (q - 1), which is d, the decryption key. Then it 
would be easy to calculate M, the plaintext message. 



420 http://inventwithpython.com/hacking 

There's a problem, though. Remember that n is a number that is around 600 digits long. In fact, 
Python's math . sqrt ( ) function can't even handle a number that big (it will give you an error 
message). But even if it could, Python would be executing that for loop for a very, very long 
time. 

Our Sun doesn't have enough mass to eventually go supernova, but in 5 billion years it will 
expand into a red giant star and utterly destroy the Earth. Even if your computer was still running 
then, there's still no chance that 5 billion years is long enough to find the factors of n. That is how 
big the numbers we are dealing with are. 

And here's where the strength of the RSA cipher comes from: Mathematically, there is no 
shortcut to finding the factors of a number. It's easy to look at a small number like 15 and say, 
"Oh, 5 and 3 are two numbers that multiply to 15. Those are factors of 15." But it's another thing 
entirely to take a (relatively small) number like 178,565,887,643,607,245,654,502,737 and try to 
figure out the factors for it. The only way we can try is by brute -forcing through numbers, but 
there are too many numbers. 

It is really easy to come up with two prime numbers p and q and multiply them together to get n. 
But it is reasonably impossible to take a number n and figure out what p and q are. These facts 
make the RSA cipher usable as a cryptographic cipher. 

Summary 

That's it! This is the last chapter of the book! There is no "Hacking the RSA Cipher" chapter 
because there's no straightforward attack on the mathematics behind the RSA cipher. And any 
brute-force attack would fail, because there are far too many possible keys to try: the keys are 
literally hundreds of digits long. If you had a trillion buildings each with a trillion computers that 
each tried a trillion keys every nanosecond, it would still take longer than the universe as been in 
existence to go through a fraction of the possible keys. (And the electric bill for all those 
computers would bankrupt every industrialized nation on the planet.) 

That's a lot of possible keys. 

The RSA algorithm is a real encryption cipher used in professional encryption software. When 
you log into a website or buy something off the Internet, the RSA cipher (or one like it) is used to 
keep passwords and credit card numbers secret from anyone who may be intercepting your 
network traffic. 

Actually, while the basic mathematics used for professional encryption software are the same as 
described in this chapter, you probably don't want to use this program for your secret files. The 
hacks against an encryption program like rsaCipher.py are pretty sophisticated, but they do exist. 
(For example, the "random" numbers returned from random . randint ( ) aren't truly random 



Email questions to the author: al@inventwithpython.com 



Chapter 24 - Public Key Cryptography and the RSA Cipher 421 



and can be predicted, meaning that a hacker could figure out which "random" numbers were used 
for the prime numbers of your private key.) 

You've seen how all the previous ciphers in this book have each been hacked and rendered 
worthless. In general, you don't want to write your own cryptography code for things you want to 
keep secret, because you will probably make subtle mistakes in the implementation of these 
programs. And hackers and spy agencies use these mistakes to hack your encrypted messages. 

A cipher is only secure if everything but the key can be revealed but still keep the message a 
secret. You cannot rely on a cryptanalyst not having access to the same encryption software or 
knowing what cipher you used. Remember Shannon's Maxim: The enemy knows the system! 

Professional encryption software is written by cryptographers who have spent years studying the 
mathematics and potential weaknesses of various ciphers. Even then, the software they write is 
inspected by other cryptographers to check for mistakes or potential weaknesses. You are 
perfectly capable of learning about these cipher systems and cryptographic mathematics too. It's 
not about being the smartest hacker, but spending the time to study to become the most 
knowledgeable hacker. 

1 hope you've found this book to be a helpful start on becoming an elite hacker and programmer. 
There is a lot more to learn about programming and cryptography than what is in this book, but I 
encourage you explore and learn more! One great book about the general history of cryptography 
that 1 highly recommend is "The Code Book" by Simon Singh. You can go to 
http://inypy,cor^^ for a list of other books and websites to learn more about 

cryptography. Feel free to email me your programming or cryptography questions at 
al @ inventwithpython. com. 



Good luck! 



422 http://inventwithpython.com/hacking 



About the Author 




Albert Sweigart (but you can call him Al), is a software developer in San Francisco, California 
who enjoys haunting coffee shops and making useful software. Hacking Secret Ciphers with 
Python is his third book. 

His first two books, Invent Your Own Computer Games with Python and Making Games with 
Python &amp; Pygame can be read online for free at http;//i.nyentwithpy.thon,co^ 

He is originally from Houston, Texas. He laughs out loud when watching park squirrels, which 
makes people think he's a simpleton. He almost ended up working at the NSA after college, but 
then again we all do dumb things when we are young. 

‚Ä¢ Email: al@inventwithpython.com 

‚Ä¢ Twitter: @AlSweigart 



Email questions to the author: al@inventwithpython.com 



</pre>        </div><!--/.container-->
              </main>
    </div><!--/#wrap-->
    
    <!-- Timing ...
     rendered on: www29.us.archive.org
 seconds diff sec               message   stack(file:line:function)
=========================================================
  0.0000   0.0000         petabox start   var/cache/petabox/petabox/www/sf/download.php:1:require
                                             |common/ia:66:require_once
                                             |setup.php:383:log
  0.0065   0.0065      redis_read start   var/cache/petabox/petabox/www/sf/download.php:79:main_wrap
                                             |download.php:98:main
                                             |download.php:298:getItem
                                             |common/Item.inc:78:parseMetadata
                                             |Item.inc:139:get_obj
                                             |Metadata.inc:610:_get_obj
                                             |Metadata.inc:639:run_pipeline
                                             |Metadata.inc:1682:read
                                             |Metadata/AdapterPipeline.inc:278:_read
                                             |AdapterPipeline.inc:314:pipeline
                                             |AdapterPipeline.inc:452:fetch
                                             |AdapterPipeline.inc:859:execute_pipeline
                                             |RecordServer.inc:184:log
  0.0101   0.0036     redis_read finish   var/cache/petabox/petabox/www/sf/download.php:79:main_wrap
                                             |download.php:98:main
                                             |download.php:298:getItem
                                             |common/Item.inc:78:parseMetadata
                                             |Item.inc:139:get_obj
                                             |Metadata.inc:610:_get_obj
                                             |Metadata.inc:639:run_pipeline
                                             |Metadata.inc:1682:read
                                             |Metadata/AdapterPipeline.inc:278:_read
                                             |AdapterPipeline.inc:314:pipeline
                                             |AdapterPipeline.inc:452:fetch
                                             |AdapterPipeline.inc:859:execute_pipeline
                                             |RecordServer.inc:193:log
  0.0403   0.0302   begin session_start   var/cache/petabox/petabox/www/sf/download.php:79:main_wrap
                                             |download.php:98:main
                                             |download.php:481:stream
                                             |download.php:843:head
                                             |common/Nav.inc:153:__construct
                                             |Nav.inc:224:session_start
                                             |Cookies.inc:48:log
  0.0404   0.0001    done session_start   var/cache/petabox/petabox/www/sf/download.php:79:main_wrap
                                             |download.php:98:main
                                             |download.php:481:stream
                                             |download.php:843:head
                                             |common/Nav.inc:153:__construct
                                             |Nav.inc:224:session_start
                                             |Cookies.inc:60:log
  0.0881   0.0477              bug dump   var/cache/petabox/petabox/www/sf/download.php:79:main_wrap
                                             |download.php:98:main
                                             |download.php:481:stream
                                             |download.php:873:footer
                                             |common/setup.php:148:footer
                                             |Nav.inc:942:dump
                                             |Bug.inc:94:log
    -->
    <script nonce="">
if (typeof archive_analytics !== 'undefined') {
  archive_analytics.send_pageview_on_load(archive_analytics);
  archive_analytics.process_url_events(location);
  var vs = archive_analytics.get_data_packets();
  for (var i in vs) {
    if (!vs[i]) {
      vs[i] = {};
    }
    vs[i]['cache_bust']=Math.random();
    vs[i]['server_ms']=88;
    vs[i]['server_name']="www29.us.archive.org";
      }

  if (document.querySelectorAll('.more_search').length) {
    archive_analytics.send_scroll_fetch_base_event();
  }
}
</script>
          <img src="./Full text of _Hacking Secret Ciphers With Python__files/0.gif" alt="">
          <noscript>
        <img src="//athena.archive.org/0.gif?kind=track_js&track_js_case=disabled&cache_bust=857881561" />
      </noscript>
          <script nonce="">
        document.addEventListener('DOMContentLoaded', function() {
          if (typeof archive_analytics !== 'undefined')
            archive_analytics.create_tracking_image('in_page_executes');
        });
      </script>
      
  

    </body></html>